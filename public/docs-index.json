{
  "generated": "2025-06-27T16:26:09.561Z",
  "sites": {
    "arweave": {
      "name": "Arweave Cookbook",
      "baseUrl": "https://cookbook.arweave.net",
      "pages": [
        {
          "url": "https://cookbook.arweave.net/getting-started/index.html",
          "title": "Cooking with the Permaweb",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Cooking with the PermawebThe Permaweb Cookbook is a developer resource that provides the essential concepts and references for buiding applications on the Permaweb. Each concept and reference will focus on specific aspects of the Permaweb development ecosystem while providing additional details and usage examples.# DevelopersWelcome to the Arweave development community, where the past is forever etched in the blockchain and the future is full of endless possibilities. Let's build the decentralized web together!Read More# ContributingThe Cookbook is designed in a way that makes it easy for new Permaweb developers to contribute. Even if you don't know how to do something, contributing to the cookbook is a great way to learn!Check out all open issues here. Contribution guidelines here. if you find the cookbook is missing a concept, guide or reference, please add an issue.Read More# How to Read the CookbookThe Permaweb Cookbook is split into different sections, each aimed at a different goal.SectionDescriptionCore ConceptsBuilding blocks of the Permaweb that are good to know for developmentGuidesSnack-sized guides about different tools for developmentReferencesReferences to commonly needed code snippetsStarter KitsFront-end Framework Starters to get you started building on the Permaweb in no time# Quick StartsThese are small guides to help developers from every experience level to ship code the the permaweb.Hello World (NodeJS) Core Concepts",
          "estimatedWords": 217,
          "lastModified": "2025-06-27T16:25:43.536Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:25:43.537Z"
        },
        {
          "url": "https://cookbook.arweave.net/index.html",
          "title": "Build on the Permaweb",
          "content": "Contributors: Tom Wilson, ropats16, DevJeff, Dan MacDonaldLast Updated: Edit# Cooking with the PermawebThe Permaweb Cookbook is a developer resource that provides the essential concepts and references for buiding applications on the Permaweb. Each concept and reference will focus on specific aspects of the Permaweb development ecosystem while providing additional details and usage examples.# DevelopersWelcome to the Arweave development community, where the past is forever etched in the blockchain and the future is full of endless possibilities. Let's build the decentralized web together!Read More# ContributingThe Cookbook is designed in a way that makes it easy for new Permaweb developers to contribute. Even if you don't know how to do something, contributing to the cookbook is a great way to learn!Check out all open issues here. Contribution guidelines here. if you find the cookbook is missing a concept, guide or reference, please add an issue.Read More# How to Read the CookbookThe Permaweb Cookbook is split into different sections, each aimed at a different goal.SectionDescriptionCore ConceptsBuilding blocks of the Permaweb that are good to know for developmentGuidesSnack-sized guides about different tools for developmentReferencesReferences to commonly needed code snippetsStarter KitsFront-end Framework Starters to get you started building on the Permaweb in no time# Quick StartsThese are small guides to help developers from every experience level to ship code the the permaweb.Hello World (No Code)",
          "estimatedWords": 220,
          "lastModified": "2025-06-27T16:25:44.017Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:44.017Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/index.html",
          "title": "Core Concepts",
          "content": "Contributors: Tom Wilson, Dan MacDonald, Jack Frain, bobinsteinLast Updated: Edit# Core ConceptsFoundations of Arweave and the Permaweb.Posting TransactionsMetadata (Tags)QueryingFetching DataTransaction TypesBundlesPath ManifestsWallets and KeysPermawebPermaweb ApplicationsGateway ServicesBundling ServicesArweave File System (ArFS)Data modelEntity TypesContent TypesPrivacySchema DiagramsDo you think a permaweb core concept is missing? Create a issue at Githubopen in new window or consider contributing Getting Started Guides",
          "estimatedWords": 56,
          "lastModified": "2025-06-27T16:25:44.103Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:44.103Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/post-transactions.html",
          "title": "Posting Transactions",
          "content": "Contributors: Dan MacDonald, Artem B, Luke Cassady-Dorion, Nichole Christie, Ros McMahon, Tom Wilson, Weronika K, ropats16, weibogaoLast Updated: Edit# Posting TransactionsüòçThere are several ways to post transactions to Arweave. Each has its own unique affordances and constraints. The diagram below illustrates the four main approaches to posting transactions.Direct to Peer,Direct to Gateway, Bundled, and Dispatched. Guaranteed TransactionsWhen posting a large quantity of transactions or when fast settlement time is desireable consider using a bundling service. Bundlers settle large volumes of transactions immediately and make the transaction data available within milliseconds. The bundling service holds onto posted transactions until they are confirmed on-chain. If the transactions are not included in the most recent block the bundling service re-posts them with each new block until they are recorded on chain with a sufficient number of confirmations.# Direct TransactionsTransactions posted directly to Arweave come in two varieties wallet-to-wallet transactions and data transactions. The first transfers AR tokens between wallet addresses. The second posts data to Arweave and pays the associated storage costs.Interestingly, data transactions may also transfer AR tokens to a wallet address while paying storage costs at the same time.All transactions allow the user to specify up to 2KB worth of metadata in the form of custom tags.# Direct to PeerTransactions may be posted directly to an Arweave peer (mining node). This is perhaps the most decentralized means of posting a transaction as clients can choose what peer they wish to post to.This approach is not without drawbacks. Peers may come and go making it difficult to reliably post transactions from an app. While it's possible to query a list of active peers and choose one before posting it adds overhead and friction to the process. Additionally, transactions posted to peers are only queryable at the gateway after being mined in a block. This introduces a 1-2 minute delay between posting the transaction to a peer and it being available to read in a browser from a gateway.For the above reasons, developers tend to configure arweave-js to point to a gateway when posting direct transactions as the optimistic cache at the gateway makes the transaction available almost immediately.# Direct to GatewayGateways sit between clients and Arweave's network of peers. One of the primary functions of the gateway is to index transactions and optimistically cache the data posted to the network while waiting for it to be included in a block. This makes the transaction queryable in a \"Pending\" state almost instantly which allows applications built on top of a gateway to be more responsive. There is still a risk of transactions dropping out of the optimistic cache if they are not mined in a block by the peers.An example of how to post a direct transaction using arweave-js can be found in this guide.# Bundled TransactionsServices built on top of Arweave that provide additional utility for Permaweb builders are sometimes called Permaweb Services. A bundler is one such service. Bundlers take multiple individual transactions and bundle them together into a single transaction that is posted directly to Arweave. In this way a single transaction at the protocol level can contain tens of thousands of bundled transactions. There is one restriction, however, only data transactions can be included in a bundle. Wallet-to-wallet transactions (that transfer AR tokens between wallet addresses) must be done as individual transactions posted directly to Arweave.# Dispatched TransactionsAnother way to post bundled transactions is from the browser. While browsers enforce some constraints around the size of data that can be uploaded, browser based wallets are able to post transactions to bundlers. Arweave browser wallets implement a dispatch() API method. If you are posting small transactions (100KB or less) you can use the wallets dispatch() method to take advantage of bundled transactions.An example of how to post a 100KB or less bundled transaction with an Arweave wallets dispatch() method can be found in this guide.# Resourcesarweave-js exampledispatch examplearseeding-js example Metadata (Tags)",
          "estimatedWords": 651,
          "lastModified": "2025-06-27T16:25:44.621Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:44.621Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/tags.html",
          "title": "Transaction Metadata (Tags)",
          "content": "Contributors: Tom Wilson, Dan MacDonald, Luke Cassady-DorionLast Updated: Edit# Transaction Metadata (Tags)Arweave can be thought of as a permanent append-only hard drive where each entry on the drive is its own unique transaction. Transactions have a unique ID, signature, and owner address for the address that signed and paid for the transaction to be posted. Along with those header values, the Arweave protocol allows users to tag transactions with custom tags. These are specified as a collection name value pairs appended to the transaction. These tags make it possible to query Arweave and find all the Transactions that include a particular tag or tags. The ability to query and filter transactions is critical to supporting apps built on Arweave.# What are Transaction Tags?Transaction tags are key-value pairs, where the combination of base64URL keys and values must be less than the maximum of 2048 bytes for an arweave native transaction.Some common examples of transaction tags include:Content-Type: Used to specify the MIME type of content for render on the permaweb.App-Name: This tag describes the app that is writing the dataApp-Version: This tag is the version of the app, paired with App-NameUnix-Time: This tag is the a unix timestamp, seconds since epoch.Title: Used to give a name or brief description of the content stored in the transaction.Description: Used to provide a longer description of the content.Transaction tags can be used for a variety of purposes, such as indexing transactions for search, organizing transactions into categories, or providing metadata about the content stored in a transaction.# Some good things to know about Transaction TagsTransaction tags are encoded as Base64URL encoded strings for both the key and value. This makes it possible to post arrays of bytes as keys or values and transfer them safely over http. While it's not human readable without decoding, it shouldn't be considered encryption.The max total size of Transaction tags for transaction posted directly to Arweave is 2048 bytes. This size is determined by the concatenation of all keys and all values of the transaction tags.Transaction tags can be used in GraphQL queries to return a filtered set of transaction items.# Common Tags used in the communityTag NameDescriptionUse CasesApp-NameMost commonly used for SmartWeave IdentifiersCommon values are SmartWeaveContract, SmartWeaveAction, and SmartWeaveContractSourceApp-VersionThe version of this data, it may represent the app consuming this information0.3.0 is the current SmartWeave VersionContent-TypeMIME Type to identify the data contained in the transactiontext/html, application/json, image/pngUnix-TimeThis tag is the a unix timestamp, seconds since epochThe time the transaction is submittedTitleANS-110 Standard for describing contentProviding a name for an Atomic AssetTypeANS-110 Standard for categorization of dataa type can classify a permaweb asset# Examplesconst tx = await arweave.createTransaction({ data: mydata }); tx.addTag(\"Content-Type\", \"text/html\"); tx.addTag(\"Title\", \"My incredible post about Transaction Tags\"); tx.addTag(\"Description\", \"This is one post you do not want to miss!\"); tx.addTag(\"Topic:Amazing\", \"Amazing\"); tx.addTag(\"Type\", \"blog-post\"); await arweave.transactions.sign(tx, jwk); await arweave.transactions.post(tx); # SummaryUnderstanding how Transaction Tags factor into the Arweave tech stack can provide context on how to solve problems using the Permaweb as an application platform. Tags provide a tool to consume and create common data standards and patterns to encourage a non-rivalous data experience on the Permaweb. The result gives users of the ecosystem the choice of applications to consume and create content as their data is always with the user not the application. Posting Transactions Querying",
          "estimatedWords": 548,
          "lastModified": "2025-06-27T16:25:44.690Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:44.690Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/queryTransactions.html",
          "title": "Querying Transactions",
          "content": "Contributors: Dan MacDonald, Luke Cassady-Dorion, Ros Mc Mahon, Tom Wilson, wujunzeLast Updated: Edit# Querying TransactionsIt isn't enough to store data permanently, for Arweave to be useful the data also needs to be discoverable and retrievable. This guide summarizes the different approaches to querying data on Arweave.# GraphQLOver time, indexing services that implement a GraphQL interface have became the preferred method for querying transaction data on Arweave. An indexing service reads transaction and block headers as they are added to the network (usually from a full Arweave node which the service operates). Once read, the header info is inserted into a database where it can be indexed and efficiently queried. The indexing service uses this database to provide a GraphQL endpoint for clients to query.GraphQL has a few advantages that make it ideal for retrieving query data sets. It enables indexing services to create a single endpoint that can then be used to query all types data. The service is able to return multiple resources in a single request as opposed to making an HTTP request for each resource (like one would with a REST API). With GraphQL, clients can batch multiple requests in a single round-trip and specify exactly what data is needed which increases performance.The following GraphQL example queries all the transaction ids from a given owners wallet address that have a \"Type\" tag with a value of \"manifest\". For more information about tags, read the guide on Transaction Tags.const queryObject = { query: `{ transactions ( owners:[\"${address}\"], tags: [ { name: \"Type\", values: [\"manifest\"] } ] ) { edges { node { id } } } }` }; const results = await arweave.api.post('/graphql', queryObject); # Public Indexing Serviceshttps://arweave.net/graphqlopen in new windowhttps://arweave-search.goldsky.com/graphqlopen in new windowhttps://knn3-gateway.knn3.xyz/arseeding/graphqlopen in new window# Inspecting the BlocksEach piece of data uploaded to Arweave has its own unique transaction id and is included in a unique block which is then added to the blockchain. The data associated with each transaction is split up into 256KB chunks and appended sequentially to Arweave's dataset. It is possible to walk back, block by block, from the current blockopen in new window and inspect each one for the transaction id in question. Once found, the chunks offsets can be retrieved from the block and used to request chunks directly from an Arweave peer. This is the lowest level way to locate and read data on the network. Thankfully, less labor intensive approaches like GraphQL are available.# ARQLWARNINGARQL is deprecated and replaced by GraphQL queries at a gateway or indexing service. Some peers may still honor ARQL requests but the availability and accuracy of results are not guaranteed.Arweave Query Language (ARQL) was used early on in Arweave's development. Along side blocks and chunks, peers also maintained a SQL database which indexed individual transactions. Clients could query a peer using ARQL and get back transaction data. The following is an example ARQL query syntax.let get_mail_query = { op: 'and', expr1: { op: 'equals', expr1: 'to', expr2: address }, expr2: { op: 'equals', expr1: 'App-Name', expr2: 'permamail' } } const res = await this.arweave.api.post(`arql`, get_mail_query) This approach to querying was sufficient the weave dataset was small and easy to index. As Arweave adoption accelerated, indexing the data set and responding to ARQL queries resulted in increasing computational costs. Over time as mining became more and more competitive, peers became less and less likely to be able to afford to offer the ARQL service. This ultimately became the impetus for indexing services and the GraphQL querying common on Arweave today.There is a pathway back to being able to query data directly from peers however. The Permaweb Payments Protocol (P3)open in new window is a specification developed by the community to enable clients to pay for service. Using P3, peers wishing to offer indexing service could afford to operate it profitably it by charging for the service.# ResourcesQuerying Arweave GuideArDB packagear-gql packageGraphQL Reference Metadata (Tags) Fetching Data",
          "estimatedWords": 652,
          "lastModified": "2025-06-27T16:25:45.181Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:45.181Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/bundles.html",
          "title": "Transaction Bundles",
          "content": "Contributors: Dan MacDonald, Jack Smith (Longview Labs), Luke Cassady-Dorion, Tom WilsonLast Updated: Edit# Transaction Bundles# What is a Bundle?A transaction bundle is a special type of Arweave transaction. It enables multiple other transactions and/or data items to be bundled inside it. Because transaction bundles contain many nested transactions they are key to Arweave's ability to scale to thousands of transactions per second.Users submit transactions to a bundling service, such as turboopen in new window, which combines them into a 'bundle' with other transactions and posts them to the network.# How Do Bundles Help Arweave?# AvailabilityBundling services guarantee that bundled transactions are reliably posted to Arweave without dropping.Transaction IDs of the bundled transactions are immediately made available, meaning the data can instantly be accessed as if it was already on the Arweave network.# ReliabilityTransactions posted to Arweave can occasionally fail to confirm (resulting in a dropped transaction) due to a number of reasons, such as high network activity. In these instances transactions can become orphaned, i.e. stuck in the mempool and eventually removed.Bundlers solve this problem by continually attempting to post bundled data to Arweave, assuring that it does not fail or get stuck in the mempool.# ScalabilityBundles can store up to 2256 transactions, each of which are settled as a single transaction on Arweave. This makes Arweave blockspace scale to support almost any use case.# What are Nested Bundles?Bundles can include data items for uploading to Arweave and those data item can themselves be a bundle.This means it is possible to upload a bundle of bundles, or in other words nested bundles.Nested bundles have no theoretical limit on nesting depth, meaning that transaction throughput can be increased drastically.Nested bundles might be useful for when you have different groups of bundled data that you want to guarantee reach Arweave altogether, and at the same time.Sources and Further Reading:Ardrive Turboopen in new windowANS-104 Standardopen in new window Path Manifests",
          "estimatedWords": 317,
          "lastModified": "2025-06-27T16:25:45.256Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:45.256Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/manifests.html",
          "title": "Path Manifests",
          "content": "Contributors: bobinstein, Dan MacDonald, Jack Smith, dmacLast Updated: Edit# Path Manifests# OverviewWhen uploading files to Arweave each file is assigned its own unique transaction ID. By default these ID's aren't grouped or organized in any particular manner.One picture of your cat might be stored with a transaction ID of bVLEkL1SOPFCzIYi8T_QNnh17VlDp4RylU6YTwCMVRwopen in new window, while another with FguFk5eSth0wO8SKfziYshkSxeIYe7oK9zoPN2PhSc0open in new window as its transaction ID.Cat1Cat2bVLEkL1SOPFCzIYi8T_QNnh17VlDp4...FguFk5eSth0wO8SKfziYshkSxeIYe7oK9zoPN2PhSc0These transaction ID's are a bit unwieldy and make it difficult to find all of your relevant files. Without a path manifest, if you uploaded 100 pictures of your cat you would need to keep track of 100 different IDs and links!Path Manifests are a way to link multiple transactions together under a single base transaction ID and give them human readable file names. In relation to the cat example, you could have one base transaction ID to remember and use it like a folder - accessing your cat pictures with more memorable filenames like {base id}/cat1.jpgopen in new window, {base id}/cat2.jpgopen in new window, etc.Creating grouped sets of readable file names is essential for creating practical applications on Arweave, and unlocks the ability to host websites or other file collections as explored in the examples below.# What Can You Use Manifests For?Any time you need to group files in a hierarchical way, manifests can be useful. For example:Storing NFT collections:https://arweave.net/X8Qm‚Ä¶AOhA/0.pngopen in new windowhttps://arweave.net/X8Qm‚Ä¶AOhA/1.pngopen in new windowThis mirrors the common base path approach used by NFT collections when linking to NFT images and metadata on a storage API or IPFS.Hosting websites:https://arweave.net/X8Qm‚Ä¶AOhA/index.htmlhttps://arweave.net/X8Qm‚Ä¶AOhA/styles.csshttps://arweave.net/X8Qm‚Ä¶AOhA/public/favicon.png# Manifest StructurePath Manifests are a special format of transaction created and posted to Arweave using the Tags:{ name: \"Content-type\", value: \"application/x.arweave-manifest+json\" }and having JSON formatted transaction data that matches the example below.{ \"manifest\": \"arweave/paths\", \"version\": \"0.2.0\", \"index\": { \"path\": \"index.html\" }, \"fallback\": { \"id\": \"cG7Hdi_iTQPoEYgQJFqJ8NMpN4KoZ-vH_j7pG4iP7NI\" }, \"paths\": { \"index.html\": { \"id\": \"cG7Hdi_iTQPoEYgQJFqJ8NMpN4KoZ-vH_j7pG4iP7NI\" }, \"js/style.css\": { \"id\": \"fZ4d7bkCAUiXSfo3zFsPiQvpLVKVtXUKB6kiLNt2XVQ\" }, \"css/style.css\": { \"id\": \"fZ4d7bkCAUiXSfo3zFsPiQvpLVKVtXUKB6kiLNt2XVQ\" }, \"css/mobile.css\": { \"id\": \"fZ4d7bkCAUiXSfo3zFsPiQvpLVKVtXUKB6kiLNt2XVQ\" }, \"assets/img/logo.png\": { \"id\": \"QYWh-QsozsYu2wor0ZygI5Zoa_fRYFc8_X1RkYmw_fU\" }, \"assets/img/icon.png\": { \"id\": \"0543SMRGYuGKTaqLzmpOyK4AxAB96Fra2guHzYxjRGo\" } } } fallback:Manifest version 0.2.0 introduced the fallback attribute. fallback is an object that accepts the sub attribute id, which defines an Arweave data item transaction id for the resolver to fall back to if it fails to correctly resolve a requested path.Source and Further Reading in the official Arweave Path Manifest docs: Arweave Docsopen in new window Bundles",
          "estimatedWords": 391,
          "lastModified": "2025-06-27T16:25:45.775Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:45.775Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/keyfiles-and-wallets.html",
          "title": "Wallets and Keys",
          "content": "Contributors: Dan MacDonald, Jack Smith (Longview Labs)Last Updated: Edit# Wallets and Keys# Arweave WalletsOn Arweave a wallet secures a unique address on the blockchain. The address is used to keep track of your $AR balance, and interact with the Arweave network - such as sending transactions, or interacting with SmartWeave Contracts.Like most blockchains, the concept of a wallet on Arweave is slightly misleading.A Wallet does not \"hold\" any tokens itself; token balances are stored on the blockchain and linked to the wallets address. Instead a wallet holds the cryptographic public-private key pair that can be used to sign transactions to post data or transfer tokens. The wallet owner (the person with access to the wallet's private key) is the only one who can sign transactions for the address and access its funds.# Keypair and Wallet FormatArweave uses 4096bit RSA-PSS key-pairs stored using the JWK (JSON Web Keys) format. The JWK format can be used to store many types of cryptographic keys, not just RSA key-pairs.Shown here is the contents of a JWK file which describes an RSA-PSS key-pair. The values are abbreviated so they are not accidentally used as the sender or recipient of an on-chain transaction. When storing RSA-PSS key-pairs the value associated with n in the JWK is your wallets public key and can be shared safely without compromising the security of your wallet.{ \"d\": \"cgeeu66FlfX9wVgZr5AXKlw4MxTlxSuSwMtTR7mqcnoE...\", \"dp\": \"DezP9yvB13s9edjhYz6Dl...\", \"dq\": \"SzAT5DbV7eYOZbBkkh20D...\", \"e\": \"AQAB\", \"ext\": true, \"kty\": \"RSA\", \"n\": \"o4FU6y61V1cBLChYgF9O37S4ftUy4newYWLApz4CXlK8...\", \"p\": \"5ht9nFGnpfW76CPW9IEFlw...\", \"q\": \"tedJwzjrsrvk7o1-KELQxw...\", \"qi\": \"zhL9fXSPljaVZ0WYhFGPU...\" } Your private key is also stored in the JWK, primarily under the value associated with d but it is also partially derived from some of the other values in the JWK. The private key is like the password for your wallet - which can be used to create digital signatures (such as for signing transactions), or decrypting data.These JWKs are actual json files created and exported from a wallet app such as Arweave.appopen in new window or generated through code using arweave-jsopen in new window.When using a wallet app to generate your key-pair your private key can also be represented as a mnemonic seed phrase, which in some cases can be used as an alternative to sign transactions and/or recover your wallet.# Wallet SafetyYour private key must be kept confidential at all times as it has the ability to transfer tokens from your address to someone elses. As a developer, make sure not to include your keyfile in any public GitHub repositories or host it anywhere else publicly.# Wallet AddressesInterestingly the address of your wallet is derived from its public key. While it's safe to share your public key with others, a 4096bit public key is a bit large to pass around conveniently. To reduce that overhead and keep wallet addresses a little more human readable, the SHA-256 hash of the public key is Base64URL encoded and used as the wallet address. This security and deterministically links a unique 43 character wallet address to the wallets public-key and provides a convenient shorthand that anyone with the public-key can verify.# WalletsArweave.appopen in new window - Arweave web wallet to deploy permanent data, connect your accounts securely to decentralized applications, and navigate the weave.ArConnectopen in new window - Arweave Wallet Browser Extension# Sources and Further Reading:Arweave Docsopen in new windowJSON Web Key Format (RFC 7517)open in new window Permaweb",
          "estimatedWords": 554,
          "lastModified": "2025-06-27T16:25:45.842Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:45.842Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/permaweb.html",
          "title": "Welcome to the Permaweb",
          "content": "Contributors: Tom Wilson, Dan MacDonald, felwintrrLast Updated: Edit# Welcome to the PermawebThe permaweb is like the web, but permanent. Developers build on top of permaweb services to create apps and sites that will exist forever on Arweave.Benefits of the permaweb.Sites and apps are permanent, you never have to worry about them going away (even if the team supporting them moves on)App developers have to make sure every new version of the app actually adds value, otherwise, why would you switch off the old one.Because all Permaweb apps share a common storage layer, Arweave, they can all compose with one anther's data.Your data is owned by your wallet and can follow you from app to app.# Compare Traditional Web vs PermawebFor more information about the permaweb check out the medium postopen in new window. Wallets and Keys Arweave File System (ArFS)",
          "estimatedWords": 140,
          "lastModified": "2025-06-27T16:25:46.340Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:46.340Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/permawebApplications.html",
          "title": "Permaweb Applications",
          "content": "Contributors: Tom Wilson, Dan MacDonald, Artem B, Hachiman, Luke Cassady-Dorion, mrsaifullah52Last Updated: Edit# Permaweb ApplicationsA permaweb application is a type of web page or web app that runs in your browser. What makes it a permaweb app is that it is deployed to Arweave and saved forever. Even if the team that developed it moves on users can rest assured the permaweb app will stay online and available. A huge advantage to permaweb apps is that they save their data on Arweave which means it can easily be imported into other apps that might improve on the one your currently using.# What is the permaweb?INFORMATIONFor a deeper dive into the permaweb check out this article on The PermawebThe permaweb is a collection of sites, apps, and SmartContracts built on top of the Arweave's Permaweb Services. The core parts of the Permaweb are the following:Gateway Service (ex. arweave.net, arweave.live, ar.io)Bundling Service (ex. ardrive turbo)Sequencer Service (ex. warp.cc)Index Service (ex goldsky)# Gateway ServicesGateway services are the bridge between data on Arweave and displaying data in the browser. Gateways often provide indexing service along side serving transaction data, exposing graphQL endpoints for querying Arewave transactions.# Bundling ServicesBundling services aggregate transactions into transaction bundles and make sure those bundles are posted directly to Arweave. By using a bundling service like Irys.network you can post hundreds of thousands of transactions in a single Arweave block.# Sequencing ServicesSequencers enables high performance for SmartWeave Contracts to calculate business logic stored on the Arweave network.# Indexing ServicesIndexing services listen to all the transactions on Arweave and import them into an indexed database suitable for fast querying. They then expose a graphQL endpoint so permaweb apps can make optimized queries for Arweave data.These services work together to form the Permaweb Services Layer and gives developers the power to build fully decentralized applications on the permaweb.# Application DevelopmentApproaching application development with the permaweb is similar to Single Page Application development, the application consists of frontend functionality that is executed in a web browser, and uses GraphQL (Read/Query), Irys (Write), and SmartWeave (Decentralized computation) to make up the business logic and persistance layer of the application.By leveraging modern web application frameworks and the Path Manifest specification, developers can deploy web sites and applications to the permaweb.To learn more about creating and deploying Permaweb Apps, check out our starter kits in your favorite framework:ReactSvelteVueMissing my framework?Can't find your framework, why don't you contribute? How to contribute to the cookbook Gateway Services",
          "estimatedWords": 409,
          "lastModified": "2025-06-27T16:25:46.402Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:46.402Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/gateways.html",
          "title": "Gateways",
          "content": "Contributors: Jack Smith (Longview Labs), wujunzeLast Updated: Edit# GatewaysData uploaded to the Arweave network (or the permawebopen in new window) isn't always immediately easy to work with.# What is a Gateway?Gateways are sometimes referred to as the \"front door to the permaweb\". They act as an interface between Arweave and end-users, making it easy to access data or use permaweb applications from your web browser.For example, accessing a HTML file stored on Arweave will be displayed as a web page in your browser. The same goes for viewing images, downloading files, viewing JSON data, or any other file stored on Arweave. This makes interacting with the permaweb very similar to using the traditional web.# Other Roles of GatewaysOther than serving data for users to access, gateways offer other services such as:Caching frequently accessed data and transactionsIndexing and querying transactions (through Arweave tags and a GraphQl interface)Seeding transactions throughout the Arweave networkContent moderation (content policies to choose which data is or isn't served)# Gateways and the Arweave ProtocolAlthough gateways play a large role in allowing content to be accessed on Arweave, they are not part of the core protocol.This means hosting and running gateways is separate to running a node securing the Arweave network (although are frequently done together).As gateways are not part of the core protocol, there is no built-in incentive structure like the rewards or incentives for mining. This allows gateway operators or external services to choose how they want to structure their incentive system, leading to a more decentralized and democratic model. Individual applications could even operate their own gateway to allow for better caching and performance of their permaweb applications.Some popular gateways include arweave.netopen in new window ran by the Arweave team, and others like arweave.worldopen in new window arweave.asiaopen in new window arweave.liveopen in new window, and g8way.ioopen in new window. However, operating gateways is being made easier and more accessible through teams such as AR.IOopen in new window.# Sources and Further ReadingArWikiopen in new windowAR.IOopen in new window Permaweb Applications Bundling Services",
          "estimatedWords": 337,
          "lastModified": "2025-06-27T16:25:47.547Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:47.547Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/bundlers.html",
          "title": "Bundling Services",
          "content": "Contributors: Dan MacDonald, Luke Cassady-Dorion, Pawan Paudel, Tom WilsonLast Updated: Edit# Bundling ServicesWith bundling services users can post their data transactions to a bundling service to have it \"bundled\" together with other users transactions and posted as a single Arweave transaction in an upcoming Arweave block.# What is a bundle?A description of transaction bundles and their benefits can be found here.# What is a Bundler node?A bundler is a node which is responsible for accepting transactions or data items from users, bundling them, and posting them to the Arweave network (with a guarantee they will be uploaded with a specific transaction ID).Services:Turboopen in new windowWhich make sure the data is persisted until it is uploaded to Arweave.# Supporting multiple currenciesA key feature of bundling services is that because they pay for the base Arweave transaction to be posted (using AR tokens) they can choose to enable payments of storage fees on a variety of different tokens. This is the main entry point for other chains to enable Arweave's permanent storage for their users. Gateway Services",
          "estimatedWords": 175,
          "lastModified": "2025-06-27T16:25:48.070Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:48.070Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/arfs.html",
          "title": "ArFS Protocol A Decentralized File System on Arweave",
          "content": "Contributors: bobinsteinLast Updated: Edit# ArFS Protocol: A Decentralized File System on ArweaveArweave File System, or ‚ÄúArFS‚Äù is a data modeling, storage, and retrieval protocol designed to emulate common file system operations and to provide aspects of mutability to your data hierarchy on Arweaveopen in new window's otherwise permanent, immutable data storage blockweave.Due to Arweave's permanent, immutable and public nature traditional file system operations such as permissions, file/folder renaming and moving, and file updates cannot be done by simply updating the on-chain data model.ArFS works around this by implementing a privacy and encryption pattern and defining an append-only transaction data model using tags within Arweave Transaction headersopen in new window.# Key Features# File StructureArFS organizes files and folders using a hierarchical structure. Files are stored as individual transactions on the Arweave blockchain, while folders are metadata that reference these file transactions.# MetadataEach file and folder has associated metadata, such as the name, type, size, and modification timestamp. ArFS leverages Arweave's tagging system to store this metadata in a standardized format, which allows for easy querying and organization.# File PermissionsArFS supports public and private file permissions. Public files can be accessed by anyone on the network, while private files are encrypted using the owner's private key, ensuring only they can decrypt and access the content.# File VersioningArFS supports versioning of files, allowing users to store multiple versions of a file and access previous versions at any time. This is achieved by linking new file transactions to previous versions through the use of metadata tags.# Data DeduplicationTo minimize storage redundancy and costs, ArFS employs data deduplication techniques. If a user tries to store a file that already exists on the network, the protocol will simply create a new reference to the existing file instead of storing a duplicate copy.# Search and DiscoveryArFS enables users to search and discover files based on their metadata, such as file names, types, and tags. This is made possible by indexing the metadata stored within the Arweave blockchain.# InteroperabilityArFS is designed to be interoperable with other decentralized applications and services built on the Arweave network. This allows for seamless integration and collaboration between different applications and users.# Getting StartedTo start using ArFS, you'll need to familiarize yourself with the Arweave ecosystem, acquire AR tokens to cover storage costs, and choose a compatible client or library to interact with the ArFS protocol.# ResourcesFor more information, documentation, and community support, refer to the following resources:Arweave Official Websiteopen in new windowArweave Developer Documentationopen in new windowArweave Community Forumsopen in new window Permaweb Data Model",
          "estimatedWords": 423,
          "lastModified": "2025-06-27T16:25:48.160Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:48.160Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/data-model.html",
          "title": "Data Model",
          "content": "Contributors: Jack Frain, bobinsteinLast Updated: Edit# Data ModelBecause of Arweave's permanent and immutable nature, traditional file structure operations such as renaming and moving files or folders cannot be accomplished by simply updating on-chain data. ArFS works around this by defining an append-only transaction data model based on the metadata tags found in the Arweave Transaction Headers.open in new windowThis model uses a bottom-up reference method, which avoids race conditions in file system updates. Each file contains metadata that refers to the parent folder, and each folder contains metadata that refers to its parent drive. A top-down data model would require the parent model (i.e. a folder) to store references to its children.These defined entities allow the state of the drive to be constructed by a client to look and feel like a file systemDrive Entities contain folders and filesFolder Entities contain other folders or filesFile Entities contain both the file data and metadataSnapshot entities contain a state rollups of all files and folder metadata within a drive# Entity relationshipsThe following diagram shows the high level relationships between drive, folder, and file entities, and their associated data. More detailed information about each Entity Type can be found here.Entity Relationship DiagramAs you can see, each file and folder contains metadata which points to both the parent folder and the parent drive. The drive entity contains metadata about itself, but not the child contents. So clients must build drive states from the lowest level and work their way up.# Metadata FormatMetadata stored in any Arweave transaction tag will be defined in the following manner:{ \"name\": \"Example-Tag\", \"value\": \"example-data\" } Metadata stored in the Transaction Data Payload will follow JSON formatting like below:{ \"exampleField\": \"exampleData\" } fields with a ? suffix are optional.{ \"name\": \"My Project\", \"description\": \"This is a sample project.\", \"version?\": \"1.0.0\", \"author?\": \"John Doe\" } Enumerated field values (those which must adhere to certain values) are defined in the format \"value 1 | value 2\".All UUIDs used for Entity-Ids are based on the Universally Unique Identifieropen in new window standard.There are no requirements to list ArFS tags in any specific order. ArFS Protocol: A Decentralized File System on Arweave Entity Types",
          "estimatedWords": 360,
          "lastModified": "2025-06-27T16:25:48.643Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:48.643Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/entity-types.html",
          "title": "Entity Types",
          "content": "Contributors: bobinsteinLast Updated: Edit# Entity Types# OverviewArweave transactions are composed of transaction headers and data payloads.ArFS entities, therefore, have their data split between being stored as tags on their transaction header and encoded as JSON and stored as the data of a transaction. In the case of private entities, JSON data and file data payloads are always encrypted according to the protocol processes defined below.Drive entities require a single metadata transaction, with standard Drive tags and encoded JSON with secondary metadata.Folder entities require a single metadata transaction, with standard Folder tags and an encoded JSON with secondary metadata.File entities require a metadata transaction, with standard File tags and an encoded Data JSON with secondary metadata relating to the file.File entities also require a second data transaction, which includes a limited set of File tags and the actual file data itself.Snapshot entities require a single transaction. which contains a Data JSON with all of the Drive‚Äôs rolled up ArFS metadata and standard Snapshot GQL tags that identify the Snapshot.# DriveA drive is the highest level logical grouping of folders and files. All folders and files must be part of a drive, and reference the Drive ID of that drive.When creating a Drive, a corresponding folder must be created as well. This will act as the root folder of the drive. This separation of drive and folder entity enables features such as folder view queries, renaming, and linking.ArFS: \"0.13\" Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Content-Type: \"<application/json | application/octet-stream>\" Drive-Id: \"<uuid>\" Drive-Privacy: \"<public | private>\" Drive-Auth-Mode?: \"password\" Entity-Type: \"drive\" Unix-Time: \"<seconds since unix epoch>\" Data JSON { \"name\": \"<user defined drive name>\", \"rootFolderId\": \"<uuid of the drive root folder>\" } Drive Entity Transaction Example# FolderA folder is a logical grouping of other folders and files. Folder entity metadata transactions without a parent folder id are considered the Drive Root Folder of their corresponding Drives. All other Folder entities must have a parent folder id. Since folders do not have underlying data, there is no Folder data transaction required.ArFS: \"0.13\" Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Content-Type: \"<application/json | application/octet-stream>\" Drive-Id: \"<drive uuid>\" Entity-Type: \"folder\" Folder-Id: \"<uuid>\" Parent-Folder-Id?: \"<parent folder uuid>\" Unix-Time: \"<seconds since unix epoch>\" Data JSON { \"name\": \"<user defined folder name>\" } Folder Entity Transaction Example# FileA File contains uploaded data, like a photo, document, or movie.In the Arweave File System, a single file is broken into 2 parts - its metadata and its data.In the Arweave File System, a single file is broken into 2 parts - its metadata and its data.A File entity metadata transaction does not include the actual File data. Instead, the File data must be uploaded as a separate transaction, called the File Data Transaction. The File JSON metadata transaction contains a reference to the File Data Transaction ID so that it can retrieve the actual data. This separation allows for file metadata to be updated without requiring the file itself to be reuploaded. It also ensures that private files can have their JSON Metadata Transaction encrypted as well, ensuring that no one without authorization can see either the file or its metadata.ArFS: \"0.13\" Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Content-Type: \"<application/json | application/octet-stream>\" Drive-Id: \"<drive uuid>\" Entity-Type: \"file\" File-Id: \"<uuid>\" Parent-Folder-Id: \"<parent folder uuid>\" Unix-Time: \"<seconds since unix epoch>\" Data JSON { \"name\": \"<user defined file name with extension eg. happyBirthday.jpg>\", \"size\": \"<computed file size - int>\", \"lastModifiedDate\": \"<timestamp for OS reported time of file's last modified date represented as milliseconds since unix epoch - int>\", \"dataTxId\": \"<transaction id of stored data>\", \"dataContentType\": \"<the mime type of the data associated with this file entity>\", \"pinnedDataOwner\": \"<the address of the original owner of the data where the file is pointing to>\" # Optional } Pin Files Since the version v0.13, ArFS suports Pins. Pins are files whose data may be any transaction uploaded to Arweave, that may or may not be owned by the wallet that created the pin.When a new File Pin is created, the only created transaction is the Metadata Transaction. The dataTxId field will point it to any transaction in Arweave, and the optional pinnedDataOwner field is gonna hold the address of the wallet that owns the original copy of the data transaction.File Data Transaction ExampleThe File Data Transaction contains limited information about the file, such as the information required to decrypt it, or the Content-Type (mime-type) needed to view in the browser.Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Content-Type: \"<file mime-type | application/octet-stream>\" { File Data - Encrypted if private } File Metadata Transaction ExampleThe the File Metadata Transaction contains the GQL Tags necessary to identify the file within a drive and folder.Its data contains the JSON metadata for the file. This includes the file name, size, last modified date, data transaction id, and data content type.ArFS: \"0.13\" Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Content-Type: \"<application/json | application/octet-stream>\" Drive-Id: \"<drive uuid>\" Entity-Type: \"file\" File-Id: \"<uuid>\" Parent-Folder-Id: \"<parent folder uuid>\" Unix-Time: \"<seconds since unix epoch>\" { File JSON Metadata - Encrypted if private } # SnapshotArFS applications generate the latest state of a drive by querying for all ArFS transactions made relating to a user's particular Drive-Id. This includes both paged queries for indexed ArFS data via GQL, as well as the ArFS JSON metadata entries for each ArFS transaction.For small drives (less than 1000 files), a few thousand requests for very small volumes of data can be achieved relatively quickly and reliably. For larger drives, however, this results in long sync times to pull every piece of ArFS metadata when the local database cache is empty. This can also potentially trigger rate-limiting related ArWeave Gateway delays.Once a drive state has been completely, and accurately generated, in can be rolled up into a single snapshot and uploaded as an Arweave transaction. ArFS clients can use GQL to find and retrieve this snapshot in order to rapidly reconstitute the total state of the drive, or a large portion of it. They can then query individual transactions performed after the snapshot.This optional method offers convenience and resource efficiency when building the drive state, at the cost of paying for uploading the snapshot data. Using this method means a client will only have to iterate through a few snapshots instead of every transaction performed on the drive.# Snapshot Entity TagsSnapshot entities require the following tags. These are queried by ArFS clients to find drive snapshots, organize them together with any other transactions not included within them, and build the latest state of the drive.ArFS: \"0.13\" Drive-Id: \"<drive uuid that this snapshot is associated with>\" Entity-Type: \"snapshot\" Snapshot-Id: \"<uuid of this snapshot entity>\" Content-Type: \"<application/json>\" Block-Start: \"<the minimum block height from which transactions were searched for in this snapshot, eg. 0>\" Block-End: \"<the maximum block height from which transactions were searched for in this snapshot, eg 1007568>\" Data-Start: \"<the first block in which transaction data was found in this snapshot, eg 854300\" Data-End: \"<the last block in which transaction was found in this snapshot, eg 1001671\" Unix-Time: \"<seconds since unix epoch>\" Snapshot Transaction GQL tags example# Snapshot Entity DataA JSON data object must also be uploaded with every ArFS Snapshot entity. THis data contains all ArFS Drive, Folder, and File metadata changes within the associated drive, as well as any previous Snapshots. The Snapshot Data contains an array txSnapshots. Each item includes both the GQL and ArFS metadata details of each transaction made for the associated drive, within the snapshot's start and end period.A tsSnapshot contains a gqlNode object which uses the same GQL tags interface returned by the Arweave Gateway. It includes all of the important block, owner, tags, and bundledIn information needed by ArFS clients. It also contains a dataJson object which stores the correlated Data JSON for that ArFS entity.For private drives, the dataJson object contains the JSON-string-escaped encrypted text of the associated file or folder. This encrypted text uses the file's existing Cipher and Cipher-IV. This ensures clients can decrypt this information quickly using the existing ArFS privacy protocols.{ \"txSnapshots\": [ { \"gqlNode\": { \"id\": \"bWCvIc3cOzwVgquD349HUVsn5Dd1_GIri8Dglok41Vg\", \"owner\": { \"address\": \"hlWRbyJ6WUoErm3b0wqVgd1l3LTgaQeLBhB36v2HxgY\" }, \"bundledIn\": { \"id\": \"39n5evzP1Ip9MhGytuFm7F3TDaozwHuVUbS55My-MBk\" }, \"block\": { \"height\": 1062005, \"timestamp\": 1669053791 }, \"tags\": [ { \"name\": \"Content-Type\", \"value\": \"application/json\" }, { \"name\": \"ArFS\", \"value\": \"0.11\" }, { \"name\": \"Entity-Type\", \"value\": \"drive\" }, { \"name\": \"Drive-Id\", \"value\": \"f27abc4b-ed6f-4108-a9f5-e545fc4ff55b\" }, { \"name\": \"Drive-Privacy\", \"value\": \"public\" }, { \"name\": \"App-Name\", \"value\": \"ArDrive-App\" }, { \"name\": \"App-Platform\", \"value\": \"Web\" }, { \"name\": \"App-Version\", \"value\": \"1.39.0\" }, { \"name\": \"Unix-Time\", \"value\": \"1669053323\" } ] }, \"dataJson\": \"{\\\"name\\\":\\\"november\\\",\\\"rootFolderId\\\":\\\"71dfc1cb-5368-4323-972a-e9dd0b1c63a0\\\"}\" } ] } Snapshot Transaction JSON data example# Schema DiagramsThe following diagrams show complete examples of Drive, Folder, and File entity Schemas.# Public DrivePublic Drive Schema# Private DrivePrivate Drive Schema Data Model Content Types",
          "estimatedWords": 1459,
          "lastModified": "2025-06-27T16:25:48.738Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:48.738Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/content-types.html",
          "title": "Content Types",
          "content": "Contributors: bobinsteinLast Updated: Edit# Content TypesAll transaction types in ArFS leverage a specific metadata tag for the Content-Type (also known as mime-type) of the data that is included in the transaction. ArFS clients must determine what the mime-type of the data is, in order for Arweave gateways and browswers to render this content appropriately.All public drive, folder, and file (metadata only) entity transactions all use a JSON standard, therefore they must have the following content type tag:Content-Type: '<application/json>' However, a file's data transaction must have its mime-type determined. This is stored in the file's corresponding metadata transaction JSON's dataContentType as well as the content type tag in the data transaction itself.Content-Type: \"<file's mime-type>\" All private drive, folder, and file entity transactions must have the following content type, since they are encrypted:Content-Type: '<application/octet-stream>' ArDrive-Coreopen in new window includes methods to determine a file's content type.# Other TagsArFS enabled clients should include the following tags on their transactions to identify their applicationApp-Name: \"<defined application name eg. ArDrive\" App-Version: \"<defined version of the app eg. 0.5.0\" Client?: \"<if the application has multiple clients, they should be specified here eg. Web\" Entity Types Privacy",
          "estimatedWords": 190,
          "lastModified": "2025-06-27T16:25:49.229Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:49.229Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/privacy.html",
          "title": "Privacy",
          "content": "Contributors: bobinsteinLast Updated: Edit# PrivacyThe Arweave blockweave is inherently public. But with apps that use ArFS, like ArDrive, your private data never leaves your computer without using military grade (and quantum resistantopen in new window) encryption. This privacy layer is applied at the Drive level, and users determine whether a Drive is public or private when they first create it. Private drives must follow the ArFS privacy model.Every file within a Private Drive is symmetrically encrypted using AES-256-GCMopen in new window. Every Private drive has a master \"Drive Key\" which uses a combination of the user's Arweave wallet signature, a user defined drive password, and a unique drive identifier (uuidv4open in new window). Each file has its own \"File Key\" derived from the \"Drive Key\". This allows for single files to be shared without exposing access to the other files within the Drive.Once a file is encrypted and stored on Arweave, it is locked forever and can only be decrypted using its file key.# Deriving KeysPrivate drives have a global drive key, D, and multiple file keys F, for encryption. This enables a drive to have as many uniquely encrypted files as needed. One key is used for all versions of a single file (since new file versions use the same File-Id)D is used for encrypting both Drive and Folder metadata, while F is used for encrypting File metadata and the actual stored data. Having these different keys, D and F, allows a user to share specific files without revealing the contents of their entire drive.D is derived using HKDF-SHA256 with an unsaltedopen in new window RSA-PSS signature of the drive's id and a user provided password.F is also derived using HKDF-SHA256 with the drive key and the file's id.Other wallets (like ArConnectopen in new window) integrate with this Key Derivation protocol just exposing an API to collect a signature from a given Arweave Wallet in order to get the SHA-256 signature needed for the HKDFopen in new window to derive the Drive Key.An example implementation, using Dart, is available hereopen in new window, with a Typescript implementation hereopen in new window.# Private DrivesDrives can store either public or private data. This is indicated by the Drive-Privacy tag in the Drive entity metadata.Drive-Privacy: \"<public | private>\" If a Drive entity is private, an additional tag Drive-Auth-Mode must also be used to indicate how the Drive Key is derived. ArDrive clients currently leverage a secure password along with the Arweave Wallet private key signature to derive the global Drive Key.Drive-Auth-Mode?: 'password' On every encrypted Drive Entity, a Cipher tag must be specified, along with the public parameters for decrypting the data. This is done by specifying the parameter with a Cipher-* tag. eg. Cipher-IV. If the parameter is byte data, it must be encoded as Base64 in the tag.ArDrive clients currently leverage AES256-GCM for all symmetric encryption, which requires a Cipher Initialization Vector consisting of 12 random bytes.Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Additionally, all encrypted transactions must have the Content-Type tag application/octet-stream as opposed to application/jsonPrivate Drive Entities and their corresponding Root Folder Entities will both use these keys and ciphers generated to symmetrically encrypt the JSON files that are included in the transaction. This ensures that only the Drive Owner (and whomever the keys have been shared with) can open the drive, discover the root folder, and continue to load the rest of the children in the drive.# Private FilesWhen a file is uploaded to a private drive, it by default also becomes private and leverages the same drive keys used for its parent drive. Each unique file in a drive will get its own set of file keys based off of that file's unique FileId. If a single file gets a new version, its File-Id will be reused, effectively leveraging the same File Key for all versions in that file's history.These file keys can be shared by the drive's owner as needed.Private File entities have both its metadata and data transactions encrypted using the same File Key, ensuring all facets of the data is truly private. As such, both the file's metadata and data transactions must both have a unique Cipher-IV and Cipher tag:Cipher?: \"AES256-GCM\" Cipher-IV?: \"<12 byte initialization vector as Base64>\" Just like drives, private files must have the Content-Type tag set as application/octet-stream in both its metadata and data transactions:Content-Type: \"application/octet-stream\" Content Types schema-diagrams.md",
          "estimatedWords": 731,
          "lastModified": "2025-06-27T16:25:49.311Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:49.311Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arfs/schema-diagrams.html",
          "title": "Cooking with the Permaweb",
          "content": "Contributors: bobinsteinLast Updated: Edit# Schema DiagramsThe following diagrams show complete examples of Drive, Folder, and File entity Schemas.# Public DrivePublic Drive Schema# Private DrivePrivate Drive SchemaArweave GQL Tag Byte Limit is restricted to 2048. There is no determined limit on Data JSON custom metadata, though more data results in a higher upload cost. Privacy",
          "estimatedWords": 54,
          "lastModified": "2025-06-27T16:25:49.808Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:49.808Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/vouch.html",
          "title": "Vouch",
          "content": "Contributors: Jack Frain, PBillingsbyLast Updated: Edit# Vouch# Overview# MotivationVouching provides a decentralized approach to Sybil resistance. A Sybil attack is when an attacker subverts the network by creating a large number of pseudonymous identities to gain a disproportionately large influence.# Vouch ProtocolArweave introduced the concept of the ANS-109 Vouch (Assertion of Identity). It is a standard that uses a specific transaction format along with some tags to allows anyone on the permaweb to \"vouch\" for the identity and humanity of any Arweave address.Adding a standard such as the ANS-109 to the permaweb will help minimize Sybil attacks and bad actors, making it a safer experience for permaweb users.# VouchDAOVouchDAO is a community led, decentralized verification layer built on top of the Vouch standard. Developers create vouch services and members of the VouchDAO community vote on which of these verification services are deemed trustworthy.# How It WorksDevelopers have the ability to create different Vouch services to attest to a user's Arweave wallet based on a given set of requirements. A current example of this is the Twitter service which is the first vouch service, which has vouched over 180 Arweave addresses so far.The VouchDAO smart contract state has an attribute vouched. This state gets updated whenever a user gets verified. The vouched object stores a list of vouched addresses in the following format:VOUCH_USER_ADDRESS:[ { service:\"SERVICE_ADDRESS_1\" transaction:\"TX_ID\" }, { service:\"SERVICE_ADDRESS_2\" transaction:\"TX_ID\" } ] Users that get verified will have the ANS-109 token sent to their wallet to indicate that wallet has been vouched for by that service.# ANS-109 Transaction FormatTag NameOptional?Tag ValueApp-NameFalseVouchVouch-ForFalseArweave address that is being vouched for in this transactionApp-VersionTrue0.1Verification-MethodTrueMethod of verification of identity for the person. Example - Twitter/In-Person/Gmail/FacebookUser-IdentifierTrueAn identifier for the user based on the Verification Method. Example - abhav@arweave.org# ResourcesVouchDAOopen in new windowVouchDAO Contractopen in new window Arweave File System (ArFS)",
          "estimatedWords": 303,
          "lastModified": "2025-06-27T16:25:49.880Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:49.880Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deployment/arkb.html",
          "title": "arkb",
          "content": "Contributors: Dan MacDonald, Luke Cassady-Dorion, PBillingsbyLast Updated: Edit# arkb# RequirementsAn Arweave wallet is required to deploy using arkb for covering the data transaction costs.# InstallationTo install arkb runNPMYARNnpm install -g arkb yarn add ar-gql # DeployingWhen uploading a directory of files or a Permaweb application, by default arkb deploys each file separately as an L1 transaction, with the option to bundle the transactions using Bundlr.# Static BuildPermaweb applications are statically generated, meaning that the code and content are generated ahead of time and stored on the network.Below is an example of a static site. To deploy this to the Permaweb, the build directory will be passed in as the argument for the deploy flag.|- build |- index.html |- styles.css |- index.js # Default DeploymentDeploying as an L1 transaction can take longer to confirm as it is directly uploaded to the Arweave network.arkb deploy [folder] --wallet [path to wallet] # Bundled DeploymentTo deploy using Bundlr you will need to fund a Bundlr node.Bundlr node2 allows free transactions under 100kb.You can add custom identifiable tags to the deployment using tag-name/tag-value syntax.arkb deploy [folder] --use-bundler [bundlr node] --wallet [path to wallet] --tag-name [tag name] --tag-value [tag value] # Other Commands# Fund Bundlrarkb fund-bundler [amount] --use-bundler [bundlr node] * Funding a Bundlr instance can take up to 30 minutes to process# Saving Keyfilearkb wallet-save [path to wallet] After saving your key you can now run commands without the --wallet-file option, like thisarkb deploy [path to directory] # Check Wallet Balancearkb balance Github Action",
          "estimatedWords": 249,
          "lastModified": "2025-06-27T16:25:50.394Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:50.394Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deployment/github-action.html",
          "title": "Github Action",
          "content": "Contributors: Megumiiiiii, Tom Wilson, Luke Cassady-Dorion, Tyler HallLast Updated: Edit# Github ActionWARNINGThis guide is for educational purposes only, and you should use to learn options of how you might want to deploy your application. In this guide, we are trusting a 3rd party resource github owned by microsoft to protect our secret information, in their documentation they encrypt secrets in their store using libsodium sealed box, you can find more information about their security practices here. https://docs.github.com/en/actions/security-guides/encrypted-secretsGithub Actions are CI/CD pipelines that allows developers to trigger automated tasks via events generated from the github workflow system. These tasks can be just about anything, in this guide we will show how you can use github actions to deploy your permaweb application to the permaweb using Irys and ArNS.TIPThis guide requires understanding of github actions, and you must have some ArNS Test Tokens, go to https://ar.io/arns/ for more details.WARNINGThis guide does not include testing or any other checks you may want to add to your production workflow.# Create deploy scriptA deploy script is a script that does the heavy lifting of deploying your application, we will use @irys/sdk and warp-contracts to publish our application and register the newly published application on ArNS.Install deploy dependenciesnpm install --save-dev @permaweb/arx npm install --save-dev warp-contracts npm install --save-dev arweave Create deploy.mjs fileimport Arx from \"@permaweb/arx\"; import { WarpFactory, defaultCacheOptions } from \"warp-contracts\"; import Arweave from \"arweave\"; const ANT = \"[YOUR ANT CONTRACT]\"; const DEPLOY_FOLDER = \"./dist\"; const TURBO_NODE = \"https://turbo.ardrive.io\"; const jwk = JSON.parse(Buffer.from(process.env.PERMAWEB_KEY, \"base64\").toString(\"utf-8\")); const arweave = Arweave.init({ host: \"arweave.net\", port: 443, protocol: \"https\" }); const arx = new Arx({ url: TURBO_NODE, token: \"arweave\", key: jwk }); const warp = WarpFactory.custom(arweave, defaultCacheOptions, \"mainnet\").useArweaveGateway().build(); const contract = warp.contract(ANT).connect(jwk); // upload folder const result = await arx.uploadFolder(DEPLOY_FOLDER, { indexFile: \"index.html\", }); // update ANT await contract.writeInteraction({ function: \"setRecord\", subDomain: \"@\", transactionId: result.id, }); console.log(\"Deployed Cookbook, please wait 20 - 30 minutes for ArNS to update!\"); # Add script to package.jsonCreate a new script property called deploy, call the build script, then call node deploy.mjs in the value of the scripts deploy property.package.json ... \"scripts\": { \"dev\": \"vuepress dev src\", \"build\": \"vuepress build src\", \"deploy\": \"yarn build && node deploy.mjs\" }, ... # Create github actionCreate a deploy.yml file in the .github/workflows folder, this file instructs github actions to deploy when a push event is triggered on the main branch.name: publish on: push: branches: - \"main\" jobs: publish: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - uses: actions/setup-node@v1 with: node-version: 18.x - run: yarn - run: yarn deploy env: KEY: ${{ secrets.PERMAWEB_KEY }} # SummaryIn the project repo, go to the settings and secrets, add a new secret to the repostiory, this secret will be called PERMAWEB_KEY for this project. The value of the secret should be the base64 encode string of the deployment wallet.base64 -i wallet.json | pbcopy In order for this deployment to work, you will need to fund this wallets Irys account, make sure there is some $AR in the wallet you will be using, not much, maybe .5 AR, then use the Irys cli to fund.arx fund 250000000000 -w wallet.json -t arweave WARNINGKeep this wallet low on funds and only use it for this project.üéâ You have setup a github action to completely automate your deploy to permaweb! arkb",
          "estimatedWords": 544,
          "lastModified": "2025-06-27T16:25:50.473Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:50.473Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deploying-manifests/deployingManifests.html",
          "title": "Creating and Deploying Manifests",
          "content": "Contributors: Jack SmithLast Updated: Edit# Creating and Deploying ManifestsThis guide lays out how to create and deploy a path manifest manually.The path manifests core concepts page has more information on what manifests are, and why they might be useful for your project.If you follow this guide to deploy a path manifest, it will need to follow the manifest structure laid out in the core conceptsopen in new window page. Deploying PSTs",
          "estimatedWords": 71,
          "lastModified": "2025-06-27T16:25:50.966Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:50.966Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deploying-manifests/arweave-app.html",
          "title": "Cooking with the Permaweb",
          "content": "Contributors: Jack SmithLast Updated: Edit# Arweave.appUploading a directory through Arweave.appopen in new window will automatically create a manifest for all of the files in the directory.Alternatively, you can upload your own manifest file manually, add the following tag, and submit the transaction. ardrive",
          "estimatedWords": 43,
          "lastModified": "2025-06-27T16:25:51.040Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:51.040Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deploying-manifests/ardrive.html",
          "title": "Cooking with the Permaweb",
          "content": "Contributors: Jack SmithLast Updated: Edit# ArDriveYou can create a manifest for a folder or group of folders with ardrive create-manifest using the ArDrive CLIopen in new window.Further Reading: ArDrive CLI Docsopen in new windowAlternatively, you can create a manifest using the ArDriveopen in new window web app by selecting New ‚Üí Create manifest while inside of a drive. arweave.app arseeding-js",
          "estimatedWords": 60,
          "lastModified": "2025-06-27T16:25:51.540Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:51.540Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deploying-manifests/arseeding-js.html",
          "title": "Cooking with the Permaweb",
          "content": "Contributors: weibogaoLast Updated: Edit# Arseeding JS SDKThe guide of how to easily use the Manifest feature in Arseeding.# Getting Started# Installing the SDKnpm i arseeding-js Create a demo.js, and copy the following code into it.import {uploadFolderAndPay} from \"arseeding-js/cjs/uploadFolder\"; const run = async () => { const path = 'Your Folder path' const priv = 'YOUR PRIVATE KEY' const arseedUrl = 'https://arseed.web3infra.dev' const tag = '<chaintype-symbol-id>' // everpay supported all token tag (chainType-symbol-id) const indexFile = '' const res = await uploadFolderAndPay(path,priv,arseedUrl,tag, indexFile) console.log(res) } // review manifest Data curl --location --request GET 'https://arseed.web3infra.dev/{res.maniId}' Configuration Notes:Populate your ECC key with YOUR PRIVATE KEY. Make sure that the wallet corresponding to the private key has assets in everPay.arseedUrl is the URL of the Arseeding backend service, here we use the public Arseeding service provided by permadao: https://arseed.web3infra.dev.payUrl is the URL of the everPay service that needs to be configured: https://api.everpay.ioopen in new windowpath is the path to the folder you want to upload, for example, to deploy a static website, the front-end project will generate a build or dist folder after the project is compiled, just choose the path to that folder.tag is the payment token tag you need to select, if your MetaMask address held in everPay is usdc, you can get the usdc tag via getTokenTagByEver('usdc')open in new window,If you want to pay with another token, just fill in the token name to get the specified tag.indexFile is optional,if you don't pass it, index.html(if exist) or null will be default value, if the folder is a front-end project build folder you don't need pass indexFile.After preparing the configuration, call uploadFolderAndPay(path,priv,url,payCurrency) to upload all the files under your folder to web3infra's Arseeding node by means of manifest.node demo.js return:{ fee: '0.004218', maniId: 'EHeDa8b428L38b972qyHI87YELuZKue1jDI_JWC-aGE', everHash:[ '0x46744320be6529c48bf18c348fa181facef3d9d6d920a24687dc9964ba3ead0a' ] } # Download data-Access pageThe maniId can be found in the returned result, the maniId above is EHeDa8b428L38b972qyHI87YELuZKue1jDI_JWC-aGEIn this tutorial, we are uploading a Docusaurus front-end project, and running yarn build under that project will generate a build folder, which is the one we uploaded. Now, we can access the site via maniId!In your browser, enter:https://arseed.web3infra.dev/EHeDa8b428L38b972qyHI87YELuZKue1jDI_JWC-aGE You can now access this website, and it will be permanently available!References and Further Reading:Arseeding Documentationopen in new windowFollow the Arseeding Upload Manifest tutorial hereopen in new window„ÄÇ ardrive Turbo",
          "estimatedWords": 381,
          "lastModified": "2025-06-27T16:25:51.612Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:51.612Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/deploying-psts.html",
          "title": "Creating and Deploying a PST",
          "content": "Contributors: Jack Smith (Longview Labs)Last Updated: Edit# Creating and Deploying a PST# PrerequisitesBefore you begin creating your PST, you will need NodeJS/NPM installed.# Getting StartedSmartWeave contracts can be broken down into two parts:The Contract (the actual logic behind the token)Initial State (some settings or configuration we want our token to have)In this guide we will create both.Setting Up a Local EnvironmentRun npm install arweave arlocal warp-contracts.This will provide functions to create and deploy a PST.# Configuring The ContractThe PST requires some initial state setup before deployment, e.g. the token name, and token quantity.Create a configuration file that looks something like this:// initial-state.json { \"ticker\": \"TEST_PST\", \"name\": \"Test PST\", \"owner\": \"G1mQ4_jjcca46JqR1kEt0yKvhaw6EUrXLiEwebMvSwo\", \"balances\": { \"G1mQ4_jjcca46JqR1kEt0yKvhaw6EUrXLiEwebMvSwo\": 1000, \"Jo9BZOaIVBDIhyKDiSnJ1bIU4usT1ZZJ5Kl6M-rBFdI\": 1000, } } Which sets some initial options for the PST. Save it as initial-state.json.ticker - symbol of the token (e.g. BTC, ETH)name - name of the tokenowner - address of the contract ownerbalances - addresses to distribute the initial tokens to# Writing The ContractThe PST contract should have a single function, handle, which takes two arguments:state, which is the current state of the contract, and action, which is the action you want to perform (e.g. transferring tokens).When making a call to the PST contract, it should return one of two things:state - if the call to the contract changes the state (e.g. making a transfer).result - if the call does not change the state (e.g. viewing a balance).Otherwise it should throw error if the call is invalid or fails.First, let's define the main handle function.//contract.js export function handle(state, action) { let balances = state.balances; let input = action.input; let caller = action.caller; } This sets up some variables for common interactions the smart contract uses.Now let's add the first type of input which will change the state. This allows the owner of the contract to mint new PSTs to their wallet address. if (input.function == 'mint') { let qty = input.qty; if (qty <= 0) { throw new ContractError('Invalid token mint'); } if (!Number.isInteger(qty)) { throw new ContractError('Invalid value for \"qty\". Must be an integer'); } if(caller != state.owner) { throw new ContractError('Only the owner of the contract can mint new tokens.'); } balances[caller] ? (balances[caller] += qty) : (balances[caller] = qty); return { state }; } The next function will handle transfers of PSTs between wallets.if (input.function == 'transfer') { let target = input.target; let qty = input.qty; if (!Number.isInteger(qty)) { throw new ContractError(`Invalid value for \"qty\". Must be an integer`); } if (!target) { throw new ContractError(`No target specified`); } if (qty <= 0 || caller == target) { throw new ContractError('Invalid token transfer'); } if (balances[caller] < qty) { throw new ContractError(`Caller balance not high enough to send ${qty} token(s)!`); } // Lower the token balance of the caller balances[caller] -= qty; if (target in balances) { // Wallet already exists in state, add new tokens balances[target] += qty; } else { // Wallet is new, set starting balance balances[target] = qty; } return { state }; } Let's also add a way to view the PST balance of a target wallet.if (input.function == 'balance') { let target = input.target; let ticker = state.ticker; if (typeof target !== 'string') { throw new ContractError(`Must specificy target to get balance for`); } if (typeof balances[target] !== 'number') { throw new ContractError(`Cannnot get balance, target does not exist`); } return { result: { target, ticker, balance: balances[target] } }; } And finally, let's throw an error if the input given is not the mint, transfer, or balance function.throw new ContractError(`No function supplied or function not recognised: \"${input.function}\"`); # Deploying The ContractTo deploy a contract, we need to write a NodeJS script which will work with Warp to deploy our contract.Create a file called deploy-contract.js, and begin by importing WarpFactory.import { WarpFactory } from 'warp-contracts/mjs' Next, initialize an instance of Warp.You can replace forMainnet() with forLocal(), or forTestnet(), depending on where you want to deploy your contract.const warp = WarpFactory.forMainnet(); Now we have Warp setup, you'll need a wallet to deploy the contract from. You can either use your own local keyfile:const walletAddress = \"path/to/wallet.json\" or, generate a new wallet through Warp using the following code:const jwk = await warp.arweave.wallets.generate(); const walletAddress = await warp.arweave.wallets.jwkToAddress(jwk); Transactions under 100KB are free, so you don't even have to fund the wallet!Before deploying the contract, we need to read in the initial state file and the contract file.const contract = fs.readFileSync(path.join(__dirname, 'contract.js'), 'utf8'); const state = JSON.parse( fs.readFileSync(path.join(__dirname, 'initial-state.json'), 'utf8') ); If you generated a new wallet to deploy from, you'll need to override the owner in the initial state. You can do this with the following code:const initialState = { ...stateFromFile, ...{ owner: walletAddress, }, }; If you're using wallet, you can instead edit the initial-state.json file directly to use your wallet address.The following code handles the deployment of the contract:const contractTxId = await warp.createContract.deploy({ wallet, initState: JSON.stringify(initialState), src: contractSrc, }); console.log('Deployment completed: ', { ...result, sonar: `https://sonar.warp.cc/#/app/contract/${result.contractTxId}` }); Run the script with node deploy-contract.js which will deoply your contract and log the contract transaction ID in the terminal for you to use.Source and Further Reading: Warp Docsopen in new window Deploying PathManifests",
          "estimatedWords": 856,
          "lastModified": "2025-06-27T16:25:52.219Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:52.219Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/intro.html",
          "title": "Execution Machine (EXM)",
          "content": "Contributors: RopatsLast Updated: Edit# Execution Machine (EXM)Execution Machine (EXM) is a developer platform that provides the ability to create and leverage blockchain-based (permanent) serverless functions without the need for knowledge of or access to blockchain technologies like wallets and tokens.This further enables the creation of composable, immutable and trustless applications in a frictionless manner.# Serverless Functions on ArweaveServerless functions are stored on Arweave through the intermediary EXM that also stores a copy as cache to rapidly serve applications at any time. The functions are stateful (store data) and hence, a single function id points to some data as well as the logic for interacting and updating this data.EXM handles the storage and execution, eliminating the need for maintaining a dedicated server, reducing upkeep costs and adding a layer of modularity.The modularity also brings in composability to select and assemble functions in various combinations to create custom applications suited to our requirements. These functions, and interactions with them, are permanently stored on chain, they cannot be tampered with and are available for anyone to view, making them immutable and trustless.Additionally, EXM covers the cost for uploading the data to Arweave and making the process crypto agnostic for devs.# How does it work in the background?A user sends a transaction request to a dedicated EXM server. With the help of Verifiable Computing, Execution Machine is able to process user requests in a quick and performant manner, eliminating the need for blockchain technology like tokens and wallets, while still maintaining a decentralised result. EXM then updates its cache layer with the updated state while also uploading the data to Arweave. The cache layer is used as an aid to rapidly serve applications at any time.Additionally, EXM is able to maintain a trust minimised environment as users can verify the transactions and current state of the contract/ functions using Lazy Evaluation.Verifiable Computing ExplainedVerifiable computing is a form of computing that takes advantage of the benefits of centralised system while still guaranteeing a decentralised result.Every serverless function either has the ability to read or update the state of some information. Using verifiable computing, this state is cached in a centralised server which allows for greater performance as consensus is not needed at the time of processing, but the information is always available for verification by the users. This allows users to ‚Äúlazily evaluate‚Äù even when it is stored on the cache layer before eventually being moved on chain.For verifiable computing to work seamlessly, some core parts must be implemented.Executor: A software that processes user transaction requests and caches them.Processor: A centralised pipeline (system) responsible for receiving transactions by a single or multiple users. After receiving the different bulks of transactions sent, processor must re-evaluate the smart contract with the new data. As transactions are received, the latest state of the smart contract must be upgraded and saved with accessibility to the user. The processor is responsible for ordering the transactions, usually by timestamp.Conveyor: A centralised system that establishes a bridge between a data-based blockchain. All the transactions received by the processor must be sent to the conveyor, the conveyor will guarantee the success of storing these operations in a data-based blockchain like Arweave.Lazy Evaluation ExplainedLazy evaluation, as the name suggests, is a method for lazily evaluating smart contracts and their current state on the blockchain. The smart contract itself and any interactions (write operations) with them are stored on chain and can be accessed by any user.It aims to shift the burden of processing from the nodes to the users. The user can opt to evaluate and interpret the smart contract code and interactions with it locally to verify the current state of the contract.This eliminates the need for nodes to store the full copy of the current state of a chain and arrive at a consensus on it. Thus, reducing the cost and improving performance, respectively.As everyone has access to the same data, everyone will interpret the it in the same way ensuring everyone has access to the same current state of information.# Advantages of using Serverless FunctionsServerless functions add a layer of modularity and can be composed as per various application requirements.Bug fixes and new feature integrations are easier to implement by targeting.Execution Machine has a cached layer for rapidly serving applications.Execution Machine leverages a centralised system while guaranteeing a decentralised result.Execution Machine seeks to be crypto agnostic. Api Token",
          "estimatedWords": 727,
          "lastModified": "2025-06-27T16:25:52.698Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:52.698Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/api.html",
          "title": "Execution Machine API Token",
          "content": "Contributors: RopatsLast Updated: Edit# Execution Machine API TokenEXM seeks to be crypto agnostic and requires only a single API token (also known as key) to interact with. This API key is required for most actions in EXM like deployments and write operations.# Creating an API TokenFor creating an API token, the following steps must be performed:Go to the main pageopen in new window.Choose the preferred method to Sign-Up/ Sign-In.After being redirected to the dashboard, click on \"New Token\".Copy the token that has been generated and use it with the SDK or CLI.# Handling API Token safelyThe token is an identifier to our account and lets us access functions associated with it. Hence, it is vital to ensure this token is kept secret to prevent any spams and attacks to our functions. The best way to do so is using environment variables.There are two ways to store environment variables:Through the command line:In the directory of the project, pass the following command:export EXM_PK=<your_api_token> Through the dotenv sdk:Run the following in the command line:npm install dotenv #OR yarn add dotenv Import the library in file using the variables:import dotenv from \"dotenv\"; dotenv.config(); Then this key can be refered inside files as process.env.EXM_PK without exposing it or pushing it to version control systems like GitHub. Introduction",
          "estimatedWords": 212,
          "lastModified": "2025-06-27T16:25:52.793Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:52.793Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/js-sdk/sdk-intro.html",
          "title": "Execution Machine SDK",
          "content": "Contributors: RopatsLast Updated: Edit# Execution Machine SDKThe JavaScript SDK enables the usage of Execution Machine (EXM) in JavaScript and TypeScript applications. To use the SDK the following setup steps are needed.# InstallTo install EXM in your project you can use npm or yarn.npmyarnnpm install @execution-machine/sdk yarn add @execution-machine/sdk # ImportWhen using EXM with your project the package must be imported as follows.JavaScriptimport { Exm } from '@execution-machine/sdk'; # Creating an instanceTo interact with EXM after installation and importing, an instance must be created.JavaScriptconst exmInstance = new Exm({ token: 'MY_EXM_TOKEN' }); # SummaryThe following guides will show how to deploy serverless functions using the EXM JS SDK, and how to interact with them. Deploy with SDK",
          "estimatedWords": 115,
          "lastModified": "2025-06-27T16:25:53.327Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:53.328Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/js-sdk/sdk-deploy.html",
          "title": "Deploying Serverless Functions with Execution Machine SDK",
          "content": "Contributors: RopatsLast Updated: Edit# Deploying Serverless Functions with Execution Machine SDKFor deploying serverless functions with the SDK in JavaScript, we create a script here that tells our computer how to deploy our function to the network.Function Logic ExampleAfter installing the package we need a file defining the logic of the function within the project.function.jsexport async function handle(state, action) { state.counter++; return { state }; } The syntax for defining functions is based off of the standard implemented by SmartWeave for smart contracts in JavaScript. Every function has a state which is a JSON object of values stored in it and actions to interact with these values.The function above adds names to a users array which is done using the following line:state.users.push(action.input.name); When deploying our function we initialise an empty array named users that later helps our function to identify this state variable (variable stored in state of the function) during read and write calls. Upon initialisation the state looks like this:{ users: [] } Additionally, while writing to the function, we use a key named name to help the function identify what value we are feeding into the write operation. Both these definitions gain further significance when dealing with multiple values.Once the function logic is defined and API Token is setup properly as shown here, create the deploy file as follows:deploy.jsimport { Exm, ContractType } from '@execution-machine/sdk'; import { readFileSync, writeFileSync } from 'fs'; // init new EXM instance const exm = new Exm({ token: process.env.EXM_API_TOKEN }); // fetch function source const functionSource = readFileSync('function.js'); // .deploy(source, initState, contractType) const data = await exm.functions.deploy(functionSource, { users: [] }, ContractType.JS); // write the function id to a local file writeFileSync('./functionId.js', `export const functionId = \"${data.id}\"`) While deploying, we need to pass in the function logic, function's initial state and programming language of function definition as arguments. To deploy, run the following command in the command line inside the appropriate directory of the project:node deploy.js Upon deploying we receive some data from which we store the functionId in a local file. The functionId as the name states is a unique identifier that helps in further interactions with the serverless function such as read and write operations.The following sections walk through the process of reading and writing with EXM functions. Execution Machine SDK Write with SDK",
          "estimatedWords": 383,
          "lastModified": "2025-06-27T16:25:53.397Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:53.397Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/js-sdk/sdk-write.html",
          "title": "Write to Serverless Functions with Execution Machine SDK",
          "content": "Contributors: RopatsLast Updated: Edit# Write to Serverless Functions with Execution Machine SDKOnce a function is deployed, it's state can be updated with the help of write interactions. Due to the unique architecture of EXM's serverless functions, the logic for updating state is stored along with the state itself and both of these can be referred to using the same functionId. Functions can have a single operation or multiple operations for updating state as per the application requirements and the arguments for the write call vary accordingly.Function Logic and Corresponding Write ExampleFunction example with single operations for updating state:The following function adds names to a users array:export async function handle(state, action) { state.users.push(action.input.name); return { state }; } The state is updated by the following line:state.users.push(action.input.name); In this case, the write call only needs a key-value pair of name as an input:const inputs = [{ name: 'Open Sourcerer' }]; Function example with multiple operations for updating state:The following function creates posts but also has the ability to update or delete these posts:export async function handle(state, action) { const { input } = action if (input.type === 'createPost' || input.type === 'updatePost') { state.posts[input.post.id] = input.post } if (input.type === 'deletePost') { delete state.posts[input.postId] } return { state } } The posts are objects with the following format:post: { id: string title: string content: string author: string } We give each post a unique id so that we can refer to it for updating or deleting. If no corresponding id exists, then a new post is created instead.However, as can be seen in the function above, this function logic has the abilitiy to perform multiple operations and hence the type for each has been given a name. This name must be passed in as an input along with the post or id for performing the appropriate write call. To update a post, the inputs for the write call would look as follows:const inputs = [{ type: 'updatePost', post: { id, title: \"My Post\", content: \"My updated post\", author: \"Open Sourcerer\" } }]; The write transaction takes in two arguments. The functionId of the function to interact with and any inputs the function needs to process the write request and update state.write.jsimport { Exm } from '@execution-machine/sdk'; import { functionId } from './functionId.js'; // init new EXM instance const exm = new Exm({ token: process.env.EXM_API_TOKEN }); // inputs is an array of objects const inputs = [{ name: 'Open Sourcerer' }]; // read from cached layer const writeResult = await exm.functions.write(functionId, inputs); console.log(writeResult); A successful write request returns an object with the status as SUCCESS.{ status: 'SUCCESS', data: { pseudoId: 'txnId', execution: { state: [Object], result: null, validity: [Object], exmContext: [Object], updated: false } } } Deploy with SDK Read with SDK",
          "estimatedWords": 459,
          "lastModified": "2025-06-27T16:25:53.867Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:53.867Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/exm/js-sdk/sdk-read.html",
          "title": "Read from Serverless Functions with Execution Machine SDK",
          "content": "Contributors: RopatsLast Updated: Edit# Read from Serverless Functions with Execution Machine SDKThere are two ways of reading state from an EXM serverless functions. As explained in the introduction, EXM stores a copy of the function on a cache layer for rapidly serving applications but also uploads the function on Arweave to maintain decentralisation and its associated benefits. As a result of this, the function state can be read either from EXM's cache layer or directly from Arweave.Reading from EXM's cache layer:The read call reads the latest state as stored on EXM's cached layer. This layer is specifically designed for rapily serving applications. It takes an optimistic approach and updates the function state immediately upoon receiving a transaction request.read.jsimport { Exm } from '@execution-machine/sdk'; import { functionId } from './functionId.js'; // init new EXM instance const exm = new Exm({ token: process.env.EXM_API_TOKEN }); // read from cached layer const readResult = await exm.functions.read(functionId); console.log(readResult); Reading directly from Arweave (Evaluate):The evaluate call returns the latest state as successfully processed on Arweave. This latest state is calculated by lazy evaluation, which evaluates the initial state and the interactions with the function in order of ocurrence to arrive at the latest state.evaluate.jsimport { Exm } from '@execution-machine/sdk'; import { functionId } from './functionId.js'; // init new EXM instance const exm = new Exm({ token: process.env.EXM_API_TOKEN }); // evaluate from arweave const evalResult = await exm.functions.evaluate(functionId); console.log(evalResult); TIPReading from Arweave is recommended for verification purposes only. The function state returned from the evaluate call can be checked against the information returned by the cache layer to ensure its authenticity. There may be a slight lag in posting the transaction request and it updating on the network. Write with SDK",
          "estimatedWords": 284,
          "lastModified": "2025-06-27T16:25:53.961Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:53.961Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/querying-arweave/queryingArweave.html",
          "title": "Querying Arweave with GraphQL",
          "content": "Contributors: Dan MacDonald, wujunze, Jeffrey Ling, Tom WilsonLast Updated: Edit# Querying Arweave with GraphQLArweave provides a simple way of querying for transactions and filtering them by tags. Arweave GraphQL-compatible indexing services provide endpoints users can post GraphQL queries to, and also provide a playground for trying queries.GraphQLopen in new window is a flexible query language that services can use to build a customized data schema for clients to query. GraphQL also allows clients to specify which elements of the available data structure they would like to see in the results.# Public Indexing Servicesarweave.net graphqlopen in new window the original graphql endpoint, managed by ar.ioopen in new windowgoldsky search serviceopen in new window a public service specifically optimized for search using a superset of the graphql syntax, managed by goldskyopen in new windowar.io decentralized indexingopen in new window A decentralized network for indexing services. Currently in testing with L1 transactions available.knn3 arseeding indexingopen in new window, one for arseeding trading can real-time query service.# Executing a GraphQL QueryTo query arweave we‚Äôll need to access it through an indexing service that supports GraphQL. Use one of the GraphQL playgrounds listed above to get started!Copy and paste in the following queryquery { transactions(tags: [{ name: \"App-Name\", values: [\"PublicSquare\"] }]) { edges { node { id tags { name value } } } } } If you‚Äôre not familiar with GraphQL it can seem a little overwhelming at first but once you know the structure, it‚Äôs fairly easy to read and understand.query { <schema type> ( <filter criteria> ) { <data structure of the results> } } In the example query we pasted our <schema type> is transactions but we could also query for blocks. A full description of Arweave's GraphQL schema is written up in the Arweave GraphQL Guideopen in new window. The guide refers to the filter criteria as ‚ÄúQuery Structures‚Äù and the complete data structure definition of transactions and blocks as ‚ÄúData Structures‚Äù.When it comes to the <data structure of the results>, the thing to note is that you can specify a subset of the complete data structure you‚Äôre interested in. For example, the complete data structure for a transactions schema is listed hereopen in new window.In our case we‚Äôre interested in the id and complete list of tags for any transaction matching our filter criteria.Hit the big ‚ÄúPlay‚Äù button in the middle of the playground to run the query.You‚Äôll notice we get back a list of transactions in the results data structure we specified in our original query.If you‚Äôre new to blockchains this is unexpected, we haven‚Äôt built anything, why do these results exist? It turns out, the ‚ÄúPublicSquare‚Äù: ‚ÄúApp-Name‚Äù tag we‚Äôve filtered for has been in use for a while.Arweave protocol's founder, Sam Williams, proposed the transaction format a few years ago in a github code snippetopen in new window. Since then builders in the ecosystem have been building on and around it, experimenting, posting transactions with those tags.Back to querying Arweave. You‚Äôll notice in the GraphQL results that there are no readable post messages, just tags and information about posts.This is because the GraphQL indexing service is concerned with indexing and retrieving header data for transactions and blocks but not their associated data.To get the data of a transaction we need to look it up using another HTTP endpoint.https://arweave.net/<transaction id> Copy and paste one of the id‚Äôs in your query results and modify the above link, appending the id. It should look something like this‚Ä¶https://arweave.net/eaUAvulzZPrdh6_cHwUYV473OhvCumqT3K7eWI8tArkThe result of navigating to that URL in the browser (HTTP GET) would be retrieving the content of the post (stored in the transactions data). In this example it‚Äôs‚Ä¶Woah that's pretty cool üòé (For a complete listing arweave HTTP endpoints visit the HTTP APIopen in new window documentation.)# Posting a Query From JavasScriptPosting a GraphQL query from javascript isn't much different than posting it in the playground.First install the arweave-js package for easy access to a GraphQL endpoint.npm install --save arweave Then enter a slightly more advanced version of the example query from above and await the results of posting it.import Arweave from 'arweave'; // initialize an arweave instance const arweave = Arweave.init({}); // create a query that selects tx data the first 100 tx with specific tags const queryObject = { query: `{ transactions( first:100, tags: [ { name: \"App-Name\", values: [\"PublicSquare\"] }, { name: \"Content-Type\", values: [\"text/plain\"] } ] ) { edges { node { id tags { name value } } } } }` }; const results = await arweave.api.post('/graphql', queryObject); # Multiple QueriesIt is possible to post multiple queries in a single round-trip to the GraphQL endpoint. This example queries the name transaction (each as a separate query) for two wallet addresses using the now obsolete (replaced by ar-profile) but still permanent arweave-id protocol.query { account1: transactions(first: 1, owners:[\"89tR0-C1m3_sCWCoVCChg4gFYKdiH5_ZDyZpdJ2DDRw\"], tags: [ { name: \"App-Name\", values: [\"arweave-id\"] }, { name: \"Type\", values: [\"name\"] } ] ) { edges { node { id owner { address } } } } account2: transactions(first: 1, owners:[\"kLx41ALBpTVpCAgymxPaooBgMyk9hsdijSF2T-lZ_Bg\"], tags: [ { name: \"App-Name\", values: [\"arweave-id\"] }, { name: \"Type\", values: [\"name\"] } ] ) { edges { node { id owner { address } } } } } # ResourcesArweave GQL ReferenceArDB packagear-gql packageSearch Indexing Service",
          "estimatedWords": 870,
          "lastModified": "2025-06-27T16:25:54.457Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:54.457Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/querying-arweave/ardb.html",
          "title": "ArDB",
          "content": "Contributors: Dan MacDonaldLast Updated: Edit# ArDBA library built on top of GraphQL that makes it possible to query transaction and block data from arweave without having to memorize GraphQL parameter names. Just build queries using autocomplete in your favorite code editor.# Installationyarn add ardb # Exampleimport Arweave from 'arweave'; import ArDB from 'ardb'; // initialize an arweave instance const arweave = Arweave.init({}); // arweave is Arweave Client instance const ardb = new ArDB(arweave); // Get a single transaction by its id const tx = await ardb.search('transaction') .id('A235HBk5p4nEWfjBEGsAo56kYsmq7mCCyc5UZq5sgjY') .findOne(); // Get an array of transactions and include only the first result const txs = await ardb.search('transactions') .appName('SmartWeaveAction') .findOne(); // This is the same as doing: const txs = await ardb.search('transactions') .tag('App-Name', 'SmartWeaveAction') .limit(1) .find(); // Search for multiple transactions from a specific owner/wallet address const txs = await ardb.search('transactions') .from('BPr7vrFduuQqqVMu_tftxsScTKUq9ke0rx4q5C9ieQU') .find(); // Continue paging though the results with... const newTxs = await ardb.next(); // Or you could get all results at once by doing: const txs = await ardb.search('blocks') .id('BkJ_h-GGIwfek-cJd-RaJrOXezAc0PmklItzzCLIF_aSk36FEjpOBuBDS27D2K_T') .findAll(); # ResourcesArDB NPM packageopen in new window ar-gql",
          "estimatedWords": 178,
          "lastModified": "2025-06-27T16:25:55.069Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:55.069Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/querying-arweave/ar-gql.html",
          "title": "ar-gql",
          "content": "Contributors: Dan MacDonald, Ros Mc MahonLast Updated: Edit# ar-gqlThis package is a minimal layer on top of GraphQL, it supports parameterized queries with query variables. It also implements management of paged results.# InstallationTo install `ar-gql runNPMYARNnpm i ar-gql yarn add ar-gql # Exampleimport { arGql } from \"ar-gql\" const argql = arGql() (async () => { let results = await argql.run(`query( $count: Int ){ transactions( first: $count, tags: [ { name: \"App-Name\", values: [\"PublicSquare\"] }, { name: \"Content-Type\", values: [\"text/plain\"] }, ] ) { edges { node { id owner { address } data { size } block { height timestamp } tags { name, value } } } } }`, {count: 1}); console.log(results); })(); # Resourcesar-gql github pageopen in new window ArDB Search Indexing Service",
          "estimatedWords": 126,
          "lastModified": "2025-06-27T16:25:55.131Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:55.131Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/querying-arweave/search-indexing-service.html",
          "title": "Search Indexing Service",
          "content": "Contributors: jling, wujunze, Jeffrey LingLast Updated: Edit# Search Indexing Servicetl;drBackwards compatible syntax with Arweave GraphQLFaster response times for complex queries (ie multi-tag search)More query optionsGoldskyopen in new window's free search service uses an optimized backend that allows for faster searches for complex queries across arweave blocks and transactions, and also introduces additional querying syntax for fuzzy and wildcard search use-cases.The Search GraphQL syntax is a superset of the Arweave GraphQL syntax. It's fully backwards compatible and will return the same results for the same queries, but has some additional modifiers that can be useful.Flexible tag filters Search for just a tag name or valueAdvanced tag filters Fuzzy searchWildcard searchFilter for L1 transactions onlyResult set total countsFor any custom needs or feature ideas, feel free to contact the Goldsky team through email or on discord!# Search Gateway EndpointsCurrently, the only service with this syntax is hosted Goldsky. If anybody is interested in hosting their own gateway with the same syntax, feel free to contact the Goldskyopen in new window for help.Goldsky Search Serviceopen in new window# Features# Flexible Tag FiltersThe Search Gateway Syntax is less strict, and allows for searching just for the Tag name or value# ExamplesSearch for transactions with the tag value 'cat'query just_values { transactions( first: 10, tags: [ { values: [\"cat\"] } ] ) { edges { node { id tags { name value } } } } } Search for transactions that have an In-Response-To-IDquery just_name { transactions( first: 10, tags: [ { name: \"In-Response-To-ID\" } ] ) { edges { node { id tags { name value } } } } } # Advanced tag filtersThe Search Gateway Syntax offers an additional parameter to the tag filter, match.Match valueDescriptionEXACT(default) exact matches only.WILDCARDEnables * to match any amount of characters, ie. text/*FUZZY_ANDFuzzy match containing all search termsFUZZY_ORFuzzy match containing at least one search termOpen up the playground and try some of the following queries!Searching all transactions with an image content type using a wildcard{ transactions( tags: [ { name: \"Content-Type\", values: \"image/*\", match: WILDCARD} ] first: 10 ) { edges { cursor node { id tags { name value } block { height } bundledIn {id} } } } } # Fuzzy SearchFuzzy search is very powerful, and can search for 'similar' text with many variations.Searching all transactions with 'cat' OR 'dog' (or CAT or doG or cAts or CAAts etcs). So the tag could contain at least of cat-like or dog-like term.{ transactions( tags: [ { name: \"Content-Type\", values: [\"cat\", \"dog\"], match: \"FUZZY_OR\"} ] first: 10 ) { edges { cursor node { id tags { name value } block { height } bundledIn {id} } } } } Search for transactions that have cat-like AND dog-like tag values{ transactions( tags: [ { name: \"Content-Type\", values: [\"cat\", \"dog\"], match: \"FUZZY_AND\"} ] first: 10 ) { edges { cursor node { id tags { name value } block { height } bundledIn {id} } } } } # Exclude Bundled (L2) TransactionsSimply set bundledIn: NULLquery just_l1 { transactions( first: 10, bundledIn: null ) { edges { node { id signature owner { address } block { height } } } } } # Getting total counts given a queryIf you'd like to understand how many transactions fit a certain set of filters, just use the count field. This will trigger an additional optimized count operation. This will likely double the time it would take to return the query, so use only when needed.query count_mirror { { transactions(tags:{values:[\"MirrorXYZ\"]}) { count } } } ar-gql",
          "estimatedWords": 587,
          "lastModified": "2025-06-27T16:25:55.599Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:55.599Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/testing/arlocal.html",
          "title": "arlocal",
          "content": "Contributors: PBillingsbyLast Updated: Edit# arlocalarlocal is a tool for quickly setting up and running a local Arweave testing environment. It allows you to test transactions on a Arweave gateway-like server. It allows developers to test their applications in a simulated environment before deploying them to the Arweave networkNo $AR tokens are required to use and transactions are instant.# CLIYou must have node and npm installed on your machine to use the arlocal CLITo start the local gateway, run npx arlocalTIPYou can specify what port to run the slim gateway on by passing your port as an argument npx arlocal 8080To hide the logs, add the flag --hidelogs when you run your gateway npx arlocal --hidelogs# NodeInstall the package as a dev dependency by running yarn add arlocal -D or npm install arlocal --save-devimport ArLocal from 'arlocal'; (async () => { const arLocal = new ArLocal(); // create local testing environment await arLocal.start(); // your tests here // shut down testing environment await arLocal.stop(); })(); An ArLocal instance can be created with optionsOptionDescriptionportPort to useshowLogsShow logsdbPathDirectory for temporary databasepersistPersisting data between server restarts# ExampleFor this example to work, the code needs to use a generated test wallet. To achieve this the arweave package must be installed to the project along with arlocalyarn add arweave arlocal -D or npm install --save-dev arweave arlocalBelow is a basic JavaScript test for creating a data transaction and posting it to Arweave using arlocal:import ArLocal from 'arlocal' import Arweave from 'arweave' test('test transaction', async () => { // create and start ArLocal instance const arLocal = new ArLocal() await arLocal.start() // create local Arweave gateway const arweave = Arweave.init({ host: 'localhost', port: 1984, protocol: 'http' }) // generate wallet const wallet = await arweave.wallets.generate() // airdrop amount of tokens (in winston) to wallet await arweave.api.get(`mint/${addr}/10000000000000000`) // create mine function const mine = () => arweave.api.get('mine') try { // create transaction let transaction = await arweave.createTransaction({ data: '<html><head><meta charset=\"UTF-8\"><title>Hello world!</title></head><body></body></html>' }, wallet); // sign and post transaction await arweave.transactions.sign(transaction, wallet); const response = await arweave.transactions.post(transaction); // mine transaction await mine() // test the response } catch(err) { console.error('ERROR: ', err.message) } // tear down testing environment await arLocal.stop() }) WARNINGTest results from L1 transactions may differ from L2 transactions# Resourcesarlocal docsopen in new window",
          "estimatedWords": 377,
          "lastModified": "2025-06-27T16:25:55.703Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:55.703Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/vouch.html",
          "title": "Vouch",
          "content": "Contributors: Jack Frain, PBillingsbyLast Updated: Edit# VouchThere are a few ways to query an Arweave address to verify if it has been vouched by a service. Below is two of those approaches.# VouchDAO PackageThe isVouched function is made available to use in your applications in a straight-forward way.# InstallationAdd the package:NPMYARNnpm i vouchdao yarn add vouchdao # UsageInside of an async function you can use the isVouched function which will return true if a user is vouched.import { isVouched } from 'vouchdao' (async () => { const res = await isVouched(\"ARWEAVE_ADDRESS\") // true || undefined // ... })(); # Using GraphQLYou can query the Arweave network using GraphQL to find out if a given Arweave address has been vouched.query { transactions( tags:{name:\"Vouch-For\", values:[\"ARWEAVE_ADDRESS\"]} ) { edges { node { id tags { name value } } } } } If the address has been vouched, an array of nodes will be returned with tags pertaining to the service that issues the ANS-109. You can cross reference the owner address value with the passed community votes to ensure the service has been verified through community vote via VouchDAO.\"owner\": { \"address\": \"Ax_uXyLQBPZSQ15movzv9-O1mDo30khslqN64qD27Z8\" }, \"tags\": [ { \"name\": \"Content-Type\", \"value\": \"application/json\" }, { \"name\": \"App-Name\", \"value\": \"Vouch\" }, { \"name\": \"App-Version\", \"value\": \"0.1\" }, { \"name\": \"Verification-Method\", \"value\": \"Twitter\" }, { \"name\": \"Vouch-For\", \"value\": \"ARWEAVE_ADDRESS\" } ] # ResourcesVouchDAOopen in new windowVouchDAO Contractopen in new windowArweave/GraphQL Playgroundopen in new window",
          "estimatedWords": 237,
          "lastModified": "2025-06-27T16:25:56.178Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:56.178Z"
        },
        {
          "url": "https://cookbook.arweave.net/references/index.html",
          "title": "References",
          "content": "Contributors: Tom Wilson, Harpreet Singh, Luke Cassady-DorionLast Updated: Edit# ReferencesReferences for learning in depth about various topics like Bundling, GraphQL, and HTTP APIs.BundlingGraphQLHTTP APIDo you think a permaweb guide is missing? Create a issue at Githubopen in new window or consider contributing Guides Starter Kits",
          "estimatedWords": 45,
          "lastModified": "2025-06-27T16:25:56.272Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:56.272Z"
        },
        {
          "url": "https://cookbook.arweave.net/references/bundling.html",
          "title": "Bundling",
          "content": "Contributors: Jim Toth, Pawan Paudel, Luke Cassady-DorionLast Updated: Edit# BundlingBefore getting started with any of the below references, make sure you've read Bundles and Bundling from Core Concepts.# SetupWe'll be using the arbundlesopen in new window library which is a JavaScript implementation of the ANS-104 specificationopen in new window. ArBundles comes with TypeScript support.Note: This reference assumes a NodeJS environment. Browser compatibility with ArBundles is possible but currently requires wrangling Buffer polyfills. This will be addressed in a future version of ArBundles.NPMYARNnpm install arbundles yarn add arbundles # Create a SignerIn order to create Data Items, we need to first create a Signer.TSimport { ArweaveSigner, JWKInterface } from 'arbundles' const jwk: JWKInterface = { /* your Arweave jwk keyfile */ } const signer = new ArweaveSigner(jwk) # Create a DataItemTo create a DataItem, we pass some data along with a Signer to the createData() utility function.Note: While the createData() utility function requires a Signer, the returned DataItem is not yet signed and contains a placeholder ID.TSimport { createData } from 'arbundles' // Create a DataItem from a string const myStringData: string = 'Hello, Permaweb!' const myDataItem = createData(myStringData, signer) // Create a DataItem from a Buffer or Uint8Array const myBufferData: Buffer | Uint8Array = Buffer.from('Hello, Permaweb!') const myOtherDataItem = createData(myBufferData, signer) /* !!!WARNING!!! DATA ITEM ARE NOT YET SIGNED! */ # Create a BundleTo create a Bundle, we pass our DataItem to the bundleAndSignData utility function and await the result.Note: A DataItem passed to this utility function can be pre-signed as detailed in a later section.TSimport { bundleAndSignData } from 'arbundles' const dataItems = [ myDataItem, myOtherDataItem ] const bundle = await bundleAndSignData(dataItems, signer) # Create a Transaction from a BundleIn order to post a Bundle to Arweave there ultimately needs to be a root Layer 1 Transaction containing the Bundle.TSimport Arweave from 'Arweave' // Set up an Arweave client const arweave = new Arweave({ protocol: 'https', host: 'arweave.net', port: 443 }) // Create using ArweaveJS const tx = await arweave.createTransaction({ data: bundle.getRaw() }, jwk) // OR Create from the Bundle itself const tx = await bundle.toTransaction({}, arweave, jwk) // Sign the transaction await arweave.transactions.sign(tx, jwk) // Post tx to Arweave with your preferred method! # Sign a DataItemIn order to get a DataItem's ID (e.g. for use in a manifest also contained in the same bundle), we must call and await its .sign() method. If signing is successful, the DataItem will now have their unique ID and signature and are ready to be added to a Bundle.TSawait myDataItem.sign(signer) await myOtherDataItem.sign(signer) const id1 = myDataItem.id const id2 = myOtherDataItem.id # Tagging DataItemDataItem can themselves have tags just as Layer 1 Arweave Transactions can have tags. Once an Arweave Gateway unbundles and indexes the Bundle, these DataItem tags become queryable the same way a Layer 1 Arweave Transaction's tags are queryable.TS const myStringData: string = 'Hello, Permaweb!' const tags = [ { name: 'Title', value: 'Hello Permaweb' }, { name: 'Content-Type', value: 'text/plain' } ] const myDataItem = createData(myStringData, signer, { tags }) # Consuming BundlesWARNING: Be sure that the Buffer you pass to new Bundle(buffer) does contain a Bundle, otherwise, very small Buffer being passed will crash the thread. DO NOT use new Bundle(buffer) in a production environment. Instead, see the streamable interfaceopen in new window in the ArBundles repository.TS const bundle = new Bundle(Buffer.from(tx.data)) const myDataItem = bundle.get(0) const myOtherDataItem = bundle.get(1) GraphQL",
          "estimatedWords": 564,
          "lastModified": "2025-06-27T16:25:56.850Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:56.850Z"
        },
        {
          "url": "https://cookbook.arweave.net/references/gql.html",
          "title": "Complete GraphQL Structure for Transactions",
          "content": "Contributors: Dan MacDonald, Ros Mc Mahon, Tom WilsonLast Updated: Edit# Complete GraphQL Structure for TransactionsThe following GraphQL query returns all of the properties of a transaction captured by the indexing service.query { transactions { pageInfo { hasNextPage } edges { cursor node { id anchor signature recipient owner { address key } fee { winston ar } quantity { winston ar } data { size type } tags { name value } block { id timestamp height previous } parent { id } } } } } # PaginationBy default, GraphQL queries return the first 10 results. Larger result sets can be requested by adding the first: X option (where X is a value from 1 to 100) to the transactions query.query { transactions( first:100, tags: [ { name: \"App-Name\", values: [\"PublicSquare\"] } ] ) { edges { node { id tags { name value } } } } } If there are more than 100 items in the result set, subsequent pages of results can be retrieved by using a cursor.query { transactions( first:100, tags: [ { name: \"App-Name\", values: [\"PublicSquare\"] } ] ) { pageInfo { hasNextPage } edges { cursor node { id tags { name value } } } } } If there are subsequent result pages hasNextPage will have a value of true. Take the cursor value of the last item in the result set and use it as the value for the after query parameter.query { transactions( first:100, after: \"WyIyMDIyLTEyLTMwVDE2OjQ0OjIzLjc0OVoiLDEwMF0=\", tags: [ { name: \"App-Name\", values: [\"PublicSquare\"] } ] ) { pageInfo { hasNextPage } edges { cursor node { id tags { name value } } } } } To retrieve the entire results set, repeat the after query with an updated cursor value from the last item of each page until hasNextPage is false.# Rate LimitingIndexing services will implement rate limiting to prevent attacks and abuse of their services. The arweave.net/graphql service limits GraphQL queries to 600 queries every 5 minutes (per IP address). Always check the results of your queries to see if they have a status code in the 200s before parsing the response. A HTTP Status code of 429 will indicate rate limiting is being enforced. A HTTP Status code of 503 usually indicates that the query result set is too large for arweave.net/graphql.# ResourcesFor a more complete listing of the Arweave GraphQL schema see the Arweave GraphQL Guideopen in new windowArDB packagear-gql packageFor a general guide to graphql graphql.org/learnopen in new window is a good starting point Bundling HTTP API",
          "estimatedWords": 422,
          "lastModified": "2025-06-27T16:25:57.434Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:57.434Z"
        },
        {
          "url": "https://cookbook.arweave.net/references/http-api.html",
          "title": "Arweave peer HTTP API",
          "content": "Contributors: Ros Mc Mahon, Dan MacDonaldLast Updated: Edit# Arweave peer HTTP APIFor a more complete reference of the Arweave peer HTTP APIs see the linked guideopen in new window.The endpoints present here are for done so for convenance and/or because they were omitted from the linked guideopen in new window.Permaweb gateway services are typically backed by one or more full Arweave nodes. As a result they will often expose the node endpoints under the /tx/ path and routing the request directly to an Arweave node. This means these methods can often be called on a gateway as well as directly on an arweave peer/node.# Get by fieldRetrieves the header fields associated with a transaction directly from an Arweave node. Can be used to retrieve the transaction data as well, if the node stores the chunks, and the data is small enough for the node to serve.https://arweave.net/tx/TX_ID/FIELDAvailable fields: id | last_tx | owner | target | quantity | data | reward | signatureconst result = await fetch('https://arweave.net/tx/sHqUBKFeS42-CMCvNqPR31yEP63qSJG3ImshfwzJJF8/data') // fields are returned in base64url format, so we need to decode const base64url = await result.text() const jsonData = JSON.parse( Arweave.utils.b64UrlToString(base64url) ) console.log(jsonData) Click to view example result{ \"ticker\":\"ANT-PENDING\", \"name\":\"pending\", \"owner\":\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"controller\":\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"evolve\":null, \"records\": { \"@\":\"As-g0fqvO_ALZpSI8yKfCZaFtnmuwWasY83BQ520Duw\" }, \"balances\":{\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\":1} } # Get Wallet BalanceThe returned balance is in Winston. To get balance in $AR, divide the balance by 1000000000000 https://arweave.net/wallet/ADDRESS/balanceconst res = await axios.get(`https://arweave.net/wallet/NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0/balance`) console.log(res) console.log(res.data / 1000000000000) 6638463438702 // Winston 6.638463438702 // $AR # Get transaction statushttps://arweave.net/tx/TX_ID/statusTIPThis endpoint only supports base Arweave transactions not bundled transactions. Transactions must be confirmed on-chain before their status will be available. const response = await fetch('https://arweave.net/tx/EiRSQExb5HvSynpn0S7_dDnwcws1AJMxoYx4x7nWoho/status') const result = await response.json() console.log(JSON.stringify(result)) Click to view example result{ \"block_height\":1095552,\"block_indep_hash\":\"hyhLEyOw5WcIhZxq-tlnxhnEFgKChKHFrMoUdgIg2Sw0WoBMbdx6uSJKjxnQWon3\",\"number_of_confirmations\":10669 } # Get network informationconst res = await axios.get('https://arweave.net/info') console.log(res.data) Click to view example result{ \"network\": \"arweave.N.1\", \"version\": 5, \"release\": 53, \"height\": 1106211, \"current\": \"bqPU_7t-TdRIxgsja0ftgEMNnlGL6OX621LPJJzYP12w-uB_PN4F7qRYD-DpIuRu\", \"blocks\": 1092577, \"peers\": 13922, \"queue_length\": 0, \"node_state_latency\": 0 } GraphQL",
          "estimatedWords": 316,
          "lastModified": "2025-06-27T16:25:57.895Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:57.895Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/index.html",
          "title": "Starter Kits",
          "content": "Contributors: Tom Wilson, Andr√© Nunes, Jack Frain, Luke Cassady-Dorion, VinceJulianoLast Updated: Edit# Starter KitsStarter kits are boiler plate repositories for specific frameworks configured and ready to go, to build on the permaweb.ReactSvelteVue References Community",
          "estimatedWords": 34,
          "lastModified": "2025-06-27T16:25:57.997Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:57.997Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/react/index.html",
          "title": "React Starter Kits",
          "content": "Contributors: Brian Gershon, Tom Wilson, Jack Frain, Marton Lederer, VinceJuliano, Weronika KLast Updated: Edit# React Starter KitsReact is a popular library used for building user interfaces. Alongside other popular tools such as create-react-app, a React project can be compiled into a bundle. This bundle can be uploaded as a transaction to the permaweb where it will serve as a single page application.React Starter Kit Guides:Vite - React + Vite, publish with permaweb-deployCreate React App - utilize Create React App to build a React permaweb appPermaweb Application Constraints100% Front-end application (No Server-Side Backend)Applications are served from a sub-path (https://[gateway]/[TX_ID]) Svelte",
          "estimatedWords": 99,
          "lastModified": "2025-06-27T16:25:58.465Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:58.465Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/react/turbo.html",
          "title": "React Starter Kit wvite  ArDrive",
          "content": "Contributors: Jack Frain, Tom WilsonLast Updated: Edit# React Starter Kit w/vite & ArDriveThis guide will walk you through in a step by step flow to configure your development environment to build and deploy a permaweb react application.# PrerequisitesBasic Typescript Knowledge (Not Mandatory) - [https://www.typescriptlang.org/docs/](Learn Typescript)NodeJS v16.15.0 or greater - [https://nodejs.org/en/download/](Download NodeJS)Knowledge of ReactJS - [https://reactjs.org/](Learn ReactJS)Know git and common terminal commands# Development DependenciesTypeScriptNPM or Yarn Package Manager# Steps# Create React AppNPMYARNnpm create vite my-arweave-app --template react-ts cd my-arweave-app npm install yarn create vite my-arweave-app --template react-ts cd my-arweave-app yarn # Add React Router DOMNPMYARNnpm install react-router-dom yarn add react-router-dom We need to use the hash-router to create a working app on arweave.# Page Componentstouch src/Home.tsx src/About.tsx src/Home.tsximport { Link } from \"react-router-dom\"; function Home() { return ( <div> Welcome to the Permaweb! <Link to={\"/about/\"}> <div>About</div> </Link> </div> ); } export default Home; src/About.tsximport { Link } from \"react-router-dom\"; function About() { return ( <div> Welcome to the About page! <Link to={\"/\"}> <div>Home</div> </Link> </div> ); } export default About; # Modify App.tsxWe need to update the App.tsx to manage different pagesimport { HashRouter } from \"react-router-dom\"; import { Routes, Route } from \"react-router-dom\"; import Home from \"./Home\"; import About from \"./About\"; function App() { return ( <HashRouter> <Routes> <Route path={\"/\"} element={<Home />} /> <Route path={\"/about/\"} element={<About />} /> </Routes> </HashRouter> ); } export default App; # Modify index.cssAlter the body selectorbody { margin: 0; padding-top: 200px; display: flex; flex-direction: column; place-items: center; min-width: 100%; min-height: 100vh; } Run the projectNPMYARNnpm run dev yarn dev # Building React App# Modify vite.config.tsimport { defineConfig } from 'vite' import react from '@vitejs/plugin-react' // https://vitejs.dev/config/ export default defineConfig({ base: \"\", plugins: [react()], }) # Build Appyarn build # Deploy Permanently# Generate WalletWe need the arweave package to generate a walletNPMYARNnpm install --save arweave yarn add arweave -D then run this command in the terminalnode -e \"require('arweave').init({}).wallets.generate().then(JSON.stringify).then(console.log.bind(console))\" > wallet.json # Fund WalletYou will need to fund your wallet with ArDrive Turbo credits. To do this, enter ArDriveopen in new window and import your wallet. Then, you can purchase turbo credits for your wallet.# Setup Permaweb-DeployNPMYARNnpm install --global permaweb-deploy yarn global add permaweb-deploy # Update package.json{ ... \"scripts\": { ... \"deploy\": \"DEPLOY_KEY=$(base64 -i wallet.json) permaweb-deploy --ant-process << ANT-PROCESS >> \" } ... } Replace << ANT-PROCESS >> with your ANT process id.# Run buildNow it is time to generate a build, runNPMYARNnpm run build yarn build # Run deployFinally we are good to deploy our first Permaweb ApplicationNPMYARNnpm run deploy yarn deploy ERRORIf you receive an error Insufficient funds, make sure you remembered to fund your deployment wallet with ArDrive Turbo credits.# ResponseYou should see a response similar to the following:Deployed TxId [<<tx-id>>] to ANT [<<ant-process>>] using undername [<<undername>>] Your React app can be found at https://arweave.net/<< tx-id >>.SUCCESSYou should now have a React Application on the Permaweb! Great Job!# Congrats!You just published a react application on the Permaweb! This app will be hosted forever!",
          "estimatedWords": 489,
          "lastModified": "2025-06-27T16:25:58.572Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:25:58.572Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/react/create-react-app.html",
          "title": "Create React App Starter Kit",
          "content": "Contributors: Vince Juliano, VinceJuliano, mrsaifullah52, Jack Frain, Luke Cassady-Dorion, Tom Wilson, bobinstein, mrsaifullah52Last Updated: Edit# Create React App Starter KitThis guide will walk you through in a step by step flow to configure your development environment to build and deploy a permaweb react application.# PrerequisitesBasic Typescript Knowledge (Not Mandatory) - [https://www.typescriptlang.org/docs/](Learn Typescript)NodeJS v16.15.0 or greater - [https://nodejs.org/en/download/](Download NodeJS)Knowledge of ReactJS - [https://reactjs.org/](Learn ReactJS)Know git and common terminal commands# Development DependenciesTypeScriptNPM or Yarn Package Manager# Steps# Create ProjectIf you are not familiar with typescript you can exclude the extra check --template typescriptNPMYARNnpx create-react-app permaweb-create-react-app --template typescript yarn create react-app permaweb-create-react-app --template typescript # Change into the Project Directorycd permaweb-create-react-app # Install react-router-domYou have to install this package to manage routing between different pagesNPMYARNnpm install react-router-dom --save yarn add react-router-dom -D # Run the AppNow we need to check if everything is working before jumping into next step, runNPMYARNnpm start yarn start This will start a new development server locally on your machine. By default it uses `PORT 3000`, if this PORT is already in use it may ask you to switch to another available PORT in Terminal # Modify the package.json to contain the following config{ ... \"homepage\": \".\", } # Setup RoutingNow modify the application and add a new route such as an about page, first create 2 more .tsx files. (if you have exluceded the extra check --template typescript, then your component file extension should be .jsx or .js)touch src/HomePage.tsx touch src/About.tsx # HomePage.tsximport { Link } from \"react-router-dom\"; function HomePage() { return ( <div> Welcome to the Permaweb! <Link to={\"/about/\"}> <div>About</div> </Link> </div> ); } export default HomePage; # About.tsximport { Link } from \"react-router-dom\"; function About() { return ( <div> Welcome to the About page! <Link to={\"/\"}> <div>Home</div> </Link> </div> ); } export default About; # Modify App.tsxWe need to update the App.tsx to manage the different pagesimport { HashRouter } from \"react-router-dom\"; import { Routes, Route } from \"react-router-dom\"; import HomePage from \"./HomePage\"; import About from \"./About\"; function App() { return ( <HashRouter> <Routes> <Route path={\"/\"} element={<HomePage />} /> <Route path={\"/about/\"} element={<About />} /> </Routes> </HashRouter> ); } export default App; Hash RoutingNote that we are wrapping the routes in a HashRouter and using the react-router-dom Link component to build links. This is important on the permaweb in its current state, it will ensure the routes work properly because applications are served on a path like https://[gateway]/[TX]# Deploy Permanently# Generate WalletExisting WalletThis step will generate a new, empty, Arweave wallet. If you already have an existing Arweave wallet you may provide its keyfile and skip this step.We need the arweave package to generate a walletNPMYARNnpm install --save arweave yarn add arweave -D then run this command in the terminalnode -e \"require('arweave').init({}).wallets.generate().then(JSON.stringify).then(console.log.bind(console))\" > wallet.json It is very important to make sure that your wallet file is not included in any folder you want uploaded to Arweave.# Setup TurboWe need Turbo to deploy our app to the Permaweb.# Fund WalletYou will need to fund your wallet with ArDrive Turbo credits. To do this, enter ArDriveopen in new window and import your wallet. Then, you can purchase turbo credits for your wallet.# Setup Permaweb-DeployNPMYARNnpm install --global permaweb-deploy yarn global add permaweb-deploy # Fund Your WalletTurbo uses Turbo Credits to upload data to Arweave. You can purchase Turbo Credits with a variety of fiat currencies or crypto tokens. Below is an example for funding your wallet with 10 USD. It will open a browser window to complete the purchase using Stripe.npm install @ardrive/turbo-sdk turbo top-up --wallet-file wallet.json --currency USD --value 10 Be sure to replace wallet.json with the path to your Arweave wallet.# Update package.json{ ... \"scripts\": { ... \"deploy\": \"turbo upload-folder --folder-path ./build --wallet-file wallet.json > latest-manifest.json\" } ... } This will upload your build folder to the permaweb, and save all of the details of the upload to a file named \"latest-manifest.json\". That way, you'll have a reference for the manifest TxId to use later.# Run buildNow it is time to generate a build, runNPMYARNnpm run build yarn build # Run deployFinally we are good to deploy our first Permaweb ApplicationNPMYARNnpm run deploy yarn deploy ERRORIf you receive an error Insufficient funds, make sure you remembered to fund your deployment wallet with ArDrive Turbo credits.# ResponseYou should see a response similar to the following:Deployed TxId [<<tx-id>>] to ANT [<<ant-process>>] using undername [<<undername>>] Your React app can be found at https://arweave.net/<< tx-id >>.SUCCESSYou should now have a React Application on the Permaweb! Great Job!# SummaryThis is a Create React App version of publishing a React app on the permaweb. You may discover new ways to deploy an app on the permaweb or checkout other starter kits in this guide!",
          "estimatedWords": 780,
          "lastModified": "2025-06-27T16:25:59.089Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:25:59.089Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/svelte/index.html",
          "title": "Svelte Starter Kits",
          "content": "Contributors: Brian Gershon, Tom WilsonLast Updated: Edit# Svelte Starter KitsSvelte is a framework that compiles to a JavaScript bundle and in the process removes the framework from the distribution of the app. This results in a much smaller footprint than other frameworks. Svelte is the perfect framework for Permaweb Applications. A Permaweb Application is built on the principles of a Single Page Application, but lives on the Arweave network and is distributed by Permaweb gateways.Svelte Starter Kit Guides:Minimal - the minimum required to build a svelte permaweb appVite - Svelte, Typescript and VitePermaweb Application Constraints100% Front-end application (No Server-Side Backend)Applications are served from a sub-path (https://[gateway]/[TX_ID]) React Vue",
          "estimatedWords": 108,
          "lastModified": "2025-06-27T16:25:59.160Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:25:59.160Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/svelte/minimal.html",
          "title": "Minimal Svelte Starter Kit",
          "content": "Contributors: Tom Wilson, Jack Frain, Luke Cassady-Dorion, bobinsteinLast Updated: Edit# Minimal Svelte Starter KitThis guide will walk you through in a step by step flow to configure your development environment to build and deploy a permaweb application.# PrerequisitesKnow typescriptNodeJS v18 or greaterKnow Svelte - https://svelte.devopen in new windowKnow git and common terminal commands# Development DependenciesTypeScriptesbuildw3# Steps# Create ProjectNPMYARNmkdir myproject cd myproject npm init -y npm install -D svelte esbuild typescript esbuild-svelte tinro svelte-preprocess mkdir myproject cd myproject yarn init -y yarn add -D svelte esbuild typescript esbuild-svelte tinro svelte-preprocess # Create buildscript.jsimport fs from \"fs\"; import esbuild from \"esbuild\"; import esbuildSvelte from \"esbuild-svelte\"; import sveltePreprocess from \"svelte-preprocess\"; //make sure the directoy exists before stuff gets put into it if (!fs.existsSync(\"./dist/\")) { fs.mkdirSync(\"./dist/\"); } esbuild .build({ entryPoints: [`./src/main.ts`], bundle: true, outdir: `./dist`, mainFields: [\"svelte\", \"browser\", \"module\", \"main\"], // logLevel: `info`, splitting: true, write: true, format: `esm`, plugins: [ esbuildSvelte({ preprocess: sveltePreprocess(), }), ], }) .catch((error, location) => { console.warn(`Errors: `, error, location); process.exit(1); }); //use a basic html file to test with fs.copyFileSync(\"./index.html\", \"./dist/index.html\"); # Modify package.jsonSet type to module, add a build script{ \"type\": \"module\" ... \"scripts\": { \"build\": \"node buildscript.js\" } } # Create src directory and some src filesmkdir src touch src/main.ts touch src/app.svelte touch src/counter.svelte touch src/about.svelte # Main.tsimport App from \"./app.svelte\"; new App({ target: document.body, }); # app.svelte<script lang=\"ts\"> import { Route, router } from \"tinro\"; import Counter from \"./counter.svelte\"; import About from \"./about.svelte\"; // add hash routing for permaweb support router.mode.hash(); </script> <nav><a href=\"/\">Home</a> | <a href=\"/about\">About</a></nav> <Route path=\"/\"><Counter /></Route> <Route path=\"/about\"><About /></Route> Hash RoutingYou will notice the router.mode.hash() setting in the script session, this is important to configure your application to use hash based routing, which will enable url support when running that application on a path, like https://[gateway]/[TX]# counter.svelte<script lang=\"ts\"> let count = 0; function inc() { count += 1; } </script> <h1>Hello Permaweb</h1> <button on:click=\"{inc}\">Inc</button> <p>Count: {count}</p> # about.svelte<h1>About Page</h1> <p>Minimal About Page</p> <a href=\"/\">Home</a> # Add index.html<!doctype html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\" /> <link rel=\"icon\" type=\"image/svg+xml\" href=\"/vite.svg\" /> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /> <title>Vite + Svelte + TS</title> </head> <body> <div id=\"app\"></div> <script type=\"module\" src=\"./main.js\"></script> </body> </html> # Deploy Permanently# Generate WalletWe need the arweave package to generate a walletNPMYARNnpm install --save arweave yarn add arweave -D then run this command in the terminalnode -e \"require('arweave').init({}).wallets.generate().then(JSON.stringify).then(console.log.bind(console))\" > wallet.json # Fund WalletYou will need to fund your wallet with ArDrive Turbo credits. To do this, enter ArDriveopen in new window and import your wallet. Then, you can purchase turbo credits for your wallet.# Setup Permaweb-DeployNPMYARNnpm install --global permaweb-deploy yarn global add permaweb-deploy # Update vite.config.tsimport { defineConfig } from 'vite' import { svelte } from '@sveltejs/vite-plugin-svelte' export default defineConfig({ plugins: [svelte()], base: './' }) # Update package.json{ ... \"scripts\": { ... \"deploy\": \"DEPLOY_KEY=$(base64 -i wallet.json) permaweb-deploy --ant-process << ANT-PROCESS >> --deploy-folder build\" } ... } Replace << ANT-PROCESS >> with your ANT process id.# Run buildNow it is time to generate a build, runNPMYARNnpm run build yarn build # Run deployFinally we are good to deploy our first Permaweb ApplicationNPMYARNnpm run deploy yarn deploy ERRORIf you receive an error Insufficient funds, make sure you remembered to fund your deployment wallet with ArDrive Turbo credits.# ResponseYou should see a response similar to the following:Deployed TxId [<<tx-id>>] to ANT [<<ant-process>>] using undername [<<undername>>] Your Svelte app can be found at https://arweave.net/<< tx-id >>.SUCCESSYou should now have a Svelte Application on the Permaweb! Great Job!# SummaryThis is a minimal version of publishing a Svelte application on the permaweb, but you may want more features, like hot-reloading and tailwind, etc. Check out hypar for a turnkey starter kit. HypARopen in new window",
          "estimatedWords": 607,
          "lastModified": "2025-06-27T16:25:59.670Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:25:59.670Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/svelte/vite.html",
          "title": "SvelteVite Starter Kit",
          "content": "Contributors: Tom Wilson, Jack Frain, Luke Cassady-Dorion, bobinsteinLast Updated: Edit# Svelte/Vite Starter KitSvelte is the framework that compiles out of the way, that results is small packages, which is perfect for the permaweb. As developers, we value Dev Experience as much as we value User Experience. This kit uses the vite bundle system to give developers a great DX experience.# Installing vite with svelte and typescriptNPM v6NPM v7YARNPNPMnpm create vite@latest my-perma-app --template svelte-ts npm create vite@latest my-perma-app -- --template svelte-ts yarn create vite my-perma-app --template svelte-ts pnpm create vite my-perma-app --template svelte-ts # Project InfoThe vite build system places your index.html file in the root directory, this is where you would include any css or global script dependencies if needed. For more information about the vite project layout check out the vite documentationopen in new window# Setup hash-routerTo setup the hash-router we will use tinroopen in new window. tinro is a tiny declarative routing library, that is similar to React Router.NPMYARNnpm install --save-dev tinro yarn add -D tinro # Telling Svelte to use hash routingIn the src/App.svelte file, you want to configure the router to use the hash routing mode.<script lang=\"ts\"> import { Route, router } from \"tinro\"; router.mode.hash(); router.subscribe((_) => window.scrollTo(0, 0)); </script> <main></main> The router.mode.hash function turns on hash router mode. The router.subscribe callback is nice to reset the page to the top on page transfers# Adding some transition componentsThese component will manage the transition between one page to another page when routing.Create a directory under the src directory called components and add these two files:# announcer.svelte<script> import { router } from \"tinro\"; $: current = $router.path === \"/\" ? \"Home\" : $router.path.slice(1); </script> <div aria-live=\"assertive\" aria-atomic=\"true\">{#key current} Navigated to {current} {/key}</div> <style> div { position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px; } </style> This component is for screen readers announcing when a page changes# transition.svelte<script> import { router } from \"tinro\"; import { fade } from \"svelte/transition\"; </script> {#key $router.path} <div in:fade={{ duration: 700 }}> <slot /> </div> {/key} This component adds a fade to the page transition# Adding Routes to the app<script lang=\"ts\"> ... import Announcer from \"./components/announcer.svelte\"; import Transition from \"./components/transition.svelte\"; ... </script> <Announcer /> <Transition> <Route path=\"/\"> <Home /> </Route> <Route path=\"/about\"> <About /> </Route> </Transition> Adding the Announcer and Transition components to our routing system will handle announcing page transitions as well as animating the transition.# Create some pages# home.svelte<script lang=\"ts\"> let count = 0; function inc() { count += 1; } </script> <h1>Hello Permaweb</h1> <button on:click=\"{inc}\">Inc</button> <p>Count: {count}</p> <a href=\"/about\">About</a> # about.svelte<h1>About Page</h1> <p>Svelte/Vite About Page</p> <a href=\"/\">Home</a> # Modify App.svelte<script lang=\"ts\"> ... import Home from './home.svelte' import About from './about.svelte' </script> ... # Deploy Permanently# Generate WalletWe need the arweave package to generate a walletNPMYARNnpm install --save arweave yarn add arweave -D then run this command in the terminalnode -e \"require('arweave').init({}).wallets.generate().then(JSON.stringify).then(console.log.bind(console))\" > wallet.json # Fund WalletYou will need to fund your wallet with ArDrive Turbo credits. To do this, enter ArDriveopen in new window and import your wallet. Then, you can purchase turbo credits for your wallet.# Setup Permaweb-DeployNPMYARNnpm install --global permaweb-deploy yarn global add permaweb-deploy # Update vite.config.tsimport { defineConfig } from 'vite' import { svelte } from '@sveltejs/vite-plugin-svelte' export default defineConfig({ plugins: [svelte()], base: './' }) # Update package.json# Update package.json{ ... \"scripts\": { ... \"deploy\": \"DEPLOY_KEY=$(base64 -i wallet.json) permaweb-deploy --ant-process << ANT-PROCESS >> --deploy-folder build\" } ... } Replace << ANT-PROCESS >> with your ANT process id.# Run buildNow it is time to generate a build, runNPMYARNnpm run build yarn build # Run deployFinally we are good to deploy our first Permaweb ApplicationNPMYARNnpm run deploy yarn deploy ERRORIf you receive an error Insufficient funds, make sure you remembered to fund your deployment wallet with ArDrive Turbo credits.# ResponseYou should see a response similar to the following:Deployed TxId [<<tx-id>>] to ANT [<<ant-process>>] using undername [<<undername>>] Your Svelte app can be found at https://arweave.net/<< tx-id >>.SUCCESSYou should now have a Svelte Application on the Permaweb! Great Job!# SummaryThis is a minimal version of publishing a Svelte application on the permaweb, but you may want more features, like hot-reloading and tailwind, etc. Check out hypar for a turnkey starter kit. HypARopen in new window",
          "estimatedWords": 707,
          "lastModified": "2025-06-27T16:25:59.761Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:25:59.761Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/vue/index.html",
          "title": "Vue Starter Kits",
          "content": "Contributors: ropats16, Brian Gershon, Andr√© NunesLast Updated: Edit# Vue Starter KitsVue.js is a progressive JavaScript framework that allows building user interfaces. Unlike other frameworks, it compiles the template into JavaScript during runtime, resulting in a smaller file size and faster performance. Vue is ideal for building performant and scalable single-page applications, making it a popular choice among front-end developers.Vue Starter Kit Guides:Note: - Since npm init vue@latestalredy uses vite, we have not included a vite guide for Vue.Create Vue App - Use Create Vue to efficiently build a Vue.js-based with TypeScript and Vite modern permaweb applicationPermaweb Application Constraints100% Front-end application (No Server-Side Backend)Applications are served from a sub-path (https://[gateway]/[TX_ID]) Svelte",
          "estimatedWords": 110,
          "lastModified": "2025-06-27T16:26:00.234Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:00.234Z"
        },
        {
          "url": "https://cookbook.arweave.net/kits/vue/create-vue.html",
          "title": "Create Vue Starter Kit",
          "content": "Contributors: Andr√© Nunes, Jack Frain, Luke Cassady-Dorion, Tom Wilson, bobinsteinLast Updated: Edit# Create Vue Starter KitThis guide will provide step-by-step instructions to configure your development environment and build a permaweb Vue application.# PrerequisitesBasic Typescript Knowledge (Not Mandatory) - Learn Typescriptopen in new windowNodeJS v16.15.0 or greater - Download NodeJSopen in new windowKnowledge of Vue.js (preferably Vue 3) - Learn Vue.jsopen in new windowKnow git and common terminal commands# Development DependenciesTypeScript (Optional)NPM or Yarn Package Manager# Steps# Create ProjectThe following command installs and launches create-vue, the official scaffolding tool for Vue projects.NPMYARNnpm init vue@latest yarn create vue During the process, you'll be prompted to select optional features such as TypeScript and testing support. I recommend selecting the Vue Router with yes, the rest can be selected as per your preference.‚úî Project name: ‚Ä¶ <your-project-name> ‚úî Add TypeScript? ‚Ä¶ No / Yes ‚úî Add JSX Support? ‚Ä¶ No / Yes ‚úî Add Vue Router for Single Page Application development? ‚Ä¶ No / *Yes* ‚úî Add Pinia for state management? ‚Ä¶ No / Yes ‚úî Add Vitest for Unit testing? ‚Ä¶ No / Yes ‚úî Add Cypress for both Unit and End-to-End testing? ‚Ä¶ No / Yes ‚úî Add ESLint for code quality? ‚Ä¶ No / Yes ‚úî Add Prettier for code formatting? ‚Ä¶ No / Yes # Change into the Project Directorycd <your-project-name> # Install DependenciesNPMYARNnpm install yarn # Setup RouterVue Router is the official router for Vue.js and seamlessly integrates with Vue. To make it work with Permaweb, switch from a browser history router to a hash router as the URL cannot be sent to the server. Change createWebHistory to createWebHashHistory in your src/router/index.ts or src/router/index.js file.import { createRouter, createWebHashHistory } from \"vue-router\"; import HomeView from \"../views/HomeView.vue\"; const router = createRouter({ history: createWebHashHistory(import.meta.env.BASE_URL), routes: [ { path: \"/\", name: \"home\", component: HomeView, }, { path: \"/about\", name: \"about\", component: () => import(\"../views/AboutView.vue\"), }, ], }); export default router; # Setup BuildConfigure the build process in the vite.config.ts or vite.config.js file. To serve Permaweb apps from a sub-path (https://[gateway]/[TX_ID]), update the base property to ./ in the config file.export default defineConfig({ base: './', ... }) # Run the AppBefore moving forward, it is crucial to verify that everything is working correctly. Run a check to ensure smooth progress.NPMYARNnpm run dev yarn dev it will start a new development server locally on your machine by default it uses `PORT 5173`. If this PORT is already in use it may increase the PORT number by 1 (`PORT 5174`) and try again. # Deploy Permanently# Generate WalletWe need the arweave package to generate a walletNPMYARNnpm install --save arweave yarn add arweave -D then run this command in the terminalnode -e \"require('arweave').init({}).wallets.generate().then(JSON.stringify).then(console.log.bind(console))\" > wallet.json # Fund WalletYou will need to fund your wallet with ArDrive Turbo credits. To do this, enter ArDriveopen in new window and import your wallet. Then, you can purchase turbo credits for your wallet.# Setup Permaweb-DeployNPMYARNnpm install --global permaweb-deploy yarn global add permaweb-deploy # Fund Your WalletTurbo uses Turbo Credits to upload data to Arweave. You can purchase Turbo Credits with a variety of fiat currencies or crypto tokens. Below is an example for funding your wallet with 10 USD. It will open a browser window to complete the purchase using Stripe.npm install @ardrive/turbo-sdk turbo top-up --wallet-file wallet.json --currency USD --value 10 Be sure to replace wallet.json with the path to your Arweave wallet.# Update package.json{ ... \"scripts\": { ... \"deploy\": \"DEPLOY_KEY=$(base64 -i wallet.json) permaweb-deploy --ant-process << ANT-PROCESS >> --deploy-folder build\" } ... } Replace << ANT-PROCESS >> with your ANT process id.# Run buildNow it is time to generate a build, runNPMYARNnpm run build yarn build # Run deployFinally we are good to deploy our first Permaweb ApplicationNPMYARNnpm run deploy yarn deploy ERRORIf you receive an error Insufficient funds, make sure you remembered to fund your deployment wallet with ArDrive Turbo credits.# ResponseYou should see a response similar to the following:Deployed TxId [<<tx-id>>] to ANT [<<ant-process>>] using undername [<<undername>>] Your Vue app can be found at https://arweave.net/<< tx-id >>.SUCCESSYou should now have a Vue Application on the Permaweb! Great Job!# SummaryThis guide provides a simple step-by-step method to publish a Vue.js app on the Permaweb using Create Vue. If you need additional features Tailwind, consider exploring alternative starter kits listed in the guide to find a suitable solution for your requirements.",
          "estimatedWords": 720,
          "lastModified": "2025-06-27T16:26:00.336Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:26:00.336Z"
        },
        {
          "url": "https://cookbook.arweave.net/community/index.html",
          "title": "Community",
          "content": "Contributors: Jack Frain, Ros McMahonLast Updated: Edit# CommunityIf you've created something on the Permaweb, and would like to add documentation to this cookbook, consider contributing!# Community ContributionsArweave Name System (ArNS)Atomic Assetsusing ArDrive CLI Starter Kits Legacy",
          "estimatedWords": 36,
          "lastModified": "2025-06-27T16:26:00.821Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:00.821Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/arns.html",
          "title": "ArNS - Arweave Name System",
          "content": "Contributors: Jack Frain, Dan MacDonald, PBillingsby, atticusofsparta, dmacLast Updated: Edit# ArNS - Arweave Name System# OverviewThe Arweave Name System (ArNS) is the phonebook of the PermaWeb.It is a decentralized and censorship-resistant naming system that is enabled by AR.IO Gateways and used to connect friendly names to PermaWeb apps, pages and data.This system works similarly to traditional DNS, where a user can purchase a name in a registry and DNS Name servers resolve these names to IP addresses.With ArNS, the registry is decentralized, permanent and stored on Arweave and each AR.IO gateway acts as both cache and name resolver. Users can register a name within the ArNS Registry, like \"my-name\" and set a pointer to any Arweave Transaction ID. AR.IO Gateways will resolve that name as one of their own subdomains, eg. https://laserilla.arweave.net and proxy all requests to the associated Arweave Transaction ID. Each registered name can also have under names associated with it that each point to an Arweave Transaction ID, like https://v1_laserilla.arweave.net, giving even more flexibility and control to its owner.# The ArNS RegistryArNS uses the Smartweave protocol manage its name records. Each record, or name, is leased by a user and tied to an ANT token. You can register multiple ArNS names to a single ANT, but you cannot register multiple ANTs to a single ArNS name - the gateways wouldn't know where to point the routing ID.ArNS names can be up to 32 characters, including numbers [0-9], letters [a-z], and dashes [-]. The dashes cannot be trailing dashes, e.g. -myname.# ANTs (Arweave Name Tokens)ANTs are a crucial part of the ArNS ecosystem - they are the actual key to owning an ArNS name. When you register an ArNS name to an ANT, the ANT then becomes the transfer method for that name. The ArNS registry does not care who owns the ANT, it simply knows what name ANT it belongs to.Within ANTs you can build out whatever functionality you wish, within the scope ArNS registry approved source code transaction list. Up to and including NFT's, PST's, DAO's, or full on applications.# Under_NamesUndernames are records held and managed by your ANT (Arweave Name Token). These records can be created and managed without even owning an ARNS name, and will be transferred along with the ant when sent to a new owner. Likewise if your ArNS name expires, and you register your ANT to a new ArNS name, all your undername will remain intact.Example: you own oldName.arweave.net.then: You create the undername \"my\" - my_oldName.arweave.net.then: oldName.arweave.net expires, and you register newName.arweave.net to your ANT.now: my_ undername is accessable on newName - my_newName.arweave.net.Below is an example of an ANT contract State:{ balances:{ QGWqtJdLLgm2ehFWiiPzMaoFLD50CnGuzZIPEdoDRGQ : 1 }, controller: \"QGWqtJdLLgm2ehFWiiPzMaoFLD50CnGuzZIPEdoDRGQ\", evolve: null, name: \"ArDrive OG Logo\", owner: \"QGWqtJdLLgm2ehFWiiPzMaoFLD50CnGuzZIPEdoDRGQ\", records:{ @:{ transactionId: \"xWQ7UmbP0ZHDY7OLCxJsuPCN3wSUk0jCTJvOG1etCRo\" }, undername1:{ transactionId: \"usOLUmbP0ZHDY7OLCxJsuPCN3wSUk0jkdlvOG1etCRo\" } }, ticker:\"ANT-ARDRIVE-OG-LOGO\" } the base \"@\" record is the initial routing id for the ANT. if you registered 'my-name' to this ANT, and tried to access it via my-name.arweave.net, you would be redirected to the @ record's transactionId.if you tried to access undername1_my-name.arweave.net, you would get 'undername1's transactionId.ANT's, in theory, have an UNLIMITED number of undernames. However, how many will be served depends on which tier is used with your ArNS name.# Resources# ArNS Appopen in new window# ArNS Docsopen in new window Atomic Assets",
          "estimatedWords": 549,
          "lastModified": "2025-06-27T16:26:01.417Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:01.417Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/atomic-assets/index.html",
          "title": "Atomic Assets",
          "content": "Contributors: Ros McMahon, Tom Wilson, Weronika KLast Updated: Edit# Atomic AssetsAn atomic asset is a unique package that includes data, labels (also known as tags), and a specific agreement, all under a single, unchangeable identifier. This allows applications and users to access the data, labels, and agreement by using just this one identifier.To enable trading of the Atomic Asset, we must connect it to something called a SmartWeave Token. This connection transforms the asset into what's known as an Atomic Token and allows it to be exchanged or traded.The SmartWeave Token has a special feature called a balances object that keeps track of who owns the tokens related to that particular asset. This ensures that ownership and trades are recorded and managed accurately.# Deploying Atomic Assetsusing ArDrive CLI Arweave Name System (ArNS)",
          "estimatedWords": 132,
          "lastModified": "2025-06-27T16:26:01.499Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:01.499Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/atomic-assets/ardrive-cli.html",
          "title": "Deploy and Register Atomic Assets using ArDrive CLI",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Deploy and Register Atomic Assets using ArDrive CLIAtomic Assets need to be registered to be capable of being traded on the Permaweb. You can upload your assets using services like ardrive-cli and give the asset the proper data tags, then use this cli to register the asset.# Guide to publish an atomic asset using ArDrive-cli and asset-registar cli.# SetupRequires NodeJS - https://nodejs.org and jq - https://jqlang.github.io/jq/download/npm i -g ardrive-cli npm i -g asset-registar # Create Atomic Assets TagsUsing a text editor, we want to create a new file called data.json and in this new file add the following:{ \"dataGqlTags\": { \"Type\": \"ASSET_TYPE_HERE\", \"Title\": \"TITLE_HERE\", \"Description\": \"DESCRIPTION_HERE\", \"License\": \"yRj4a5KMctX_uOmKWCFJIjmY8DeJcusVk6-HzLiM_t8\", \"App-Name\": \"SmartWeaveContract\", \"App-Version\": \"0.3.0\", \"Contract-Src\": \"Of9pi--Gj7hCTawhgxOwbuWnFI1h24TTgO5pw8ENJNQ\", \"Indexed-By\": \"ucm\", \"Init-State\": \"{ \\\"ticker\\\": \\\"ATOMIC\\\", \\\"name\\\": \\\"ASSET_NAME_HERE\\\", \\\"balances\\\": { \\\"YOUR_WALLET_ADDRESS\\\": UNITS_HERE }, \\\"claimable\\\": [] }\" } } Now that you have your tags initialized you need to take every uppercase word and replace it with the values that are unique to your asset.ASSET_TYPE_HERE:This should be a one word description of your asset, \"image\", \"audio\", \"video\". etc.TITLE_HERE:A title that describes your asset, it should not be longer than 150 characters.DESCRIPTION_HERE:A description that you want to show up in search results or list results for your asset.ASSET_NAME_HERE:The name of your asset, in one word or connected with dashes ex. \"AA-ALIEN-WITH-BEER\".YOUR_WALLET_ADDRESS:The wallet address you want to give ownership too.UNITS_HERE:The number of fractional units you want to provide for this asset, if there can only be one owner then the replace with 1, if you want 100 owners replace with 100.save the file as data.json# Copy the asset you want to publish to this directory.# Uploading with new arweave wallet.Create a wallet or copy your wallet.json here.ardrive generate-seedphrase # copy the seed phrase that is in the output and include in the next command where the `...` are. # generate wallet ardrive generate-wallet -s \"...\" > wallet.json Using ardrive-cli we are going to create a drive and a folder.# create drive and folder export FOLDER=$(ardrive create-drive -w ./wallet.json -n \"My Atomic Assets\" --turbo | jq -r '.created[] | select(.type == \"folder\").entityId') # upload atomic asset export ASSET=$(ardrive upload-file -w ./wallet.json -F ${FOLDER} --metadata-file ./data.json -l ASSET_FILE_HERE --turbo | jq -r '.created[] | select(.type == \"file\").dataTxId') NOTE: if your file is larger than 500k, you will need to add credits to your ardrive wallet, you can do this by going to https://ardrive.io and logging in with your wallet file.# Register assetOnce the asset is uploaded with the Atomic Asset Tags, now all you have to do is call asset-register <assetId>asset-registar ${ASSET} # CONGRATS!You should be able to find your asset on ar://bazar by typing in the contractId in the search bar.",
          "estimatedWords": 446,
          "lastModified": "2025-06-27T16:26:02.070Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:02.070Z"
        },
        {
          "url": "https://cookbook.arweave.net/legacy/index.html",
          "title": "Legacy",
          "content": "Contributors: Jack FrainLast Updated: Edit# LegacyThe following concepts and guides have been deprecated.Concepts SmartweaveGuides Smartweave Community",
          "estimatedWords": 16,
          "lastModified": "2025-06-27T16:26:02.539Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:02.539Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/smartweave.html",
          "title": "SmartWeave",
          "content": "Contributors: Atticus, Pawan Paudel, Warcin, Dan MacDonald, Hachiman, Jack Frain, PBillingsby, Ros McMahonLast Updated: Edit# SmartWeave‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.# What is SmartWeave?SmartWeave is the name given to the dominant SmartContract paradigm on Arweave. A unique property of SmartWeave contracts is that the current state of the contract is provided by a process of \"lazy evaluation\". This means that instead of Arweave mining nodes constantly evaluating the current state of all contracts, a client reading a contract evaluates the state for themselves.# Why is SmartWeave important?The state and logic of decentralized applications need to be as censorship-resistant, permanent, and verifiable as the rest of their data. SmartWeave enables developers to write smart contracts that encapsulate their apps state and logic on-chain and execute it in a trustless verifiable way. This is no small feat as the Arweave protocol does not include incentives for nodes to evaluate smart contract state for the network.SmartWeave provides an immutable append-only pattern for contract interactions that leverage permanent storage to hold onto their state. The result is a fully decentralized on-chain state machine that can give protocols and applications dynamic functionality in a permissionless and trustless way. By using SmartWeave, developers can create smart contracts that are stored on Arweave and are guaranteed not to change over time. This allows them to build Permaweb applications with dynamic functionality that can be used in a permissionless and trustless manner.There are several reasons why developers might choose to use SmartWeave to implement the logic for their permaweb applications:Decentralized storage: SmartWeave is built on Arweave, which means that applications created using SmartWeave will be stored on a distributed network of nodes rather than on a centralized server. This can make them more resistant to censorship, tampering, and other forms of interference.Lazy evaluation: The lazy evaluation feature of SmartWeave contracts allows for efficient and scaleable execution. Instead of Arweave nodes constantly evaluating the state of a contract, the client reading the contract is responsible for evaluating the state, leveraging the users processing power instead of the networks nodes.Language support: SmartWeave supports a range of programming languages, including JavaScript, TypeScript, Rust, Go, AssemblyScript, and WASM (WebAssembly). This allows developers to use the language they are most familiar with when creating SmartWeave applications.Data durability: Arweave is designed to store data in a way that makes it highly durable and long-lasting. This can be useful for applications that need to store data over a long period of time, such as historical records or scientific data.Economic model: Arweave uses a unique economic model based on the concept of permanent storage that incentivizes miners to store data indefinitely. This can help ensure the long-term viability and durability of permaweb applications created using SmartWeave.# How does SmartWeave Work?SmartWeave contracts, at their core, are built from an initial contract state, with edits, additions, and subtractions using transaction tags.SmartWeave SDK's such as Warp (previously RedStone), are used to query for these transactions to build contract state locally, modifying the contract state with each transaction. The Evaluator (Warp) uses tags to query for a contracts transactions; It knows a transaction is part of the contract by way of the App-Name tag, and the Contract tag.Here is an example of a contract interaction .The App-Name says its a Smartweave ACTION .The Contract tag gives the specific transaction ID of the initial contract state.The Input tag gives the contract its function to execute and any other data it needs:[ { name:\"App-Name\" value:\"SmartWeaveAction\" }, { name:\"App-Version\" value:\"0.3.0\" }, { name:\"Contract\" value:\"pyM5amizQRN2VlcVBVaC7QzlguUB0p3O3xx9JmbNW48\" }, { name:\"Input\" value:\"{ \"function\":\"setRecord\", \"subDomain\":\"@\", \"transactionId\":\"lfaFgcoBT8auBrFJepLV1hyiUjtlKwVwn5MTjPnTDcs\" }\" } ] And here is an example of a contract .The App-Name says its a Smartweave CONTRACTThe Contract-Src tag points to the source code of the contract:[ { key:\"App-Name\" value:\"SmartWeaveContract\" }, { key:\"App-Version\" value:\"0.3.0\" }, { key:\"Contract-Src\" value:\"JIIB01pRbNK2-UyNxwQK-6eknrjENMTpTvQmB8ZDzQg\" }, { key:\"SDK\" value:\"RedStone\" }, { key:\"Content-Type\" value:\"application/json\" } ] The resulting state is the current contract state, which the SDK on the client side can use to calculate user balances, contract owners, and other contract specific details. Once the caller has a validated contract state they can build an interaction for the user to deploy to the chain, which upon mining or indexing on a Gateway will be included the next time someone builds the contract state.For a comprehensive overview of the SmartWeave Protocol, its leading implementation Warp Contracts, and more, head to Warp Academyopen in new window. Dive into step-by-step tutorials, explore advanced concepts, and uncover how SmartWeave power up the permaweb!# Smartweave ecosystem projectsThere's quite a few ecosystem projects leveraging SmartWeave SmartContracts, but here are some of notes:# ImplementationsWarpopen in new window | Main provider of SmartWeave SDK's, tutorials, and helps maintain the SmartWeave protocol.MEMopen in new window | Molecular Execution Machine (MEM) is a developer platform that powers the creation and usage of highly available and highly performant applications within a decentralized environment.# ToolsSonAropen in new window| SmartWeave contract explorer, created and hosted by Warp.# ResourcesWarp Academyopen in new window | A one-stop shop for all things SmartWeave# AppsPermapagesopen in new window | Permanent webpage creation tool, ArNS purchase portal, and ANT creation portal. Your profile on the permaweb.ArNS | Arweave Name System WeaveDBopen in new window | NoSQL Database as a Smart Contract.KwilDBopen in new window| SQL Database as a Smart Contract.ArDrive Infernoopen in new window | Get PST's for uploading thru Ardrive.FirstBatchopen in new window | FirstBatch aids developers and enterprises in creating personalized, private, and distortion-free AI applications.Othentopen in new window | Web3 transactions with existing traditional social logins.BazARopen in new window | Digital content marketplace with real-world rights.Alex the Archieveopen in new window | A decentralized archival platform utilizing Arweave's immutable storage.and so much more.",
          "estimatedWords": 945,
          "lastModified": "2025-06-27T16:26:02.644Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:02.644Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/psts.html",
          "title": "Overview",
          "content": "Contributors: Jack Smith, Jack FrainLast Updated: Edit# Overview‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.Profit Sharing Tokens (PSTs) are a type of SmartWeaveToken which include the following structure:propertytypebalancesobjectnamestringtickerstringtransfermethodbalancemethodPSTs are typically used to govern a protocol or \"Profit Sharing Community\" (PSC) - similar to a DAO.# How are PSTs Distributed?Founders of an application can create a set number of PSTs and distribute them as they see fit - to keep, or sell to investors to raise capital.Protocols can offer PSTs as a reward for contributing work, or completing tasks for the community to incentivize growth.PSTs can also be exchanged between each other on Permaswapopen in new window (currently in testnet), and developers can set up token trading permissions using Verto Flexopen in new window.# FeaturesPSTs work as ‚Äòmicro-dividends‚Äô. When a protocol is used, a tipping amount is set aside to be distributed amongst holders. The tip is paid out in $AR - not in the currency of the PST. This creates quite a special relationship between the app being developed, and Arweave itself.# BenefitsProvides a flexible way for developers to run a protocol and distribute as much ‚Äòownership‚Äô as they see fitPSTs can be used as payment for protocol work or for community tasksFounders are incentivized to increase network usage, as it is directly tied to revenueHolders get intrinsic value (rewards $AR, not more ‚Äòstock‚Äô)# Example PST: ARDRIVE TokenArDrive is a permaweb application utilitizing their aptly named PST, ARDRIVE.When someone pays $AR to upload data through ArDrive, a 15% community fee is distributed to a single token holder using a random, weighted method.A user uploads data -> An ARDRIVE token holder receives $AR -> ARDRIVE token holder can use this $AR to upload files -> cycle repeats. Hopefully this gives you a good idea of one way you could implement your own PST!# Exploring PSTsGoing straight to viewblock and Sonar by Redstone is most appropriate most likely. Just use links that specifically show PSTs so someone doesn‚Äôt have to navigate to find them.You can use ViewBlockopen in new window for an etherscan-like experience to view PST contracts, like this one hereopen in new window.Another option is Sonar, an Arweave smart contract explorer built by RedStone Financeopen in new window. View the same contract hereopen in new window.Some community members have been discussing calling PSTs ‚ÄúPermaweb Service Tokens‚Äù. There is still much to explore with PSTs ‚Üí join the discussion hereopen in new window (Discord).",
          "estimatedWords": 406,
          "lastModified": "2025-06-27T16:26:03.127Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:03.127Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/atomic-tokens/intro.html",
          "title": "Atomic Tokens",
          "content": "Contributors: Tom Wilson, Jack Frain, Luke Cassady-Dorion, Pawan PaudelLast Updated: Edit# Atomic Tokens‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.# What is an Atomic Token?Check out the concept# Creating an Atomic TokenINFORMATIONFor this example, we are using a SWT Contract Source that is already published on the network. x0ojRwrcHBmZP20Y4SY0mgusMRx-IYTjg5W8c3UFoNsopen in new window -example.tsimport Irys from '@irys/sdk' import { WarpFactory } from 'warp-contracts' async function main() { const wallet = JSON.parse(await import('fs') .then(fs => fs.readFileSync('./wallet.json', 'utf-8'))) const irys = new Irys({ 'https://node2.irys.xyz', 'arweave', wallet }) const warp = WarpFactory.forMainnet() const data = `<h1>Hello Permaweb!</h1>` const tags = [ { name: 'Content-Type', value: 'text/html' }, // ANS-110 Tags { name: 'Type', value: 'web-page' }, { name: 'Title', value: 'My first permaweb page' }, { name: 'Description', value: 'First permaweb page by Anon' }, { name: 'Topic:Noob', value: 'Noob' }, // SmartWeave Contract { name: 'App-Name', value: 'SmartWeaveContract' }, { name: 'App-Version', value: '0.3.0' }, { name: 'Contract-Src', value: 'x0ojRwrcHBmZP20Y4SY0mgusMRx-IYTjg5W8c3UFoNs' }, { name: 'Init-State', value: JSON.stringify({ balances: { 'cHB6D8oNeXxbQCsKcmOyjUX3UkL8cc3FbJmzbaj3-Nc': 1000000 }, name: 'AtomicToken', ticker: 'ATOMIC-TOKEN', pairs: [], creator: 'cHB6D8oNeXxbQCsKcmOyjUX3UkL8cc3FbJmzbaj3-Nc', settings: [['isTradeable', true]] }) } ] const { id } = await irys.upload(data, { tags }) await warp.createContract.register(id, 'node2') console.log('Atomic Token: ', id) } main() In this example, we are creating a data-item and uploading the item to the bundler network service. Then we are registering our contract with the Warp sequencer. By using bundler to publish our data-item and registering with the Warp sequencer, our data is immediately available on the gateway service and our contract is immediately able to accept interactions.Run Examplenpm install @irys/sdk warp-contracts npm install typescript ts-node npx ts-node example.ts INFORMATIONANS-110open in new window is an Asset Discovery Specification to allow for composability with the Permaweb Application ecosystem.# SummaryThis is a simple example of deploying an Atomic Asset, for more detailed examples check out: https://atomic-assets.arweave.devopen in new window# Working with TokensSmartWeave Contracts can not hold AR the native coin of the Arweave Network. AR is used to purchase storage for data on the Arweave Network and it can be transferred from a source wallet to a target wallet on the Arweave network, but it can not be held in a SmartWeave contract.",
          "estimatedWords": 365,
          "lastModified": "2025-06-27T16:26:03.216Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:03.216Z"
        },
        {
          "url": "https://cookbook.arweave.net/concepts/atomic-tokens.html",
          "title": "Atomic Token Concept and Principles",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Atomic Token Concept and PrinciplesAn Atomic Token is a single permanent identifier that references data and a SmartWeave Contract on the Permaweb.# SpecificationsData MUST be stored on the arweave network and referencable by a Transaction IdentifierContract MUST implement a balances object that represents the ownership of the Atomic TokenContract MUST implement a transfer function that takes the following arguments:target {WalletAddress or Contract}qty {Number}The transfer function should transfer ownership from the caller to the target# OptionsThese are implementation options that can make the Atomic Token discoverable and tradeable on the PermawebVerto Flexopen in new window - The Flex Library gives your atomic token to be sold or purchased without trusting an exchange.Discoverability Tags - ANS 110open in new window - These additional tags can help Permaweb applications and services discover your token.Check out the Guide",
          "estimatedWords": 139,
          "lastModified": "2025-06-27T16:26:03.707Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 4,
          "crawledAt": "2025-06-27T16:26:03.707Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/warp/intro.html",
          "title": "Warp (SmartWeave) SDK Intro",
          "content": "Contributors: Jack Frain, Luke Cassady-Dorion, Tom WilsonLast Updated: Edit# Warp (SmartWeave) SDK Intro‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.Warp is a popular SmartWeave Protocol SDK. With Warp and Irys your SmartWeave deployments and interactions can be extremely fast.# IntroductionThis guide is a short introduction to the Warp SDK and some of its API methods, if you want to learn more about SmartWeave Contracts in general visit Core Concepts: SmartWeave.TIPYou can find the Warp SDK on githubopen in new window. For a deeper dive on Warp SmartWeave visit Warp Websiteopen in new windowTo use the SDK on the server, you will need access to a wallet.json file, to use the SDK in the browser you will need to connect to an arweave supported wallet.# InstallTo install warp in your project you can use npm or yarn or other npm clients.NPMYARNnpm install warp-contracts yarn add warp-contracts # ImportWhen using Warp with your project there are several ways to import the sdk depending on your project setup.TypescriptESMCommonJSimport { WarpFactory } from \"warp-contracts\"; import { WarpFactory } from \"warp-contracts/mjs\"; const { WarpFactory } = require(\"warp-contracts\"); # Connecting to an environmentThere are several environments that you may want to interact with, you can connect to those environments using the forXXXX helpers.MainnetTestnetLocalCustomconst warp = WarpFactory.forMainnet(); const warp = WarpFactory.forTestnet(); const warp = WarpFactory.forLocal(); const warp = WarpFactory.custom( arweave, // arweave-js cacheOptions, // { ...defaultCacheOptions, inMemory: true} environment, // 'local', 'testnet', 'mainnet' ); WARNINGWhen using local environment, you will need to have arLocal running on port 1984.# SummaryThis intro guide is to help you get setup with Warp, the following guides will show you how to deploy SmartWeave contracts using the Warp SDK, how to interact with those contracts and finally, how to evolve SmartWeave contracts. Deploying Contracts",
          "estimatedWords": 295,
          "lastModified": "2025-06-27T16:26:03.787Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:03.787Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/warp/deploying-contracts.html",
          "title": "Warp (SmartWeave) SDK - Deploying Contracts",
          "content": "Contributors: Tom Wilson, Jack Frain, Luke Cassady-Dorion, mrsaifullah52Last Updated: Edit# Warp (SmartWeave) SDK - Deploying Contracts‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.SmartWeave Contracts are created by posting two transactions to the network, a Source Transaction and a Initial State Transaction, the source transaction contains the source code the contract will use to determine the current state. The initial state transaction provides a contract identifer to reference as well as the initial seed data the contract should use as the starting point to evaluate the current state. The current state is calculated by accessing actions that are transactions written to the network that contain input parameters to execute using the evaluated and instantiated source code. Warp Contracts can be created using many different languages and can be evaluated using the Warp SDK. This guide will show the many different ways you can deploy a Warp Contract.TIPIf you would like to learn more about authoring Warp SmartWeaveContracts, checkout the Warp Academy! https://academy.warp.cc/open in new windowAs of Warp version 1.3.0 you willl need a plugin to deploy contracts with Warp. This plugin will enable you to add different wallet signatures.import { DeployPlugin, InjectedArweaveSigner } from 'warp-contracts-plugin-deploy' import { WarpFactory } from 'warp-contracts' const warp = WarpFactory.forMainnet().use(new DeployPlugin()) ... function deploy(initState, src) { if (window.arweaveWallet) { await window.arweaveWallet.connect(['ACCESS_ADDRESS', 'SIGN_TRANSACTION', 'ACCESS_PUBLIC_KEY', 'SIGNATURE']); } const userSigner = new InjectedArweaveSigner(window.arweaveWallet); await userSigner.setPublicKey(); return warp.deploy({ wallet: userSigner, src, initState: JSON.stringify(initState) }) } # The Four ways to deploy a Warp SmartWeave ContractThere are 4 ways you can deploy a SmartWeaveContract via the Warp SDK, these options handle different use cases that a developer may encounter.Need to deploy the contract with the source at the same timeNeed to deploy a contract where the source is already on the permawebNeed to deploy a contract through the sequencer and point it to some data using a path manifestNeed to deploy a contract via Irys and register that contract on the sequencerTIPFor more information about Warp deployments check out the github Readme for the project. https://github.com/warp-contracts/warp#deploymentopen in new window.WARNINGThis project is in rapid development, so the documentation here could be out of data quickly, if you discover it is out of date, please let us know on the Permaweb Cookbook Discord Channelopen in new window.# ExamplesTIPBy default all deploy functions are published to Arweave via Irys, each option has a flag that can be set to not use Irys, but it can take many confirmations for the network to fully confirm the transaction.deployDeploys contract plus source code to Warp Sequencer, to Irys (L2), to Arweave.const { contractTxId, srcTxId } = await warp.deploy({ wallet, initState, data: { \"Content-Type\": \"text/html\", body: \"<h1>Hello World</h1>\" }, src: contractSrc, tags: [{ name: \"AppName\", value: \"HelloWorld\" }], }); wallet - should be Arweave keyfile (wallet.json) parsed as a JSON object implementing the JWK Interfaceopen in new window or the string 'use_wallet'initState - is a stringified JSON objectdata - is optional if you want to write data as part of your deploymentsrc - is the string or Uint8Array value of the source code for the contracttags - is an array of name/value objects {name: string, value: string}[], Learn more about tagsdeployFromSourceTxAlready have the source on the permaweb? Then deployFromSourceTx is your tool of choice! With the permaweb you never have to worry about data changing so re-using source code for contracts is a no brainer.const { contractTxId, srcTxId } = await warp.deployFromSourceTx({ wallet, initState, srcTxId: \"SRC_TX_ID\", }); deployBundledUses Warp Gateway Sequencer's endpoint to upload a raw data item to Irys and index it.import { createData } from \"arbundles\"; const dataItem = createData( JSON.stringify({ manifest: \"arweave/paths\", version: \"0.1.0\", index: { path: \"index.html\", }, paths: { \"index.html\": { id: \"cG7Hdi_iTQPoEYgQJFqJ8NMpN4KoZ-vH_j7pG4iP7NI\", }, }, }), { tags: [{ \"Content-Type\": \"application/x.arweave-manifest+json\" }] }, ); const { contractTxId } = await warp.deployBundled(dataItem.getRaw()); registerUses Warp Gateway Sequencer's endpoint to index a contract that has been uploaded with Irys.import Irys from '@irys/sdk' const irys = new Irys({ 'https://node2.irys.xyz', 'arweave', wallet }) const { id } = await irys.upload('Some Awesome Atomic Asset', { tags: [{'Content-Type': 'text/plain' }] }) const { contractTxId } = await warp.register(id, 'node2') # SummaryWhy are there so many options to deploy contracts? These methods exist to reduce duplication, enable advanced contract interactions, and allow for flexibility for testing and usage of the smartweave protocol. The permaweb is very unique in its architecture, it provides a feature where you can deploy both digital data and the contract to manage that data generating the same transaction identifier. The result is dynamic data paired with an immutable set of data. Deploying contracts is just one piece of the Warp SDK, to learn more keep reading this guide! Introduction Read Contract State",
          "estimatedWords": 778,
          "lastModified": "2025-06-27T16:26:04.295Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:04.295Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/warp/readstate.html",
          "title": "Warp (SmartWeave) SDK - ReadState",
          "content": "Contributors: Tom Wilson, Jack FrainLast Updated: Edit# Warp (SmartWeave) SDK - ReadState‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.SmartWeave Contract state is calculated via lazy evaluation, which means, the state evaluation occurs on reads not writes. When reading contracts, the SDK gathers all state interactions, sorts them, and executes them against the source contract using a reduce or fold pattern.# Basic Readstateconst warp = WarpFactory.forMainnet() const CONTRACT_ID = '_z0ch80z_daDUFqC9jHjfOL8nekJcok4ZRkE_UesYsk' const result = await warp.contract(CONTRACT_ID).readState() // log current state console.log(result.cachedValue.state) # Advanced ReadstateSome contracts either read the state of other contracts, or invoke or write to other contracts, when requesting the state of these contracts it is necessary to set evaluation options.const warp = WarpFactory.forMainnet() const CONTRACT_ID = 'FMRHYgSijiUNBrFy-XqyNNXenHsCV0ThR4lGAPO4chA' const result = await warp.contract(CONTRACT_ID) .setEvaluationOptions({ internalWrites: true, allowBigInt: true }) .readState() // log current state console.log(result.cachedValue.state) # Common Evaluation OptionsNameDescriptioninternalWritesEvaluates contracts that contain internal writes to other contractsallowBigIntEvaluates contracts that use the BigInt primitive you can find out more about bigInt MDN Docsopen in new windowunsafeClientThis value could be allow or skip or throw. You should avoid using unsafeClient in your contracts it can lead to underministic results.# Readstate from specific BlockHeight or SortkeyYou may want to look at a previous state, not the current state, by supplying a blockHeight you can read the state of a contract at a specific block heightconst { sortKey, cachedValue } = await contract.readState(1090111) # SummaryReading the current state of SmartWeave Contracts performs state evaluation by pulling all interactions and processing each interaction via a fold method. This approach is unique to the permaweb and requires a unique understanding of how your SmartWeave Contract code is executed. Deploying Contracts Write Contract Interactions",
          "estimatedWords": 280,
          "lastModified": "2025-06-27T16:26:04.362Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:04.362Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/warp/write-interactions.html",
          "title": "Warp WriteInteractions",
          "content": "Contributors: Tom Wilson, Jack FrainLast Updated: Edit# Warp WriteInteractions‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.To call a function on a SmartWeave contract, you can create a transaction known as a SmartWeave action. This action includes the function name and the necessary input parameters for the function on the SmartWeave contract. You can create a SmartWeave action using the contract.writeInteraction function.# Codeimport { WarpFactory } from 'warp-contracts' const warp = WarpFactory.forMainnet() const STAMP_PROTOCOL = 'FMRHYgSijiUNBrFy-XqyNNXenHsCV0ThR4lGAPO4chA' async function doStamp() { const result = await warp.contract(STAMP_PROTOCOL) .connect('use_wallet') .writeInteraction({ function: 'stamp', timestamp: Date.now(), transactionId: 'zQhANphTO0DOsaWXhExylUD5cBN3a6xWvfn5ZCpmCVY' }) console.log(result) } When calling writeInteraction, you need to pass your input parameters, these are the parameters the contract is expecting to receive.WARNINGSince SmartWeave contracts are evaluated in a lazy flow, you do not know if your interaction ran successfully until you evaluate the contract to the current state. Use Warp readState to access the contract and determine if the interaction was applied successfully.# Dry WriteDryWrite allows you to test and verify an interaction on the current state without actually executing it on the permaweb. This feature allows you to simulate the interaction locally and ensure that it will be successful before applying it.import { WarpFactory } from 'warp-contracts' const warp = WarpFactory.forMainnet() const STAMP_PROTOCOL = 'FMRHYgSijiUNBrFy-XqyNNXenHsCV0ThR4lGAPO4chA' async function doStamp() { const result = await warp.contract(STAMP_PROTOCOL) .connect('use_wallet') .dryWrite({ function: 'stamp', timestamp: Date.now(), transactionId: 'zQhANphTO0DOsaWXhExylUD5cBN3a6xWvfn5ZCpmCVY' }) console.log(result) } WARNINGOne thing to note when using dry writes, is that the entire state needs to be evaluated locally for contacts that use readState or internalWrites. This can result in a slow performing process.# Optimized for speedBy default, writeInteractions are submitted to the Warp Sequencer and bundled and posted to Arweave. You can post directly to Arweave by disabling bundling.const result = await contract.writeInteraction({ function: 'NAME_OF_YOUR_FUNCTION', ... }, { disableBundling: true }) # SummaryThe SmartWeave Protocol allows for the modification of dynamic data on an immutable, append-only storage system using writeInteractions. These interactions enable trustless and permissionless communication with SmartWeave contracts. The Warp SDK provides developers with a user-friendly API for interacting with the SmartWeave Protocol and its writeInteractions feature.For additional resources:Warp SDK https://github.com/warp-contracts/warpopen in new windowWarp Docs https://warp.ccopen in new window Read Contract State Evolve Contract",
          "estimatedWords": 368,
          "lastModified": "2025-06-27T16:26:04.873Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:04.873Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/smartweave/warp/evolve.html",
          "title": "Warp (SmartWeave) SDK - Evolve",
          "content": "Contributors: Tom Wilson, Jack FrainLast Updated: Edit# Warp (SmartWeave) SDK - Evolve‚ö†Ô∏è Deprecation NoticeThis document is deprecated and may contain outdated information.Evolve is a feature that allows developers to update the source code of a smart contract without deploying a new contract. To use this feature, you must first submit the new source code using the save function. Once the updated code has been confirmed on the Permaweb, you can use the evolve function to point the contract to the new source code ID. This allows you to update the contract's behavior without creating a new contract instance.# Why?Writing SmartWeave contracts can be difficult and sometimes requires updates or new features to be added over time. Evolve allows you to make changes to your contract without having to create a new contract instance from scratch. To use this feature, your contract state object must include an evolve property that is set to the new contract source transaction identifier. This enables you to modify and improve your existing contract without starting from scratch.{ ... \"evolve\": \"YOUR SOURCE CODE TX_ID\" } # Post your new source to the permawebBefore you can evolve your existing contract, you need to post the new source code to the permaweb, you can do this with the save function.import { WarpFactory } from 'warp-contracts' import fs from 'fs' const src = fs.readFileSync('./dist/contract.js', 'utf-8') const jwk = JSON.parse(fs.readFileSync('./wallet.json', 'utf-8')) const TX_ID = 'VFr3Bk-uM-motpNNkkFg4lNW1BMmSfzqsVO551Ho4hA' const warp = WarpFactory.forMainnet() async function main() { const newSrcTxId = await warp.contract(TX_ID).connect(jwk).save({src }) console.log('NEW SRC ID', newSrcTxId) } main() # Evolve your contractWARNINGVerify your new Source TX_ID is confirmed, go to Sonaropen in new window to make sure the TX_ID is confirmed.import { WarpFactory } from 'warp-contracts' import fs from 'fs' const src = fs.readFileSync('./dist/contract.js', 'utf-8') const jwk = JSON.parse(fs.readFileSync('./wallet.json', 'utf-8')) const TX_ID = 'VFr3Bk-uM-motpNNkkFg4lNW1BMmSfzqsVO551Ho4hA' const warp = WarpFactory.forMainnet() async function main() { const newSrcTxId = await warp.contract(TX_ID).connect(jwk).evolve('SRC TX ID') console.log(result) } main() TIPIt's worth noting that the evolve feature is only applicable to future actions, meaning you cannot use it to apply new source code to actions that occurred before the contract was evolved.# SummaryEvolve is a powerful feature and can provide extensibility for your contracts, it can also be an attack vector, so make sure you fully understand what you are doing when using it. Below is a common snippet of what an evolve function may look like in your contract. export async function handle(state, action) { ... if (action.input.function === 'evolve') { if (action.caller === state.creator) { state.evolve = action.input.value } return { state } } ... } Write Contract Interactions",
          "estimatedWords": 430,
          "lastModified": "2025-06-27T16:26:04.943Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:04.944Z"
        },
        {
          "url": "https://cookbook.arweave.net/getting-started/welcome.html",
          "title": "Developing on the Permaweb",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Developing on the Permaweb# Welcome to the PermawebCreating applications on the permaweb, which is built on the Arweave protocol, is similar to building traditional web applications but with some key differences.One major difference is that data is stored on the permaweb permanently, as the name suggests, rather than on a centralized server. This means that once data is uploaded to the permaweb, it cannot be deleted or altered. This can be beneficial for applications that require tamper-proof data storage, such as supply chain management or voting systems.Another difference is that the permaweb is decentralized, meaning there is no central point of control or failure. This can provide increased security and reliability for applications.Additionally, the permaweb uses a unique token, called AR, to pay for the storage of data on the network. This can add a new layer of complexity to application development, as developers need to consider how to integrate AR into their applications and handle payments.Overall, the experience of creating applications on the permaweb can be challenging, but it can also be rewarding as it offers unique benefits over traditional web development.# Hello WorldsHello World (No Code)Hello World (CLI) Hello World (No Code)",
          "estimatedWords": 199,
          "lastModified": "2025-06-27T16:26:05.437Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:26:05.438Z"
        },
        {
          "url": "https://cookbook.arweave.net/getting-started/quick-starts/hw-no-code.html",
          "title": "Hello World (No Code)",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Hello World (No Code)In this quick start we are going to upload an image to the permaweb with no code!# RequirementsComputerInternetModern web browser# Create a wallethttps://arweave.app/addopen in new window or https://arconnect.ioopen in new window# Send some data to arweaveGo to https://hello_cookbook.arweave.devopen in new windowEnter some data and click publish, connect your wallet and \"BAM\"# Congrats!!You just published some data on Arweave using zero code.To check out the project -> https://github.com/twilson63/pw-no-code-hello Welcome Hello World (CLI)",
          "estimatedWords": 79,
          "lastModified": "2025-06-27T16:26:05.553Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:05.553Z"
        },
        {
          "url": "https://cookbook.arweave.net/getting-started/quick-starts/hw-cli.html",
          "title": "Hello World (CLI)",
          "content": "Contributors: Tom Wilson, Luke Cassady-DorionLast Updated: Edit# Hello World (CLI)This guide walks you through the most simple way to get data on to the permaweb using a command-line interface (CLI).# RequirementsNodeJSopen in new window LTS or greater# DescriptionUsing a terminal/console window create a new folder called hw-permaweb-1.# Setupcd hw-permaweb-1 npm init -y npm install arweave ardrive-cli # Generate a walletnpx -y @permaweb/wallet > ~/.demo-arweave-wallet.json # Create a web pageecho \"<h1>Hello Permaweb</h1>\" > index.html # Upload using Ardrive CLI# Create a Drive FOLDER_ID=$(npx ardrive create-drive -n public -w ~/.demo-arweave-wallet.json --turbo | jq -r '.created[] | select(.type == \"folder\") | .entityId') # Upload file TX_ID=$(npx ardrive upload-file -l index.html --content-type text/html -w ~/.demo-arweave-wallet.json --turbo -F ${FOLDER_ID} | jq -r '.created[] | select(.type == \"file \") | .dataTxId') # open file from ar.io gateway open https://g8way.io/${TX_ID} Hello World (No Code) Contributing",
          "estimatedWords": 138,
          "lastModified": "2025-06-27T16:26:06.017Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:06.018Z"
        },
        {
          "url": "https://cookbook.arweave.net/getting-started/contributing.html",
          "title": "Contributing Workflow",
          "content": "Contributors: Tom WilsonLast Updated: Edit# Contributing WorkflowAnyone in the community is welcome to contribute to the Permaweb Cookbook, as community members we want a high quality reference guide of little snack bite sized nuggets of information. Below is a step by step workflow of how anyone can contribute to this project.# What do you need to know?Git and Github - publishes content to github.com.Markdown - Markdown is a text based markup language that can be transformed into HTMLArweave and the Permaweb - Have some knowledge about the Permaweb that should be shared# Steps to Contribute# Need Help?Join our discord channelopen in new window and post a note.# Commiting workWe are using conventional commitsopen in new window for this repository.General flow for making a contribution:Fork the repo on GitHubClone the project to your own machineCommit changes to your own branchPush your work back up to your forkSubmit a Pull request so that we can review your changesNOTE: Be sure to merge the latest from \"upstream\" before making a pull request!# StyleHere are some suggestions on tone and style from some contributors:TIPIn writing them, I'm getting a feeling for the tone that's appropriate for each. CoreConcepts should be rather textbook like, neutral voice, objective. \"This is how Arweave works\" For Guides, I think it's ok to have a more personal voice. Refer to the reader as \"you\" and speak in the collaborative voice \"next we'll take a look at...\" This may just be personal preference, but in general I feel this tone much more supportive and accessible when following a longer form guide. Indeed, its the voice that most popular tutorials from other ecosystems are written in. For Resources, I think it shares the same voice as core concepts, with a preference for brevity.dmacTIPConceptual and referencial data should have a more cold scientific tone and guides should be a supportive or even humorous tone. Longer form content needs to pull readers in without them zoning out.Arch_Druid# More information about contributing check out the repo style guideCONTRIBUTINGopen in new window Hello World (CLI)",
          "estimatedWords": 340,
          "lastModified": "2025-06-27T16:26:06.120Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:26:06.120Z"
        },
        {
          "url": "https://cookbook.arweave.net/getting-started/quick-starts/hw-nodejs.html",
          "title": "Hello World (NodeJS)",
          "content": "Contributors: Justin Shaw, Luke Cassady-Dorion, Tom Wilson, mogulx_operatesLast Updated: Edit# Hello World (NodeJS)This guide walks you through the most simple way to get data on to the permaweb using arweave-js and irys.With Arweave 2.6 only allowing 1000 items per block, directly posting to the gateway (eg. using arweave-js) will likely be uncommon.# RequirementsNodeJSopen in new window LTS or greater# DescriptionUsing a terminal/console window create a new folder called hw-nodejs.# Setupcd hw-nodejs npm init -y npm install arweave ardrive-cli # Generate a walletnpx -y @permaweb/wallet > ~/.demo-arweave-wallet.json # Upload using Ardrive TurboUploads of less than 100 KiB are currently free on Irys' Node 2.import Irys from \"@irys/sdk\"; import fs from \"fs\"; const jwk = JSON.parse(fs.readFileSync(\"wallet.json\").toString()); const url = \"https://node2.irys.xyz\"; const token = \"arweave\"; const irys = new Irys({ url, // URL of the node you want to connect to token, // Token used for payment and signing jwk, // Arweave wallet }); const dataToUpload = \"GM world.\"; try { const receipt = await irys.upload(dataToUpload); console.log(`Data uploaded ==> https://arweave.net/${receipt.id}`); } catch (e) { console.log(\"Error uploading data \", e); } # Upload using ArweaveJSIf you are running the latest version of nodejs this arweavejs script will work as is. For other versions you may need to use the --experimental-fetch flag.import Arweave from \"arweave\"; import fs from \"fs\"; // load the JWK wallet key file from disk const jwk = JSON.parse(fs.readFileSync('./wallet.json').toString()); // initialize arweave const arweave = Arweave.init({ host: \"arweave.net\", port: 443, protocol: \"https\", }); const tx = await arweave.createTransaction( { data: \"Hello world!\", }, jwk ); await arweave.transactions.sign(tx, jwk); arweave.transactions.post(tx).then(console.log).catch(console.log); console.log(`https://arweave.net/${tx.id}`); # ResourcesIrys SDKopen in new windowArweave JS SDKopen in new windowIrys Docs: Free Uploadsopen in new window",
          "estimatedWords": 275,
          "lastModified": "2025-06-27T16:26:06.610Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:06.610Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/posting-transactions/arweave-js.html",
          "title": "Posting Transactions using arweave-js",
          "content": "Contributors: Dan MacDonald, Ros Mc Mahon, dmac, Luke Cassady-Dorion, Pawan PaudelLast Updated: Edit# Posting Transactions using arweave-jsArweave native transactions can be posted directly to a node or gateway using the arweave-js package.Arweave scales though the use of transaction bundles. These bundles make it possible for each block to contain a nearly unlimited number of transactions. Without the use of bundles, Arweave blocks are limited 1000 transactions per block (with new blocks produced every ~2 minutes). If your use case exceeds this capacity you may experience dropped transactions. Under these circumstances please consider using irys.xyz or similar services to bundle your transactions.# Installing the arweave-js PackageTo install arweave-js runNPMYARNnpm install --save arweave yarn add arweave When working with NodeJS a minimum version of NodeJS 18 or higher is required.# Initializing arweave-jsDirect Layer 1 transactions are posted using the arweave-js library.import Arweave from 'arweave'; import fs from \"fs\"; // load the JWK wallet key file from disk let key = JSON.parse(fs.readFileSync(\"walletFile.txt\").toString()); // initialize an arweave instance const arweave = Arweave.init({}); # Posting a wallet-to-wallet TransactionA basic transaction to move AR tokens from one wallet address to another.// create a wallet-to-wallet transaction sending 10.5AR to the target address let transaction = await arweave.createTransaction({ target: '1seRanklLU_1VTGkEk7P0xAwMJfA7owA1JHW5KyZKlY', quantity: arweave.ar.arToWinston('10.5') }, key); // you must sign the transaction with your key before posting await arweave.transactions.sign(transaction, key); // post the transaction const response = await arweave.transactions.post(transaction); # Posting a Data TransactionThis example illustrates how load a file from disk and create a transaction to store its data on the network. You can find the current price the network is charging at https://ar-fees.arweave.devopen in new window// load the data from disk const imageData = fs.readFileSync(`iamges/myImage.png`); // create a data transaction let transaction = await arweave.createTransaction({ data: imageData }, key); // add a custom tag that tells the gateway how to serve this data to a browser transaction.addTag('Content-Type', 'image/png'); // you must sign the transaction with your key before posting await arweave.transactions.sign(transaction, key); // create an uploader that will seed your data to the network let uploader = await arweave.transactions.getUploader(transaction); // run the uploader until it completes the upload. while (!uploader.isComplete) { await uploader.uploadChunk(); } # ResourcesFor an overview of all the ways you can post transactions, see the Posting Transactions section of the cookbook.For a more detailed description of all arweave-js's features see the documentation on githubopen in new window dispatch",
          "estimatedWords": 393,
          "lastModified": "2025-06-27T16:26:06.691Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:06.692Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/posting-transactions/dispatch.html",
          "title": "Posting a Transaction using Dispatch",
          "content": "Contributors: Dan MacDonald, dmac, Pawan PaudelLast Updated: Edit# Posting a Transaction using DispatchArweave Browser wallets have the concept of dispatching transactions. If the transaction is under 100KB in size it can be posted for free!# Dispatching a TransactionThis can be done without any package dependencies for the client app. As long as the user has a browser wallet active and the data is less than 100KB, dispatched transactions are free and guaranteed to be confirmed on the network.// use arweave-js to create a transaction let tx = await arweave.createTransaction({ data:\"Hello World!\" }) // add some custom tags to the transaction tx.addTag('App-Name', 'PublicSquare') tx.addTag('Content-Type', 'text/plain') tx.addTag('Version', '1.0.1') tx.addTag('Type', 'post') // use the browser wallet to dispatch() the transaction let result = await window.arweaveWallet.dispatch(tx); // log out the transactino id console.log(result.id); # ResourcesFor an overview of all the ways you can post transactions, see the Posting Transactions section of the cookbook. arweave-js arseeding-js",
          "estimatedWords": 151,
          "lastModified": "2025-06-27T16:26:07.258Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:07.258Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/posting-transactions/arseeding-js.html",
          "title": "Posting Transactions using arseedingjs",
          "content": "Contributors: weibogaoLast Updated: Edit# Posting Transactions using arseeding.jsYou can use the arseeding-js JavaScript SDK package to publish transactions on the Arweave network. Arseeding automatically broadcasts the transaction to all Arweave nodes in the network, ensuring that the transaction is promptly received in the pending pool of all Arweave nodes, thus increasing the transaction's packaging speed.# Installing arseeding.jsTo install arseeding.js run:NPMYARNnpm install arseeding-js yarn add arseeding-js # Transaction for Uploading DataWhen using Arseeding, you must pre-fund your account on everpayopen in new window. This balance can be funded with $AR tokens or other cryptocurrencies. Another distinction is that the Arseeding service ensures that your data will make it onto the blockchain.const { genNodeAPI } = require('arseeding-js') const run = async () => { const instance = genNodeAPI('YOUR PRIVATE KEY') const arseedUrl = 'https://arseed.web3infra.dev' const data = Buffer.from('........') const payCurrencyTag = 'ethereum-usdc-0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' // everPay supported token tag (chainType-symbol-id) const options = { tags: [{ name: 'Content-Type', value: 'image/png' }] } const res = await instance.sendAndPay(arseedUrl, data, payCurrencyTag, options) console.log('res', res) } run() # ResourcesFor an overview of all methods for publishing transactions, please refer to the Publishing Transactions section in the operation manual.You can find the complete Arseeding documentation on the Arseeding websiteopen in new window.Follow the Arseeding Upload Manifest tutorial hereopen in new window. dispatch Turbo-SDK",
          "estimatedWords": 215,
          "lastModified": "2025-06-27T16:26:07.760Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:07.760Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/posting-transactions/turbo.html",
          "title": "Posting Transactions using Ardrive Turbo",
          "content": "Contributors: bobinstein, Justin ShawLast Updated: Edit# Posting Transactions using Ardrive TurboPosting transactions using Turbo can be accomplished using the @ardrive/turbo-sdk JavaScript package.# Installing the @ardrive/turbo-sdkTo install @ardrive/turbo-sdk runNPMYARNnpm install @ardrive/turbo-sdk yarn add @ardrive/turbo-sdk # Initializing Turbo ClientThere are multiple ways to upload data using the turbo sdk. You can:upload a fileupload a data-itemWhen uploading a data-item with the turbo sdk, you will use ar-bundles to create the data-item and add tags.# Data-Item (recommended)import fs from 'node:fs' import { TurboFactory } from '@ardrive/turbo-sdk/node'; import { ArweaveSigner, createData } from 'arbundles'; if (!process.env.PATH_TO_WALLET) { console.error(\"Please set PATH_TO_WALLET in your env.\") process.exit() } const JWK = JSON.parse(fs.readFileSync(process.env.PATH_TO_WALLET).toString()); const turbo = TurboFactory.authenticated({ privateKey: JWK, }); const signer = new ArweaveSigner(JWK); # Fileimport { TurboFactory } from '@ardrive/turbo-sdk/node'; import fs from 'fs'; if (!process.env.PATH_TO_WALLET) { console.error(\"Please set PATH_TO_WALLET in your env.\") process.exit() } const JWK = JSON.parse(fs.readFileSync(process.env.PATH_TO_WALLET).toString()); const turbo = TurboFactory.authenticated({ privateKey: JWK }); const filePath = new URL('path/to/file', import.meta.url).pathname; const fileSize = fs.statSync(filePath).size; const dataItemOpts = { //target: , // anchor: , tags: [{name: 'test', value: 'test'}] // add tags } const uploadResult = await turbo.uploadFile({ fileStreamFactory: () => fs.createReadStream(filePath), fileSizeFactory: () => fileSize, signal: AbortSignal.timeout(10_000), // Optional: cancel the upload after 10 seconds dataItemOpts // Optional }); console.log(JSON.stringify(uploadResult, null, 2)); Example Output:{ \"id\": \"1mPoz28tMAnYecZTya4g6cHSIQz37zAAwr_uC0IUcxU\", \"timestamp\": 1704990130970, \"winc\": \"0\", \"version\": \"0.2.0\", \"deadlineHeight\": 1341385, \"dataCaches\": [ \"arweave.net\" ], \"fastFinalityIndexes\": [ \"arweave.net\" ], \"public\": \"j0Ki2cJHca6HoC4B3y0ZxFKEe9c539AO5KlfDj76KpWOSx5xtbiDUndEWmJxE-p9ayAI8nF5sSJeRfNpuD4g831fmUbTFvUXKNKcfLJ4knDewyY7YNtVGcjBrNRDbsMPhC6UKiquyewRhBlu3YNyEvC9hV4otuwgGI1QcPQmqL9lztpSbwtV00qQIhYAyDbUCmPU6GMPjgk3o-YTDam0rny80tJnxQu5xvLAH3x-nnaAYVsc4-oDvpKKDzq-i5GzSZAFfiWXlYs80fts0Y-T2w3649IgHIjvPy72jYS6y02HKaL9guTczSQfa5ILhE0XotIFgjTkP0LEhHNVmrG7XA5XyKdgV3tyWi1qPrHs-Se5miuZsD0Mz_tBiVZ_AmqQbUYAmyYmEnuB_NpWJoBj18ItZfP1Bq7BvjriJJmpsOab95hEkQCEJHSHRAkH72aS_oz-bM6lymNtOj68NGzTZ0y0hq9b2FSKFhQbrxQpGSbQQ4p6tnoKF_B2n1xTE1xAU3R5Ju-2CZsGCW6kf2JBVTvyQrU5njVHeAS5niOkaJEzlEoaHvaSZF48AvMKB1nZCKG3xbHdQA8EGWNJ_7D-L5BbH2-7Y6CY-9KNS7HMIFTp39lqWzMJ4gyQzDzOh1vaG8bckm0CSqB9WXJxKNALgOpQmvGKDHZIODDSyZ1b8GE\", \"signature\": \"D58BO0hRPeqkQ_m9SFRiZze1CHZzxek-grsAs0xSsfzi6FNUQDDZyzadX4cd4aWxJaw4APti-lFHjh8_eUfwO2Qblo5wY-WDi3DU9LPasdzu4P0QFhsWk_hZwQslunAtH8NnPdbD8cnfeHKabvVcpXRDwndQX-7TJwjndAHDEFuN1fB-t445i8_z6GK4XYSgM253gFcL_KC0gD5UUcxLk5OGNPuDXPKIAVPsHGzzx4861t4BvB8EYo2YRpveu3LA6bRdXbG4q312JdUZMTBoZP1-QqwcHiFtQg2YLMZAM07YbyTMaTwMa6l3EhffpDuZ_llAWtQjlDw5egu4rnWxPZos17bSN-ReiH_NTBKjlHz54gBa-Q2YT58qXEj2XzfpIENdlhVxjmmWmIiMtrr58oOws9mB5yyIFHeXUbk1U4EZc7mbNDEEmDjTpHnAIVM83aGDOux7H2UpDV9UMBPYS1CX_huW4ACXJ6XqLH5E6Kc6_WXWUwEsoGKarK0A1WiDpKhGkA41KgKHLZ5CbACJ0bWoaa4YBLQgFjowZXwDsn3s6t78aAqpx_meVI67Eg4P7ELDish8CY9NcMHMXeEBHsctNHtCdJXQLRWf6CyYkmf2T7ym1DP4R58FkpBpkVXEUadFyshJe0nfB9ie17f_njuPpKWN3d2OODZVarxtRsI\", \"owner\": \"GtDQcrr2QRdoZ-lKto_S_SpzEwiZiHVaj3x4jAgRh4o\" } # Posting a Data-Item (recommended)const signer = new ArweaveSigner(JWK); const signedDataItem = createData(JSON.stringify({ \"some\": \"data\" }), signer, { tags: [{ name: 'test', value: 'test' }] // add tags }); await signedDataItem.sign(signer); const uploadResult = await turbo.uploadSignedDataItem({ dataItemStreamFactory: () => signedDataItem.getRaw(), dataItemSizeFactory: () => signedDataItem.getRaw().length, signal: AbortSignal.timeout(10_000), // Optional: cancel the upload after 10 seconds }); console.log(JSON.stringify(uploadResult, null, 2)); Example Output:{ \"id\": \"agcPXVfw92w_JI5v8o6C_Gsixd_BDMaHqNSStX4Eed8\", \"timestamp\": 1704990453564, \"winc\": \"0\", \"version\": \"0.2.0\", \"deadlineHeight\": 1341387, \"dataCaches\": [ \"arweave.net\" ], \"fastFinalityIndexes\": [ \"arweave.net\" ], \"public\": \"j0Ki2cJHca6HoC4B3y0ZxFKEe9c539AO5KlfDj76KpWOSx5xtbiDUndEWmJxE-p9ayAI8nF5sSJeRfNpuD4g831fmUbTFvUXKNKcfLJ4knDewyY7YNtVGcjBrNRDbsMPhC6UKiquyewRhBlu3YNyEvC9hV4otuwgGI1QcPQmqL9lztpSbwtV00qQIhYAyDbUCmPU6GMPjgk3o-YTDam0rny80tJnxQu5xvLAH3x-nnaAYVsc4-oDvpKKDzq-i5GzSZAFfiWXlYs80fts0Y-T2w3649IgHIjvPy72jYS6y02HKaL9guTczSQfa5ILhE0XotIFgjTkP0LEhHNVmrG7XA5XyKdgV3tyWi1qPrHs-Se5miuZsD0Mz_tBiVZ_AmqQbUYAmyYmEnuB_NpWJoBj18ItZfP1Bq7BvjriJJmpsOab95hEkQCEJHSHRAkH72aS_oz-bM6lymNtOj68NGzTZ0y0hq9b2FSKFhQbrxQpGSbQQ4p6tnoKF_B2n1xTE1xAU3R5Ju-2CZsGCW6kf2JBVTvyQrU5njVHeAS5niOkaJEzlEoaHvaSZF48AvMKB1nZCKG3xbHdQA8EGWNJ_7D-L5BbH2-7Y6CY-9KNS7HMIFTp39lqWzMJ4gyQzDzOh1vaG8bckm0CSqB9WXJxKNALgOpQmvGKDHZIODDSyZ1b8GE\", \"signature\": \"QNgpeIZrgJ3mu3NB9iZeyXGeKJaZ_Efp-QQd7_gbAp2Z1WhqWnQHtf_uKjLOf7sfNZLyo1igMwXv0LMmILr0QRsx1bVQ1WSAHnJb11F7YEoyfiD7veSEJ-0284NIO7Ixy_AQqf5X41kmL5025Oy1NY6jy7ftQ-hBSs3jyQ0_Af1-6SZ8VAnsIQW-G2vXIralVyTkYm49USKYL8vok4Twh1ICCDj-NMqBSBtDA5lL4pmZ06OXi7jZ1dR3QDBKtD6YdomdM5ccmfyNDb95c7A-uqwVp87R5kZnMIVfQ7JhZdCrTly2dwhW6yIA6tyHSRHmP_n2esALj2_R2uYxJnU-uCE2934YFFQX-jxOchUB3vWBIYzL-v-iY0eWRQZqg5lCYMhZ8jnwrBun_e1N_9-ODsD1nnHs0fEqqrTqnEoKQRJTbIN8qmBJbPlulRmPI_x0O-601UuUQ-6BmghzXZLaQvklMwMrzEI0A3FShM7ZY0zfXj8PUB-4BSUSHXQlyT697DGYTAOuClUXs39SFp2mPP7voeMOKFUr8r0xi52pJcesAhKQOmIqMVjywqwS9089t5-JPKbA6JZKLygMZdxJ3evq7Dq9Y6K6scM2TXT6Tr7w2cP1_jNc0fomo6WjUt3y1KY1WYphmgVG_6_oMZigAK1itwtLAOQ_43PMefla7OE\", \"owner\": \"GtDQcrr2QRdoZ-lKto_S_SpzEwiZiHVaj3x4jAgRh4o\" } # Posting a Fileconst filePath = new URL('path/to/file', import.meta.url).pathname; const fileSize = fs.statSync(filePath).size; const dataItemOpts = { //target: 'string', // anchor: 'string', tags: [{name: 'test', value: 'test'}] // add tags } const uploadResult = await turbo.uploadFile({ fileStreamFactory: () => fs.createReadStream(filePath), fileSizeFactory: () => fileSize, signal: AbortSignal.timeout(10_000), // Optional: cancel the upload after 10 seconds dataItemOpts // Optional }); console.log(JSON.stringify(uploadResult, null, 2)); Example Output:{ \"id\": \"68h8-kGbKGJMQD8nOCsRl_0mJKpxQSpmL42OJq5nCxQ\", \"timestamp\": 1704990009421, \"winc\": \"0\", \"version\": \"0.2.0\", \"deadlineHeight\": 1341384, \"dataCaches\": [ \"arweave.net\" ], \"fastFinalityIndexes\": [ \"arweave.net\" ], \"public\": \"j0Ki2cJHca6HoC4B3y0ZxFKEe9c539AO5KlfDj76KpWOSx5xtbiDUndEWmJxE-p9ayAI8nF5sSJeRfNpuD4g831fmUbTFvUXKNKcfLJ4knDewyY7YNtVGcjBrNRDbsMPhC6UKiquyewRhBlu3YNyEvC9hV4otuwgGI1QcPQmqL9lztpSbwtV00qQIhYAyDbUCmPU6GMPjgk3o-YTDam0rny80tJnxQu5xvLAH3x-nnaAYVsc4-oDvpKKDzq-i5GzSZAFfiWXlYs80fts0Y-T2w3649IgHIjvPy72jYS6y02HKaL9guTczSQfa5ILhE0XotIFgjTkP0LEhHNVmrG7XA5XyKdgV3tyWi1qPrHs-Se5miuZsD0Mz_tBiVZ_AmqQbUYAmyYmEnuB_NpWJoBj18ItZfP1Bq7BvjriJJmpsOab95hEkQCEJHSHRAkH72aS_oz-bM6lymNtOj68NGzTZ0y0hq9b2FSKFhQbrxQpGSbQQ4p6tnoKF_B2n1xTE1xAU3R5Ju-2CZsGCW6kf2JBVTvyQrU5njVHeAS5niOkaJEzlEoaHvaSZF48AvMKB1nZCKG3xbHdQA8EGWNJ_7D-L5BbH2-7Y6CY-9KNS7HMIFTp39lqWzMJ4gyQzDzOh1vaG8bckm0CSqB9WXJxKNALgOpQmvGKDHZIODDSyZ1b8GE\", \"signature\": \"fSuRHFXbuWAuIIEAquGD5hwOLU8uy0sVAu3mCwyitRlxI2wDgB8F_8mrF4dsv8-Jab3jb8vjVB0LrRWlStCGTnL3JStr0C8d-UdTHyQk3EfWPmikrZuE1cHdBjTyys9Y-8lmGR0bY5fT8GA_xj48coQhNNKSU4MYvo9m0stAY7Vy5dnzp0xOvyvZuWzlLzQqwsI-1nNMCh9LvVUenGO-yOArUNNeCGL2y55qnNcFpCs8TDla3plRiddND5CkR3vkLWpMAa_irBYXB2m3ekIqGmBTBbww0YjAR9AUt9PXKibysrbADvDEa5siWEPEa48dVwLes5PtSw9s6e8X6ief8Y3cUX5QPqnPTv5Bb4T51HutMuSb2Dj78_G4tBjrkfZKUNu3U9uOBWp8fZ-N4E1buvkuM9-yAtsfRfrUfxmwdNZ9KFGuog-ffJ0lor6sdq_CjUTUo4RkwvQcOI5nZi2_AGEsfoDTusqio2pbps7E8zgU4op2vQSxZXGoYaMPrKxA6HIptPP3rZVbXJMLfSccesjylkGozdQZaWtXdhbQKRmCYouSUWMuxngCRaHVA-W1ImU-4fyX3aRi4XNZBT3b63D_QwU-cI7zlUWnEkX6E79MFlWJoVXNm94fP92wGZUsesogsiifqMBIelkHW9Otr76XFr140AsTpyZj3wqPDEc\", \"owner\": \"GtDQcrr2QRdoZ-lKto_S_SpzEwiZiHVaj3x4jAgRh4o\" } # ResourcesDive into the Codeopen in new windowJoin the discussion in the ArDrive Discordopen in new window arseeding-js",
          "estimatedWords": 425,
          "lastModified": "2025-06-27T16:26:07.846Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:07.846Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/http-api.html",
          "title": "Fetching Transaction Data",
          "content": "Contributors: PBillingsby, Dan MacDonaldLast Updated: Edit# Fetching Transaction DataWhile indexing services allow querying of transaction metadata they don't provide access to the transaction data itself. This is because caching transaction data and indexing metadata have different resource requirements. Indexing services primarily rely on compute resources to perform queries on a database while transaction data is better suited to deployment on a Content Delivery Network (CDN) to optimize storage and bandwidth.A Transaction data caching service is offered by most gateways though a set of HTTP endpoints. Any HTTP client/package can be used to request transaction data from these endpoints. For example Axios or Fetch for JavaScript, Guzzle for PHP, etc.If you wanted to bypass a transaction data caching service and get data directly from the Arweave peers/nodes you could, but it's a lot of work!Transaction data is stored on Arweave as a contiguous sequence of 256KB chunks, from the very beginning of the network until the current block. This format is optimized to support the SPoRA mining mechanism miners participate in to prove they are storing Arweave data.Retrieve a list of peers from a well known peer.Ask the peer for the chunk offsets which contain your transactions data.Ask the peer to for the chunks. If the peer provides the chunks, combine them back into their original format.(If the peer does not have the chunks) walk the peer list asking for the chunks.For each peer you visit, check their peer list and add peers not already in your list.Repeat from step 3 until you have all of the chunks.This is a fairly large amount of work to perform each time you want to retrieve data from the Arweave network. Imagine if you were trying to display a timeline of tweets like https://public-square.g8way.ioopen in new window does. The user experience would be terrible with long load times and spinners. Because data on Arweave is permanent, it's safe to cache in its original form to make retrieval of transaction data much quicker and easier.The following is how to access cached transaction data in the arweave.net Transaction data caching service.# Get cached TX datahttps://arweave.net/TX_IDconst res = await axios.get(`https://arweave.net/sHqUBKFeS42-CMCvNqPR31yEP63qSJG3ImshfwzJJF8`) console.log(res) Click to view example result{ \"data\": { \"ticker\": \"ANT-PENDING\", \"name\": \"pending\", \"owner\": \"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"controller\": \"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"evolve\": null, \"records\": { \"@\": \"As-g0fqvO_ALZpSI8yKfCZaFtnmuwWasY83BQ520Duw\" }, \"balances\": { \"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\": 1 } }, \"status\": 200, \"statusText\": \"\", \"headers\": { \"cache-control\": \"public,must-revalidate,max-age=2592000\", \"content-length\": \"291\", \"content-type\": \"application/json; charset=utf-8\" }, \"config\": { \"transitional\": { \"silentJSONParsing\": true, \"forcedJSONParsing\": true, \"clarifyTimeoutError\": false }, \"adapter\": [ \"xhr\", \"http\" ], \"transformRequest\": [ null ], \"transformResponse\": [ null ], \"timeout\": 0, \"xsrfCookieName\": \"XSRF-TOKEN\", \"xsrfHeaderName\": \"X-XSRF-TOKEN\", \"maxContentLength\": -1, \"maxBodyLength\": -1, \"env\": {}, \"headers\": { \"Accept\": \"application/json, text/plain, */*\" }, \"method\": \"get\", \"url\": \"https://arweave.net/sHqUBKFeS42-CMCvNqPR31yEP63qSJG3ImshfwzJJF8\" }, \"request\": {} } Each Arweave peer/node also exposes some HTTP endpoints which are often replicated gateways. You can read more about Arweave peer's HTTP endpoints here.# Get raw transactionhttps://arweave.net/raw/TX_IDconst result = await fetch('https://arweave.net/raw/rLyni34aYMmliemI8OjqtkE_JHHbFMb24YTQHGe9geo') .then(res => res.json()) console.log(JSON.stringify(result)) Click to view example result{ \"manifest\": \"arweave/paths\", \"version\": \"0.1.0\", \"index\": { \"path\": \"index.html\" }, \"paths\": { \"index.html\": { \"id\": \"FOPrEoqqk184Bnk9KrnQ0MTZFOM1oXb0JZjJqhluv78\" } } } # Get by fieldhttps://arweave.net/tx/TX_ID/FIELDAvailable fields: id | last_tx | owner | target | quantity | data | reward | signatureconst result = await fetch('https://arweave.net/sHqUBKFeS42-CMCvNqPR31yEP63qSJG3ImshfwzJJF8/data') .then(res => res.json()) console.log(JSON.stringify(result)) Click to view example result{ \"ticker\":\"ANT-PENDING\", \"name\":\"pending\", \"owner\":\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"controller\":\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\", \"evolve\":null, \"records\": { \"@\":\"As-g0fqvO_ALZpSI8yKfCZaFtnmuwWasY83BQ520Duw\" }, \"balances\":{\"NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0\":1} } # Get Wallet BalanceThe returned balance is in Winston. To get balance in $AR, divide the balance by 1000000000000 https://arweave.net/wallet/ADDRESS/balanceconst res = await axios.get(`https://arweave.net/wallet/NlNd_PcajvxAkOweo7rZHJKiIJ7vW1WXt9vb6CzGmC0/balance`) console.log(res) console.log(res.data / 1000000000000) 6638463438702 // Winston 6.638463438702 // $AR # Get transaction statushttps://arweave.net/tx/TX_ID/statusTIPThis endpoint only supports native Arweave transactions. Transactions must be confirmed before getting a successful response. const result = await fetch('https://arweave.net/tx/EiRSQExb5HvSynpn0S7_dDnwcws1AJMxoYx4x7nWoho/status').then(res => res.json()) console.log(JSON.stringify(result)) Click to view example result{ \"block_height\":1095552,\"block_indep_hash\":\"hyhLEyOw5WcIhZxq-tlnxhnEFgKChKHFrMoUdgIg2Sw0WoBMbdx6uSJKjxnQWon3\",\"number_of_confirmations\":10669 } # Get network informationconst res = await axios.get('https://arweave.net/info') console.log(res.data) Click to view example result{ \"network\": \"arweave.N.1\", \"version\": 5, \"release\": 53, \"height\": 1106211, \"current\": \"bqPU_7t-TdRIxgsja0ftgEMNnlGL6OX621LPJJzYP12w-uB_PN4F7qRYD-DpIuRu\", \"blocks\": 1092577, \"peers\": 13922, \"queue_length\": 0, \"node_state_latency\": 0 } Querying",
          "estimatedWords": 650,
          "lastModified": "2025-06-27T16:26:08.346Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:26:08.347Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/index.html",
          "title": "Guides",
          "content": "Contributors: Tom Wilson, Dan MacDonald, Luke Cassady-Dorion, PBillingsby, Jack Frain, Jeffrey Ling, Ros McMahon, Weronika KLast Updated: Edit# GuidesSnack-sized guides for the building blocks of the PermawebArProfileDNS IntegrationServer SideSpheronDeploying Appsarkbgithub-actionDeploying PathManifestsarweave.appardriveDeploying PSTsGraphQLArDBar-gqlSearch ServiceTestingDo you think a permaweb guide is missing? Create a issue at Githubopen in new window or consider contributing Core Concepts References",
          "estimatedWords": 54,
          "lastModified": "2025-06-27T16:26:08.412Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:26:08.412Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/arprofile.html",
          "title": "ArProfile",
          "content": "Contributors: PBillingsby, bidetaggleLast Updated: Edit# ArProfileArProfileopen in new window is an Arweave native DID which relies on the open data protocol Accountopen in new window.arweave-accountopen in new window is a npm package that allows you to easily integrate ArProfile in your codebase, wether it is a web app or a backend (nodejs).See complete documentation hereopen in new window# PurposeThe underlying account protocol aims to satisfy essential needs for social interactions between users: an avatar, a unique handle, a name and a bio. It also includes the possibility to add accounts from the well known social networks such as Twitter, Discord, Github, Instagram and Facebook.# Quick integrationA permadapp profile viewer is available at the tx 5OHoPfYucLPTgOvJGgnL0Cg0Ktl-ZDaiTjQo_2B3tBgopen in new windowYou can embed any ArProfile with a <iframe> html tag.For simplicity and to update automatically to the lattest txid, we recommend using the ArNSopen in new window name profile.# Embeddable URLshttps://profile.arweave.dev/address/<wallet_address>https://profile.arweave.dev/handler/<name#unique># Example<iframe src=\"https://profile.arweave.net/address/vh-NTHVvlKZqRxc8LyyTNok65yQ55a_PJ1zWLb9G2JI\" width=\"300\" height=\"420\" frameBorder=\"0\"> </iframe> Result: # Integration in your codebasearweave-accountopen in new window is a npm package that allows you to easily integrate ArProfile in your codebase, wether it is a web app or a backend (nodejs).# InstallationAdd the package using npm:NPMYARNnpm install arweave-account yarn add arweave-account # Using ArProfileimport Account from 'arweave-account' const account = new Account(opts); Optional argument options can be passed into the constructor. Here is the default options:const opts = { cacheIsActivated: true, cacheSize: 100, cacheTime: 60 }; TIPCaching will store the relevant profile information in your local storage so that future requests for such data can be fulfilled much faster. The duration that is stored is specified in the options passed in# Get Profile by AddressTo retrieve account information using an Arweave address, inside an async function pass the user address to the get functionawait account.get(\"aIUmY9Iy4qoW3HOikTy6aJww-mM4Y-CUJ7mXoPdzdog\") { \"txid\": \"NPJJoq-9EwUeAce_bSbSyqICaGs4_7Hg6VxCyoCY8UQ\", \"addr\": \"aIUmY9Iy4qoW3HOikTy6aJww-mM4Y-CUJ7mXoPdzdog\", \"handle\": \"@cromatikap#aIUdog\", \"profile\": { \"handleName\": \"cromatikap\", \"avatar\": \"xqjVvn9b8hmtDJhfVw80OZzAsn-ErpWbaFCPZWG5vKI\", \"avatarURL\": \"https://arweave.net/xqjVvn9b8hmtDJhfVw80OZzAsn-ErpWbaFCPZWG5vKI\", \"banner\": \"ar://a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"bannerURL\": \"https://arweave.net/a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"name\": \"Axel\", \"bio\": \"Founder of Metaweave.xyz\\nI love dogs\", \"email\": \"\", \"links\": { \"twitter\": \"cromatikap\", \"github\": \"cromatikap\", \"instagram\": \"cromatikap\", \"discord\": \"cromatikap#6039\" }, \"wallets\": {} } } # Get Profile by HandleAn Arweave address can be linked to multiple ArProfile's. To retrieve account information using an existing ArProfile handle, inside an async function pass the user handle to the search functionawait account.search(\"cromatikap\") [ { \"txid\": \"H0qHXb2mC3Y1zRZcSczZ-fp4UytCxSJDhO7j9DP2wQE\", \"addr\": \"Y4P1UzeAgQNU169vhYo3Cdx4-gevKvaBWCfkoG-ajU8\", \"handle\": \"@cromatikap#Y4PjU8\", \"profile\": { \"handleName\": \"cromatikap\", \"avatar\": \"ar://xpuHFNujK8K6_1SHRn4KPLxkHZKfIryEjXIDYkKwRtE\", \"avatarURL\": \"https://arweave.net/xpuHFNujK8K6_1SHRn4KPLxkHZKfIryEjXIDYkKwRtE\", \"banner\": \"ar://a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"bannerURL\": \"https://arweave.net/a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"name\": \"cromatikap on the go\", \"bio\": \"mobile account\", \"email\": \"\", \"links\": {}, \"wallets\": {} } }, {...}, // more profiles {...} ] # Get Profile by Unique HandleTo retrieve account information using an Arweave address, inside an async function pass the user handle and unique handle to the search functionawait account.search(\"cromatikap#aIUdog\") { \"txid\": \"_DGURgOAih5p2vTyaEu9_bBDpZv81rctPO2q9cpOFS0\", \"addr\": \"HDCwh7xJcIK23vx1blxysTnUpqy1PEzAb5Am84ZdERA\", \"handle\": \"@cromatikap#HDCERA\", \"profile\": { \"handleName\": \"cromatikap\", \"avatar\": \"ar://OrG-ZG2WN3wdcwvpjz1ihPe4MI24QBJUpsJGIdL85wA\", \"avatarURL\": \"https://arweave.net/OrG-ZG2WN3wdcwvpjz1ihPe4MI24QBJUpsJGIdL85wA\", \"banner\": \"ar://a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"bannerURL\": \"https://arweave.net/a0ieiziq2JkYhWamlrUCHxrGYnHWUAMcONxRmfkWt-k\", \"name\": \"Axel\", \"bio\": \"test account by cromatikap\\nUPDATE\", \"email\": \"\", \"links\": { \"github\": \"cromatikap\", \"twitter\": \"cromatikap\" }, \"wallets\": {} } } # SummaryWith just 3 lines of code needed to implement, ArProfile is a straight-forward way for adding additional Arweave user information such as avatars, bio's and social links to your applications.",
          "estimatedWords": 511,
          "lastModified": "2025-06-27T16:26:08.990Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 2,
          "crawledAt": "2025-06-27T16:26:08.990Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/dns-integration/server-side.html",
          "title": "ServerSide DNS Integration",
          "content": "Contributors: Tom WilsonLast Updated: Edit# ServerSide DNS IntegrationSo you have a permaweb application and it is on the permaweb, but you also have a specific domain that you want users to use to access this app. mydomain.com, to connect your domain to a permaweb app, you have several options, this option we will show here is a called a server-side redirect. The redirect occurs as a reverse proxy so that the user remains on mydomain.com in their browser, while behind the scenes the application is being served from the permaweb.TIPYou can use any reverse proxy to setup a server-side redirect, in this guide we will be using deno and deno.com a lightweight edge hosting service.# What you will need to setup a reverse proxy using deno.comA deno.com account, which at the time of this writting is free.A domain with access to the DNS SettingsA permaweb application identifier and is deployed on the permaweb# Create proxy on Deno.comDeno Deploy is a distributed system that runs at the edge. 35 regions worldwide. Open your browser to https://deno.comopen in new window and click sign in or sign up if you do not have an account.Click on New Project and Click PlayThe deno playground will allow us to create a proxy without having to leave the browser.Copy the following code:import { serve } from \"https://deno.land/std/http/mod.ts\"; const APP_ID = \"YOUR AREWEAVE IDENTIFIER\" const fileService = `https://arweave.net/${APP_ID}`; // handle requests async function reqHandler(req: Request) { const path = new URL(req.url).pathname; // proxy to arweave.net return await fetch(fileService + path).then(res => { const headers = new Headers(res.headers) // instruct server to leverage the edge cache headers.set('cache-control', 's-max-age=600, stale-while-revalidate=6000') // return response from arweave.net return new Response(res.body, { status: res.status, headers }) }); } // listen for requests serve(reqHandler, { port: 8100 }); This proxy server will receive requests from mydomain.com and proxy the request to arweave.net/APP_ID and then return the response as mydomain.com. Your APP_ID is the TX_ID identifier for you permaweb application.Click Save and Deploy# Connecting to DNSIn Project Settings go to the domains section and click to add a domain.Enter mydomain.com domain and follow the instructions to modify your DNS settings to point to the deno deploy edge network.It may take a few minutes to resolve to the dns, but once resolved your app will now be rendering from mydomain.com.üéâ Congrats you have published a server-side redirect to your permaweb application.WARNINGNote that any changes to your application will generate a new TX_ID and you will need to modify that TX_ID to publish the new changes to your domain.# Automating the DeployIf you would like to automate new deploys of your permaweb app, look into github actions and using the deno deploy github action: https://github.com/denoland/deployctl/blob/main/action/README.mdopen in new window# SummaryServer Side redirects are great for providing your users a Domain Name System URL to access your permaweb application. We hope you found this guide useful in your permaweb development journey! Spheron",
          "estimatedWords": 484,
          "lastModified": "2025-06-27T16:26:09.472Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:09.472Z"
        },
        {
          "url": "https://cookbook.arweave.net/guides/dns-integration/spheron.html",
          "title": "Spheron",
          "content": "Contributors: PBillingsbyLast Updated: Edit# SpheronThe Spheron Protocol is a decentralized platform designed to streamline the creation of modern dapps. It offers a seamless experience for developers, allowing for quick deployment, automatic scaling, and personalized content delivery on decentralized networks.Spheron uses a GitHub integration to handle continuous deployments and gives us the ability to integrate custom DNS to any given deployment.# What you will need to set up a Spheron accountA GitHub accountA permaweb application identifier and is deployed on the permawebTIPTo deploy Arweave applications using Spheron, you will need the Pro Plan which is $20/month# Authentication/Log inSpheron relies on GitHub, GitLab or BitBucket repo's for their deployments, similar to Vercel.To log in to Spheron, head to the Spheron Aqua dashboardopen in new window and select your preferred authentication.# Import repoOnce logged in, you will be presented with the user dashboard. Click the \"New Project\" button in the top right of the dashboard to import a repo. Select the repo you want and choose the option to deploy to Arweave.# Connecting to DNSNow that you've imported your project and deployed, go to the \"Domains\" tab. Enter the domain name, environment and select a domain to point the deployment to.Before continuing, you will be asked to verify your configured records. Update the record in your domain manager. Updating a DNS can take up to 72 hours. You will see something similar to the image below:Once updated, you will need to verify in Spheron. Click the Verify button and you should be all set and ready to go. Now whenever you deploy a new version to GitHub, your domain will be updated with the newest version!üéâTIPTo create a fully decentralized application, be sure to use ArNSopen in new window or any decentralized DNS server# SummarySpheron is a straight-forward way for deploying Permaweb applications to Arweave, and redirecting them to custom domains. Combining continuous integration and continuous deployment, ensuring a smooth developer experience all round! Server Side",
          "estimatedWords": 323,
          "lastModified": "2025-06-27T16:26:09.560Z",
          "siteKey": "arweave",
          "siteName": "Arweave Cookbook",
          "depth": 3,
          "crawledAt": "2025-06-27T16:26:09.560Z"
        }
      ],
      "lastCrawled": "2025-06-27T16:26:09.561Z",
      "stats": {
        "totalPages": 80,
        "averageWords": 367,
        "duration": 26592,
        "requestCount": 91,
        "averageResponseTime": 283.3736263736264,
        "pagesPerSecond": 3.0084235860409145
      }
    }
  }
}