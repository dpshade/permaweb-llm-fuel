# Permaweb Documentation Collection

Generated on: 2025-09-05T12:15:30.459Z
Total documents: 89
Total words: 36735

## Table of Contents

### Included Documents

1. [Processes](https://cookbook_ao.arweave.net/concepts/processes.html)
2. [HyperBEAM from AO Connect](https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/ao-connect.html)
3. [Editor setup](https://cookbook_ao.arweave.net/guides/aos/editor.html)
4. [Editor setup](https://cookbook_ao.arweave.net/references/editor-setup.html)
5. [Legacynet HyperBEAM](https://cookbook_ao.arweave.net/welcome/legacynet-info/index.html)
6. [Creating a Pingpong Process in aos](https://cookbook_ao.arweave.net/guides/aos/pingpong.html)
7. [Reading Dynamic State](https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/reading-dynamic-state.html)
8. [AO Processes](https://cookbook_ao.arweave.net/welcome/ao-processes.html)
9. [Connecting to specific ao nodes](https://cookbook_ao.arweave.net/guides/aoconnect/connecting.html)
10. [Understanding the Inbox](https://cookbook_ao.arweave.net/guides/aos/inbox-and-handlers.html)
11. [Automated Responses](https://cookbook_ao.arweave.net/tutorials/bots-and-games/attacking.html)
12. [ao](https://cookbook_ao.arweave.net/guides/aos/modules/ao.html)
13. [Fetching Game State](https://cookbook_ao.arweave.net/tutorials/bots-and-games/game-state.html)
14. [DataItem Signers](https://cookbook_ao.arweave.net/guides/aoconnect/signers.html)
15. [Handlers (Version 005)](https://cookbook_ao.arweave.net/references/handlers.html)
16. [Messages](https://cookbook_ao.arweave.net/concepts/messages.html)
17. [BetterIDEa](https://cookbook_ao.arweave.net/references/betteridea/index.html)
18. [Connecting to HyperBEAM with aos](https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/aos-with-hyperbeam.html)
19. [Customizing the Prompt in aos](https://cookbook_ao.arweave.net/guides/aos/prompt.html)
20. [Messaging in ao](https://cookbook_ao.arweave.net/tutorials/begin/messaging.html)
21. [Crafting a Token](https://cookbook_ao.arweave.net/tutorials/begin/token.html)
22. [Building a Token in ao](https://cookbook_ao.arweave.net/guides/aos/token.html)
23. [Troubleshooting using aolink](https://cookbook_ao.arweave.net/guides/aos/troubleshooting.html)
24. [Preparations](https://cookbook_ao.arweave.net/tutorials/begin/preparations.html)
25. [Exposing Process State to HyperBEAM](https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/exposing-process-state.html)
26. [How ao messaging works](https://cookbook_ao.arweave.net/concepts/how-it-works.html)
27. [Get started in 5 minutes](https://cookbook_ao.arweave.net/welcome/getting-started.html)
28. [Sending a Message to a Process](https://cookbook_ao.arweave.net/guides/aoconnect/sending-messages.html)
29. [aoconnect](https://cookbook_ao.arweave.net/guides/aoconnect/aoconnect.html)
30. [JSON](https://cookbook_ao.arweave.net/guides/aos/modules/json.html)
31. [Getting started with SQLite](https://cookbook_ao.arweave.net/guides/snacks/sqlite.html)
32. [AO Dev-Cli 01](https://cookbook_ao.arweave.net/guides/dev-cli/index.html)
33. [Meet Web Assembly](https://cookbook_ao.arweave.net/references/wasm.html)
34. [Building a Chatroom in aos](https://cookbook_ao.arweave.net/tutorials/begin/chatroom.html)
35. [A whistle stop tour of Lua](https://cookbook_ao.arweave.net/concepts/lua.html)
36. [Pretty](https://cookbook_ao.arweave.net/guides/aos/modules/pretty.html)
37. [aos Brief Tour](https://cookbook_ao.arweave.net/concepts/tour.html)
38. [FAQ](https://cookbook_ao.arweave.net/guides/aos/faq.html)
39. [Reading results from an ao Process](https://cookbook_ao.arweave.net/guides/aoconnect/reading-results.html)
40. [Bots and Games](https://cookbook_ao.arweave.net/tutorials/bots-and-games/index.html)
41. [Eval](https://cookbook_ao.arweave.net/concepts/eval.html)
42. [Introduction](https://cookbook_ao.arweave.net/guides/aos/intro.html)
43. [Lets Play A Game](https://cookbook_ao.arweave.net/tutorials/bots-and-games/ao-effect.html)
44. [Chatroom Blueprint](https://cookbook_ao.arweave.net/guides/aos/blueprints/chatroom.html)
45. [Using WeaveDrive](https://cookbook_ao.arweave.net/guides/snacks/weavedrive.html)
46. [Tokengating the Chatroom](https://cookbook_ao.arweave.net/tutorials/begin/tokengating.html)
47. [Units](https://cookbook_ao.arweave.net/concepts/units.html)
48. [Calling DryRun](https://cookbook_ao.arweave.net/guides/aoconnect/calling-dryrun.html)
49. [Token Blueprint](https://cookbook_ao.arweave.net/guides/aos/blueprints/token.html)
50. [Tutorials](https://cookbook_ao.arweave.net/tutorials/index.html)
51. [Community Resources](https://cookbook_ao.arweave.net/references/community.html)
52. [Installing ao connect](https://cookbook_ao.arweave.net/guides/aoconnect/installing-connect.html)
53. [Lua Optimization Guide for AO Platform](https://cookbook_ao.arweave.net/references/lua-optimization.html)
54. [Meet Lua](https://cookbook_ao.arweave.net/references/lua.html)
55. [aos AO Operating System](https://cookbook_ao.arweave.net/guides/aos/index.html)
56. [ao Module](https://cookbook_ao.arweave.net/references/ao.html)
57. [Messaging Patterns in ao](https://cookbook_ao.arweave.net/references/messaging.html)
58. [Introduction to AO-Core](https://cookbook_ao.arweave.net/welcome/ao-core-introduction.html)
59. [ao Specs](https://cookbook_ao.arweave.net/concepts/specs.html)
60. [Voting Blueprint](https://cookbook_ao.arweave.net/guides/aos/blueprints/voting.html)
61. [ao Token and Subledger Specification](https://cookbook_ao.arweave.net/references/token.html)
62. [Spawning a Process](https://cookbook_ao.arweave.net/guides/aoconnect/spawning-processes.html)
63. [LLMs Documentation](https://cookbook_ao.arweave.net/llms-explanation.html)
64. [Mechanics of the Arena](https://cookbook_ao.arweave.net/tutorials/bots-and-games/arena-mechanics.html)
65. [References](https://cookbook_ao.arweave.net/references/index.html)
66. [Begin An Interactive Tutorial](https://cookbook_ao.arweave.net/tutorials/begin/index.html)
67. [Accessing Data from Arweave with ao](https://cookbook_ao.arweave.net/references/data.html)
68. [Expanding the Arena](https://cookbook_ao.arweave.net/tutorials/bots-and-games/build-game.html)
69. [Utils](https://cookbook_ao.arweave.net/guides/aos/modules/utils.html)
70. [Base64](https://cookbook_ao.arweave.net/guides/aos/modules/base64.html)
71. [Bringing it Together](https://cookbook_ao.arweave.net/tutorials/bots-and-games/bringing-together.html)
72. [Staking Blueprint](https://cookbook_ao.arweave.net/guides/aos/blueprints/staking.html)
73. [Interpreting Announcements](https://cookbook_ao.arweave.net/tutorials/bots-and-games/announcements.html)
74. [Strategic Decisions](https://cookbook_ao.arweave.net/tutorials/bots-and-games/decisions.html)
75. [Blueprints](https://cookbook_ao.arweave.net/guides/aos/blueprints/index.html)
76. [Load Lua Files with load filename](https://cookbook_ao.arweave.net/guides/aos/load.html)
77. [CRED Utils Blueprint](https://cookbook_ao.arweave.net/guides/aos/blueprints/cred-utils.html)
78. [Installing aos](https://cookbook_ao.arweave.net/guides/aos/installing.html)
79. [Monitoring Cron](https://cookbook_ao.arweave.net/guides/aoconnect/monitoring-cron.html)
80. [Guides](https://cookbook_ao.arweave.net/guides/index.html)
81. [Welcome to ao](https://cookbook_ao.arweave.net/welcome/index.html)
82. [Concepts](https://cookbook_ao.arweave.net/concepts/index.html)
83. [Cron Messages](https://cookbook_ao.arweave.net/references/cron.html)
84. [CLI](https://cookbook_ao.arweave.net/guides/aos/cli.html)
85. [Modules](https://cookbook_ao.arweave.net/guides/aos/modules/index.html)
86. [Why Migrate to HyperBEAM](https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/why-migrate.html)
87. [crypto](https://cookbook_ao.arweave.net/guides/aos/modules/crypto.html)
88. [Release Notes](https://cookbook_ao.arweave.net/releasenotes/index.html)
89. [Sending an Assignment to a Process](https://cookbook_ao.arweave.net/guides/aoconnect/assign-data.html)

---

# 1. Processes  Cookbook

Document Number: 1
Source: https://cookbook_ao.arweave.net/concepts/processes.html
Words: 316
Quality Score: 0.544
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Processes Processes possess the capability to engage in communication via message passing, both receiving and dispatching messages within the network. Additionally, they hold the potential to instantiate further processes, enhancing the network's computational fabric. This dynamic method of data dissemination and interaction within the network is referred to as a 'holographic state', underpinning the shared and persistent state of the network. When building a Process with aos you have the ability to add handlers, these handlers can be added by calling the Handlers.add function, passing a "name", a "match" function, and a "handle" function. The core module contains a helper library that gets injected into the handler function, this library is called ao.The main functions to look at in this ao helper is ao.send(Message) - sends a message to a process ao.spawn(Module, Message) - creates a new process Ethereum Signed Process or Module For an ao Process or Module, if the ANS-104 DataItem was signed using Ethereum keys, then the value in the env.Process.Owner or env.Module.Owner field, respectively, will be the EIP-55 Ethereum address of the signer. For example: 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359 ao.send Example ao.spawn Example ao.env NOTE: ao.env is important context data that you may need as a developer creating processes.The ao.env property contains the Process and Module Reference Objects Both the Process and the Module contain the attributes of the ao Data-Protocol.Summary Processes in the network communicate through message passing and can create new processes, contributing to a 'holographic state' of shared and persistent data. Developers can build a Process using aos by adding handlers through the Handlers.add function with specific name, match, and handle functions. The ao helper library within the core module aids in this process, providing functions like ao.send to dispatch messages and ao.spawn to create new modules, as well as the important ao.env property which contains essential Process and Module information. The ao Data-Protocol outlines the structure and attributes of these elements.

---

# 2. HyperBEAM from AO Connect  Cookbook

Document Number: 2
Source: https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/ao-connect.html
Words: 211
Quality Score: 0.543
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

HyperBEAM from AO Connect This guide explains how to interact with a process using HyperBEAM and aoconnect.Prerequisites Node.js environment @permaweb/aoconnect library The latest version of aos Wallet file (wallet.json) containing your cryptographic keys A HyperBEAM node running with the genesis_wasm profile The Process ID for a process created with genesis_wasm (this is the default in the latest version of aos).Step 1: Environment Setup Install necessary dependencies:Ensure your wallet file (wallet.json) is correctly formatted and placed in your project directory.INFO You can create a test wallet using this command: npx -y @permaweb/wallet > wallet.json Step 2: Establish Connection Create a new JavaScript file (e.g., index.js) and set up your Permaweb connection. You will need a processId of a process that you want to interact with.Step 3: Pushing a Message to a Process Use the request function to send a message to the process. In aoconnect, this is done by using the push path parameter.Full Example To run the full script, combine the snippets from Step 2 and 3 into index.js:Now, run it:bashnode index.js You should see an object logged to the console, containing the ID of the message that was sent.Conclusion Following these steps, you've successfully sent a message to a process. This is a fundamental interaction for building applications on hyperAOS.

---

# 3. Editor setup  Cookbook

Document Number: 3
Source: https://cookbook_ao.arweave.net/guides/aos/editor.html
Words: 218
Quality Score: 0.543
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Editor setup Remembering all the built in ao functions and utilities can sometimes be hard. To enhance your developer experience, it is recommended to install the Lua Language Server extension into your favorite text editor and add the ao addon. It supports all built in aos modules and globals.VS Code Install the sumneko.lua extension:Search for "Lua" by sumneko in the extension marketplace Download and install the extension Open the VS Code command palette with Shift + Command + P (Mac) / Ctrl + Shift + P (Windows/Linux) and run the following command:In the Addon Manager, search for "ao", it should be the first result. Click "Enable" and enjoy autocomplete!Other editors Verify that your editor supports the language server protocol Install Lua Language Server by following the instructions at luals.github.io Install the "ao" addon to the language server BetterIDEa BetterIDEa is a custom web based IDE for developing on ao.It offers a built in Lua language server with ao definitions, so you don't need to install anything. Just open the IDE and start coding!Features include:Code completion Cell based notebook ui for rapid development Easy process management Markdown and Latex cell support Share projects with anyone through ao processes Tight integration with ao package manager Read detailed information about the various features and integrations of the IDE in the documentation.

---

# 4. Editor setup  Cookbook

Document Number: 4
Source: https://cookbook_ao.arweave.net/references/editor-setup.html
Words: 218
Quality Score: 0.543
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Editor setup Remembering all the built in ao functions and utilities can sometimes be hard. To enhance your developer experience, it is recommended to install the Lua Language Server extension into your favorite text editor and add the ao addon. It supports all built in aos modules and globals.VS Code Install the sumneko.lua extension:Search for "Lua" by sumneko in the extension marketplace Download and install the extension Open the VS Code command palette with Shift + Command + P (Mac) / Ctrl + Shift + P (Windows/Linux) and run the following command:In the Addon Manager, search for "ao", it should be the first result. Click "Enable" and enjoy autocomplete!Other editors Verify that your editor supports the language server protocol Install Lua Language Server by following the instructions at luals.github.io Install the "ao" addon to the language server BetterIDEa BetterIDEa is a custom web based IDE for developing on ao.It offers a built in Lua language server with ao definitions, so you don't need to install anything. Just open the IDE and start coding!Features include:Code completion Cell based notebook ui for rapid development Easy process management Markdown and Latex cell support Share projects with anyone through ao processes Tight integration with ao package manager Read detailed information about the various features and integrations of the IDE in the documentation.

---

# 5. Legacynet  HyperBEAM  Cookbook

Document Number: 5
Source: https://cookbook_ao.arweave.net/welcome/legacynet-info/index.html
Words: 383
Quality Score: 0.537
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Legacynet → HyperBEAM As the AO ecosystem evolves, we are transitioning from Legacynet to HyperBEAM Mainnet, marking a significant upgrade in the implementation of the AO-Core protocol.Legacynet: The Initial Implementation Legacynet was the first implementation of the AO-Core protocol, written in JavaScript. Launched on February 27, 2024, it provided a fee-free environment for early adopters to experiment with AO's hyper-parallel architecture. However, being a JavaScript implementation, Legacynet had inherent limitations in terms of scalability and native support for the actor-oriented model that AO is based on.HyperBEAM: The Future of AO-Core HyperBEAM is the new, advanced implementation of the AO-Core protocol, written in Erlang—the language that inspired AO's actor-oriented design. This implementation innately benefits from Erlang's strengths in:Actor-Oriented Design: Erlang's native support for the actor model aligns perfectly with AO's architecture, where processes (actors) operate independently and communicate via message passing.Scalability: Erlang is renowned for its ability to handle massive concurrency, allowing HyperBEAM to scale efficiently with the growing demands of the AO computer.Reliability: Erlang's design for fault tolerance ensures that HyperBEAM can maintain system stability even under high load or during failures of individual components.The Transition to HyperBEAM While HyperBEAM represents the future of AO, the transition from Legacynet is being handled carefully to ensure a smooth experience for developers. Currently, most development activity remains on Legacynet, which provides a stable environment for building and testing.The goal is to provide a seamless future upgrade path to HyperBEAM Mainnet. While Legacynet will eventually be deprecated, for now, it is the primary environment for new developers to begin building on AO.HyperBEAM Documentation For detailed documentation on the HyperBEAM protocol itself, including running infrastructure and leveraging its powerful URL pathing, visit HyperBEAM.arweave.net.Building on HyperBEAM To learn how to build applications on HyperBEAM using ao and aos, and to migrate existing processes, see the Migrating to HyperBEAM Guide.Preparing for the Future While you build on Legacynet, you can prepare for the future of AO by:Reviewing the HyperBEAM documentation to understand the new environment and its architecture.Exploring the enhanced capabilities that HyperBEAM offers due to its Erlang foundation.Building with the knowledge that a seamless migration path to HyperBEAM Mainnet is a core priority.This transition is a significant step forward for the AO ecosystem, ensuring that we can deliver on the promise of decentralized, hyper-parallel computation at any scale.

---

# 6. Creating a Pingpong Process in aos  Cookbook

Document Number: 6
Source: https://cookbook_ao.arweave.net/guides/aos/pingpong.html
Words: 358
Quality Score: 0.536
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Creating a Pingpong Process in aos This tutorial will guide you through creating a simple "ping-pong" process in aos. In this process, whenever it receives a message with the data "ping", it will automatically reply with "pong". This is a basic example of message handling and interaction between processes in aos.Step 1: Open the aos CLI Start by opening your command-line interface and typing aos to enter the aos environment.Step 2: Access the Editor Type .editor in the aos CLI to open the inline text editor. This is where you'll write your ping-pong handler code.Step 3: Write the Pingpong Handler In the editor, enter the following Lua code to add a handler for the pingpong pattern:This lua script does three things:It adds a new handler named "pingpong".It uses Handlers.utils.hasMatchingData("ping") to check if incoming messages contain the data "ping".If the message contains "ping", Handlers.utils.reply("pong") automatically sends back a message with the data "pong".Step 4: Exit the Editor After writing your code, type .done and press Enter to exit the editor and run the script.Step 5: Test the Pingpong Process To test the process, send a message with the data "ping" to the process. You can do this by typing the following command in the aos CLI:The process should respond with a message containing "pong" in the Inbox.Step 6: Monitor the Inbox Check your Inbox to see the "ping" message and your Outbox to confirm the "pong" reply.luaInbox[#Inbox].Data Step 7: Experiment and Observe Experiment by sending different messages and observe how only the "ping" messages trigger the "pong" response.Step 8: Save Your Process (Optional) If you want to use this process in the future, save the handler code in a Lua file for easy loading into aos sessions.INFO ADDITIONAL TIP:Handler Efficiency: The simplicity of the handler function is key. Ensure that it's efficient and only triggers under the correct conditions.Conclusion Congratulations! You have now created a basic ping-pong process in aos. This tutorial provides a foundation for understanding message handling and process interaction within the aos environment. As you become more comfortable with these concepts, you can expand to more complex processes and interactions, exploring the full potential of aos.

---

# 7. Reading Dynamic State  Cookbook

Document Number: 7
Source: https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/reading-dynamic-state.html
Words: 429
Quality Score: 0.525
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Reading Dynamic State Beyond reading static, cached state from your process, HyperBEAM allows you to perform on-the-fly computations on that state using Lua. This guide explains how to create and use "transformation functions" to return dynamic, computed data without altering the underlying state of your process.This is a powerful pattern for creating efficient data APIs for your applications, reducing client-side logic, and minimizing data transfer.This guide assumes you are already familiar with exposing static process state.How it Works: The Lua Device The magic behind this is the lua@5.3a device, which can execute a Lua script against a message. In this pattern, we use a HyperBEAM URL (hashpath) to construct a pipeline:First, we grab the latest state of an AO process.Then, we pipe that state as the base message into the lua@5.3a device.We tell the Lua device which script to load (from an Arweave transaction) and which function to execute.The function runs, processing the base state.Finally, the result of the function is returned over HTTP.Example: Calculating Circulating Supply Let's consider a practical example: a token process where we have patched the Balances table to be readable. Rather than forcing clients to download all balance data to compute the total supply, we can do it on the HyperBEAM node.1. The Transformation Function First, create a Lua script (sum.lua) with a function that takes the state (base) and calculates the sum of balances.The transformation function receives two arguments:base: The message being processed, which in our pipeline will be the cached state data from your process.req: The incoming request object, which contains parameters and other metadata.2. Publishing the Function Next, publish your Lua script to Arweave. The arx CLI tool is recommended for this.arx will return a transaction ID for your script. Let's say it's LUA_SCRIPT_TX_ID.3. Calling the Function With the process ID (YOUR_PROCESS_ID) and the script transaction ID (LUA_SCRIPT_TX_ID), you can construct a URL to call your function:HyperBEAMGET /~process@1.0/now/~lua@5.3a&module={LUA_SCRIPT_TX_ID}/sum/serialize~json@1.0 This URL breaks down as follows:/{YOUR_PROCESS_ID}~process@1.0: Targets the AO process and its state./now: Gets the most current state./~lua@5.3a&module={LUA_SCRIPT_TX_ID}: This is the key part. It tells HyperBEAM to take the output of the previous step (the process state) and process it with the lua@5.3a device, loading your script from the module transaction./sum: Calls the sum function within your Lua script./serialize~json@1.0: Takes the table returned by your function and serializes it into a JSON object.4. Integrating into an Application Here's how you could fetch this dynamic data in a JavaScript application:This approach significantly improves performance by offloading computation from the client to the HyperBEAM node and reducing the amount of data sent over the network.

---

# 8. AO Processes  Cookbook

Document Number: 8
Source: https://cookbook_ao.arweave.net/welcome/ao-processes.html
Words: 442
Quality Score: 0.520
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

AO Processes AO Processes are persistent, programmable smart contracts that live inside the AO computer. Embodying the actor model from Erlang that inspired AO, these processes operate as independent computational units that have their own state and communicate with each other through message passing. This architecture makes them ideal for creating autonomous agents and complex decentralized applications.What are AO Processes?Following the actor model, each AO Process functions as an independent actor within the system, executing code—typically written in Lua—in response to messages it receives. Three core characteristics define them:Stateful: Each process has its own private state and memory, which persist across interactions.Persistent: All processes and their entire message history are permanently stored on Arweave.Generative: Processes can dynamically spawn new processes, enabling complex and evolving systems.AO Processes and the Actor Model The actor model provides several key benefits for process-based development, enabling naturally concurrent and resilient systems. By treating every process as an isolated "actor," it simplifies development and enhances fault tolerance. Key advantages include:Concurrency & Isolation: Processes execute independently and are isolated from each other, enabling parallelism and preventing cascading failures.Message-Passing: All communication happens exclusively through asynchronous messages, simplifying interactions.Location Transparency & Fault Tolerance: Processes can interact without knowing each other's physical location on the network, and the system can continue operating even if individual processes fail.AOS: The Operating System for AO Processes AOS (AO Operating System) is an abstraction layer designed to simplify interaction with AO Processes. It provides developers with a powerful shell interface for sending commands, tools for managing process state, and a set of libraries for common functionalities, all contributing to a more streamlined development experience.Use Cases for AO Processes The persistent and concurrent nature of AO Processes makes them ideal for a wide range of decentralized applications. Here are a few examples:Autonomous Agents & Bots: Imagine a price-monitoring bot that tracks token prices across different decentralized exchanges (DEXs) and executes arbitrage trades automatically. AO makes it possible to build entire marketplaces for such agents, like Marketverse.Decentralized Finance (DeFi): You could build automated market makers (AMMs) or lending protocols where account balances and token reserves are tracked persistently within the process's state. A live example of this is Dexi, a decentralized exchange built on AO.On-Chain Games & Social Platforms: AO Processes can power fully on-chain games where the game state (like er positions or inventory) is managed by one or more processes, like the space strategy game Stargrid. They're also perfect for decentralized chat applications or social networks where user profiles, posts, and interactions are censorship-resistant.Now that you understand the capabilities of AO Processes, the next step is to dive into Hyperbeam, the high-performance network that powers them.

---

# 9. Connecting to specific ao nodes  Cookbook

Document Number: 9
Source: https://cookbook_ao.arweave.net/guides/aoconnect/connecting.html
Words: 176
Quality Score: 0.518
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Connecting to specific ao nodes When including ao connect in your code you have the ability to connect to a specific MU and CU, as well as being able to specify an Arweave gateway. This can be done by importing the "connect" function and extracting the functions from a call to the "connect" function.You may want to do this if you want to know which MU is being called when you send your message so that later you can debug from the specified MU. You also may want to read a result from a specific CU. You may in fact just prefer a particular MU and CU for a different reason. You can specify the gateway in order to use something other than the default, which is arweave.net.Importing without a call to connect Connecting to a specific MU, CU, and gateway All three of these parameters to connect are optional and it is valid to specify only 1 or 2 of them, or none. You could pass in just the MU_URL, for example.

---

# 10. Understanding the Inbox  Cookbook

Document Number: 10
Source: https://cookbook_ao.arweave.net/guides/aos/inbox-and-handlers.html
Words: 211
Quality Score: 0.518
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Understanding the Inbox In aos, processes are executed in response to messages via handlers. Unhandled messages are routed to the process's Inbox.What are Handlers?A handler is a function that receives and evaluates messages within your process. It acts upon messages by taking them as parameters.Handlers are defined using the Handlers.add() function.The function takes three parameters:Name of the Handler Matcher function Handle function What about Inboxes?An inbox is a storage area for messages that have not yet been processed. Think of it as a holding zone for incoming, or "inbound," items awaiting handling. Once a message is processed, it's no longer considered "inbound" and thus leaves the inbox.Example: Consider the inbox like your voicemail. Just as an unanswered phone call is directed to voicemail for you to address later, messages that your Process doesn't immediately handle are sent to the inbox. This way, unhandled messages are stored until you're ready to process them.Summary Initially, it might seem like all messages are meant to land in your Inbox, which can be puzzling if they disappear after being handled. The analogy of a voicemail should clarify this: much like calls you answer don't go to voicemail, messages you handle won't appear in your Inbox. This illustrates the roles of both the Inbox and Handlers.

---

# 11. Automated Responses  Cookbook

Document Number: 11
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/attacking.html
Words: 438
Quality Score: 0.516
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Automated Responses Following our last guide, our creation has progressed from a simple bot to a sophisticated autonomous agent. Now, let's further enhance its capabilities by adding a counterattack feature, allowing it to instantly retaliate against an opponent's attack, potentially catching them off-guard before they can retreat to safety.Writing the code Add the following handler to your bot.lua file and you're set:Whenever your er is under attack you receive a message with the Action Hit. This setup ensures your agent can make a swift counter attack, given it has sufficient energy.You can refer to the latest code for bot.lua in the dropdown below:Updated bot.lua file luaLatestGameState = LatestGameState or nil
function inRange(x1, y1, x2, y2, range)
return math.abs(x1 - x2) <= range and math.abs(y1 - y2) <= range
end
function decideNextAction()
local er = LatestGameState.ers[ao.id]
local targetInRange = false
for target, state in pairs(LatestGameState.ers) do
if target ~= ao.id and inRange(er.x, er.y, state.x, state.y, 1) then
targetInRange = true
break
end
end
if er.energy > 5 and targetInRange then
print("er in range. Attacking.")
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(er.energy)})
else
print("No er in range or insufficient energy. Moving randomly.")
local directionMap = {"Up", "Down", "Left", "Right", "UpRight", "UpLeft", "DownRight", "DownLeft"}
local randomIndex = math.random(#directionMap)
ao.send({Target = Game, Action = "erMove", er = ao.id, Direction = directionMap[randomIndex]})
end
end
Handlers.add(
"HandleAnnouncements",
{ Action = "Announcement" },
function (msg)
ao.send({Target = Game, Action = "GetGameState"})
print(msg.Event .. ": " .. msg.Data)
end
)
Handlers.add(
"UpdateGameState",
{ Action = "GameState" },
function (msg)
local json = require("json")
LatestGameState = json.decode(msg.Data)
ao.send({Target = ao.id, Action = "UpdatedGameState"})
end
)
Handlers.add(
"decideNextAction",
{ Action = "UpdatedGameState" },
function ()
if LatestGameState.GameMode ~= "ing" then
return
end
print("Deciding next action.")
decideNextAction()
end
)
Handlers.add(
"ReturnAttack",
{ Action = "Hit" },
function (msg)
local erEnergy = LatestGameState.ers[ao.id].energy
if erEnergy == undefined then
print("Unable to read energy.")
ao.send({Target = Game, Action = "Attack-Failed", Reason = "Unable to read energy."})
elseif erEnergy == 0 then
print("er has insufficient energy.")
ao.send({Target = Game, Action = "Attack-Failed", Reason = "er has no energy."})
else
print("Returning attack.")
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(erEnergy)})
end
InAction = false
ao.send({Target = ao.id, Action = "Tick"})
end
) To activate and test the counter attack feature, load the bot file in your aos er terminal:lua.load bot.lua Watch your terminal for the autonomous agent's reactions, now with the added ability to retaliate instantly. This feature showcases the agent's evolving strategic depth and autonomy. In the upcoming section, we'll consolidate all the knowledge we've gathered so far and add some features for optimization.

---

# 12. ao  Cookbook

Document Number: 12
Source: https://cookbook_ao.arweave.net/guides/aos/modules/ao.html
Words: 94
Quality Score: 0.516
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content ao Built-in global library for process communication and management. The ao object provides core functionality for sending messages, spawning processes, and logging.Core Functions ao.send(msg) Sends a message to another process. See the ao.send reference for more information.ao.spawn(module: string, spawn: table) Creates a new process from a module. See the ao.spawn reference for more information.ao.log(string|table) Logs messages or data that can be read by process callers.Environment The ao.env variable contains process initialization info like ID, owner, and tags.For the complete API reference including all properties and functions, see the ao reference documentation.

---

# 13. Fetching Game State  Cookbook

Document Number: 13
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/game-state.html
Words: 438
Quality Score: 0.515
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Fetching Game State Now that you're seeing game announcements directly in your terminal, you have a better grasp of the game's dynamics. However, these insights are limited to specific actions occurring within the game.Wouldn't it be more useful to have on-demand access to comprehensive game data, like the positions, health, and energy of all ers? This information could significantly improve your strategic planning, helping you assess threats, opportunities, and timing more effectively.If you thought of adding another handler to the bot created in the previous guide, you're absolutely right!Writing the Code Go back to your bot.lua file and update your existing handler as follows:Adjustments to your handler include:Renaming to "HandleAnnouncements" to reflect its broader role.Addition of an extra operation to request the game for the updated state. The game is designed to respond to the GetGameState action tag.When you get a print of the announcement, you can check the latest message in your Inbox as follows:luaInbox[#Inbox] The Data field of this message contains the latest state of the game which includes:GameMode: Whether the game is in Waiting or ing state.TimeRemaining: The time remaining for the game to start or end.ers: A table containing every er's stats like position, health and energy.But this can be taken a step further so that you can not just read but also use information from the latest state for other automations.Let's define a new variable that stores the latest state as follows:The syntax preserves existing values of the variable when you load successive iterations of the bot.lua file in your terminal, instead of overwriting it. If there is no pre-existing value then a nil value is assigned to the variable.Then implement another handler as follows:The response from the game process from the previous handler has an action tag with the value GameState that helps us trigger this second handler. Once triggered, the handle function loads the in-built json package that parses the data into json and stores it in the LatestGameState variable.This handler additionally sends a message to your process indicating when the state has been updated. The significance of this feature will be explained in the following section.You can refer to the latest code for bot.lua in the dropdown below:Updated bot.lua file As usual, to test this new feature, load the file in your aos er terminal as follows:lua.load bot.lua Then check the LatestStateVariable to see if it has updated correctly by simply passing its name as follows:luaLatestGameState With real-time access to the latest state of the game you bot is equipped to make informed decisions decide your next action. Next let's try automating actions with the help of this data 🚶

---

# 14. DataItem Signers  Cookbook

Document Number: 14
Source: https://cookbook_ao.arweave.net/guides/aoconnect/signers.html
Words: 279
Quality Score: 0.514
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

DataItem Signers Every message sent to AO MUST be signed, aoconnect provides a helper function for signing messages or spawning new processes. This helper function createDataItemSigner is provided for arweave wallets. But you can create your own Signer instance too.What is a Wallet/Keyfile?A wallet/keyfile is a public/private key pair that can be used to sign and encrypt data.What is an ao message/dataItem?You often see the terms message and dataItem used interchangeably in the documentation, a message is a data-protocol type in ao that uses the dataItem specification to describe the messages intent. A dataItem is defined in the ANS-104 bundle specification. A dataItem is the preferred format of storage for arweave bundles. A bundle is a collection of these signed dataItems. A message implements specific tags using the dataItem specification. When developers send messages to ao, they are publishing dataItems on arweave.🎓 To click here and to -104 dataItems click here What is a signer?A signer is function that takes data, tags, anchor, target and returns an object of id, binary representing a signed dataItem. AO accepts arweave signers and ethereum signers. createDataItemSigner is a helper function that can take an arweave keyfile or a browser instance of an arweave wallet usually located in the global scope of the browser, when I user connects to a wallet using an extension or html app.Examples arweave keyfile NOTE: if you do not have a wallet keyfile you can create one using npx -y @permaweb/wallet > wallet.json arweave browser extension NOTE: This implementation works with ArweaveWalletKit, ArConnect, and Arweave.app ethereum key Summary Using the signer function developers can control how dataItems are signed without having to share the signing process with aoconnect.

---

# 15. Handlers (Version 005)  Cookbook

Document Number: 15
Source: https://cookbook_ao.arweave.net/references/handlers.html
Words: 942
Quality Score: 0.513
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Handlers (Version 0.0.5) Overview The Handlers library provides a flexible way to manage and execute a series of process functions based on pattern matching. An AO process responds based on receiving Messages, these messages are defined using the Arweave DataItem specification which consists of Tags, and Data. Using the Handlers library, you can define a pipeline of process evaluation based on the attributes of the AO Message. Each Handler is instantiated with a name, a pattern matching function, and a function to execute on the incoming message. This library is suitable for scenarios where different actions need to be taken based on varying input criteria.Concepts Handler Arguments Overview When adding a handler using Handlers.add(), you provide three main arguments:name (string): The identifier for your handler pattern (table or function): Defines how to match incoming messages handler (function or resolver table): Defines what to do with matched messages Pattern Matching Tables Pattern Matching Tables provide a declarative way to match incoming messages based on their attributes. This is used as the second argument in Handlers.add() to specify which messages your handler should process.Basic Pattern Matching Rules Simple Tag Matching Wildcard Matching Pattern Matching Function-based Matching Common Pattern Examples Balance Action Handler Numeric Quantity Handler Default Action Handlers (AOS 2.0+) AOS 2.0 introduces simplified syntax for Action-based handlers. Instead of writing explicit pattern functions, you can use these shorthand forms:Resolvers Resolvers are special tables that can be used as the third argument in Handlers.add() to enable conditional execution of functions based on additional pattern matching. Each key in a resolver table is a pattern matching table, and its corresponding value is a function that executes when that pattern matches.This structure allows developers to create switch/case-like statements where different functions are triggered based on which pattern matches the incoming message. Resolvers are particularly useful when you need to handle a group of related messages differently based on additional criteria.Module Structure Handlers.version: String representing the version of the Handlers library.Handlers.list: Table storing the list of registered handlers.Common Handler Function Parameters Parameter Type Description name string The identifier of the handler item in the handlers list.pattern table or function Specifies how to match messages. As a table, defines required message tags with string values (e.g. { Action = "Balance", Recipient = "" } requires an "Action" tag with string value "Balance" and any string "Recipient" tag value). As a function, takes a message DataItem and returns: "true" (invoke handler and exit pipeline), "false" (skip handler), or "continue" (invoke handler and continue pipeline).handler (Resolver) table or function Either a resolver table containing pattern-function pairs for conditional execution, or a single function that processes the message. When using a resolver table, each key is a pattern matching table and its value is the function to execute when that pattern matches. When using a function, it takes the message DataItem as an argument and executes business logic.maxRuns (optional) number As of 0.0.5, each handler function takes an optional function to define the amount of times the handler should match before it is removed. The default is infinity.Functions Handlers.add(name, pattern, handler) Adds a new handler or updates an existing handler by name Handlers.append(name, pattern, handler) Appends a new handler to the end of the handlers list.Handlers.once(name, pattern, handler) Only runs once when the pattern is matched. Equivalent to setting maxRuns = 1. This is the underlying implementation used by the Receive function in the messaging system.Handlers.prepend(name, pattern, handler) Prepends a new handler to the beginning of the handlers list.Handlers.before(handleName) Returns an object that allows adding a new handler before a specified handler.Handlers.after(handleName) Returns an object that allows adding a new handler after a specified handler.Handlers.remove(name) Removes a handler from the handlers list by name.Handler Execution Notes Execution Order Handlers are executed in the order they appear in Handlers.list.When a message arrives, each handler's pattern function is called sequentially to determine if it should process the message.Pattern Function Return Values Pattern functions determine the message handling flow based on their return values:Skip Handler (No Match) Return: 0, false, or any string except "continue" or "break" Effect: Skips current handler and proceeds to the next one in the list Handle and Continue Return: 1 or "continue" Effect: Processes the message and continues checking subsequent handlers Use Case: Ideal for handlers that should always execute (e.g., logging) Handle and Return: -1, true, or "break" Effect: Processes the message and s checking further handlers Use Case: Most common scenario where a handler exclusively handles its matched message Practical Examples Logging Handler: Place at the start of the list and return "continue" to log all messages while allowing other handlers to process them.Specific Message Handler: Return "break" to handle matched messages exclusively and prevent further processing by other handlers.Handlers.utils The Handlers.utils module provides two functions that are common matching patterns and one function that is a common handle function.hasMatchingData(data: string) hasMatchingTag(name: string, value: string) reply(text: string) Handlers.utils.hasMatchingData(data: string) This helper function returns a pattern matching function that takes a message as input. The returned function checks if the message's Data field contains the specified string. You can use this helper directly as the pattern argument when adding a new handler.Handlers.utils.hasMatchingTag(name: string, value: string) This helper function returns a pattern matching function that takes a message as input. The returned function checks if the message has a tag with the specified name and value. If they match exactly, the pattern returns true and the handler function will be invoked. This helper can be used directly as the pattern argument when adding a new handler.Handlers.utils.reply(text: string) This helper is a simple handle function, it basically places the text value in to the Data property of the outbound message.

---

# 16. Messages  Cookbook

Document Number: 16
Source: https://cookbook_ao.arweave.net/concepts/messages.html
Words: 310
Quality Score: 0.512
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Messages The Message serves as the fundamental data protocol unit within ao, crafted from ANS-104 DataItems, thereby aligning with the native structure of Arweave. When engaged in a Process, a Message is structured as follows:This architecture merges the Assignment Type with the Message Type, granting the Process a comprehensive understanding of the Message's context for effective processing.When sending a message, here is a visual diagram of how the messages travels through the ao computer. The message workflow initiates with the MU (Messenger Unit), where the message's signature is authenticated. Following this, the SU (Scheduler Unit) allocates an Epoch and Nonce to the message, bundles the message with an Assignment Type, and dispatches it to Arweave. Subsequently, the aoconnect library retrieves the outcome from the CU (Compute Unit). The CU then calls for all preceding messages leading up to the current Message Id from the SU (Scheduler Unit), processes them to deduce the result. Upon completion, the computed result is conveyed back to aoconnect, which is integrated within client interfaces such as aos.Ethereum Signed Message If the Message ANS-104 DataItem was signed using Ethereum keys, then the value in the Owner and From fields will be the EIP-55 Ethereum address of the signer. For example: 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359.Summary Messages serve as the primary data protocol type for the ao network, leveraging ANS-104 Data-Items native to Arweave. Messages contain several fields including data content, origin, target, and cryptographic elements like signatures and nonces. They follow a journey starting at the Messenger Unit (MU), which ensures they are signed, through the Scheduler Unit (SU) that timestamps and sequences them, before being bundled and published to Arweave. The aoconnect library then reads the result from the Compute Unit (CU), which processes messages to calculate results and sends responses back through aoconnect, utilized by clients such as aos. The CU is the execution environment for these processes.

---

# 17. BetterIDEa  Cookbook

Document Number: 17
Source: https://cookbook_ao.arweave.net/references/betteridea/index.html
Words: 84
Quality Score: 0.510
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content BetterIDEa BetterIDEa is a custom web based IDE for developing on ao.It offers a built in Lua language server with ao definitions, so you don't need to install anything. Just open the IDE and start coding!Features include:Code completion Cell based notebook ui for rapid development Easy process management Markdown and Latex cell support Share projects with anyone through ao processes Tight integration with ao package manager Read detailed information about the various features and integrations of the IDE in the documentation.

---

# 18. Connecting to HyperBEAM with aos  Cookbook

Document Number: 18
Source: https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/aos-with-hyperbeam.html
Words: 254
Quality Score: 0.509
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Connecting to HyperBEAM with aos This guide explains how to use aos, the command-line interface for AO, to connect to a HyperBEAM node for development.Installing aos The primary tool for interacting with AO and developing processes is aos, a command-line interface and development environment.Connecting to a HyperBEAM Node While you don't need to run a HyperBEAM node yourself, you do need to connect to one to interact with the network during development.To start aos and connect to a public HyperBEAM node, simply run the command in your terminal:This connects you to an interactive Lua environment running within a process on the AO network. This process acts as your command-line interface (CLI) to the AO network. When you specify --mainnet , it connects to the genesis_wasm device running on the HyperBEAM node at the supplied URL, allowing you to interact with other processes, manage your wallet, and develop new AO processes.Running a Local HyperBEAM Node If you are running HyperBEAM locally and want to use that node when booting up aos, you must first start your local node with the genesis_wasm profile:Then, you can connect aos to it:Until aos is fully HyperBEAM native, the genesis_wasm profile is required to run a local Compute Unit (CU) for executing aos.Interacting with Mainnet Processes Note on Blocking Calls Blocking message patterns, such as Receive and ao.send().receive(), are not available when running aos against a HyperBEAM process. HyperBEAM processes do not support the underlying wasm modules required for this functionality. You should rely on asynchronous patterns using handlers instead.

---

# 19. Customizing the Prompt in aos  Cookbook

Document Number: 19
Source: https://cookbook_ao.arweave.net/guides/aos/prompt.html
Words: 203
Quality Score: 0.507
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Customizing the Prompt in aos Step 1: Open aos and Start the Editor Launch the aos command-line interface.Enter .editor to open the inline text editor.Step 2: Write the Custom Prompt Function In the editor, define your custom prompt function. For example:Customize "YourName@aos> " to your preferred prompt text.Step 3: Exit and Run Your Code To exit the editor and execute your code, type .done and then press Enter.Your aos prompt should now dis the new custom format.Step 4: Save for Future Use (Optional) If you wish to use this prompt in future aos sessions, save your script in a Lua file.In subsequent sessions, load this script to apply your custom prompt.Maximizing Your Prompt There's a great deal of utility and creativity that can come from customizing your prompt. Several things you can do within your prompt are:Tracking the number of unhandled messages you have in your inbox by creating a function that shows how many messages you have.Tracking the number of members are within your process ID's chatroom.Tracking the balance of a specified token that your process ID holds.Conclusion Now that you understand how to maximize the utility within your Prompt, you've now gained a crucial step to streamlining your ao development experience.

---

# 20. Messaging in ao  Cookbook

Document Number: 20
Source: https://cookbook_ao.arweave.net/tutorials/begin/messaging.html
Words: 996
Quality Score: 0.506
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Messaging in ao Learn how Messages gives ao Parallel Compute Capability In ao, every process runs in parallel, creating a highly scalable environment. Traditional direct function calls between processes aren't feasible because each process operates independently and asynchronously.Messaging addresses this by enabling asynchronous communication. Processes send and receive messages rather than directly invoking functions on each other. This method allows for flexible and efficient interaction, where processes can respond to messages, enhancing the system's scalability and responsiveness.We'll begin by exploring the basics of messaging in aos, how to see messages received in your inbox, and how to send messages to other processes.Video Tutorial Step 1: Understand the Message Structure Message Basics: Messages in ao are built using Lua tables, which are versatile data structures that can hold multiple values. Within these tables, the "Data" field is crucial as it contains the message's content or payload. This structure allows for efficient sending and receiving of information between processes, showcasing how ao primitives leverage Arweave's underlying capabilities to facilitate complex, composable operations.For detailed specifications, please refer to the original documentation on the G8way specs page.Example: { Data = "Hello from Process A!" } is a simple message.Step 2: Open the aos CLI Launch the aos command-line interface (CLI) by typing aos in your terminal and pressing Enter.shaos Step 3: How to Send a Message Send: The Send function is globally available in the aos interactive environment.Target: To send a message to a specific process, include a Target field in your message.Data: The Data is the string message (or payload) you want to be received by the receiving process. In this example, the message is "Hello World!".Step 4: Store Morpheus's Process ID We'll use the process ID provided below and store it as a variable called Morpheus.luaFvan28CFY0JYl5f_ETB7d3PDwBhGS8Yq5IA0vcWulUc Copy the process ID above and store it as a variable by running the below command in the aos CLI:This will store the process ID as a variable called Morpheus, making it easier to interact with the specific process ID.Check the Morpheus Variable Step 5: Send a Message to Morpheus After obtaining Morpheus's process ID and storing it in a variable, you're ready to communicate with it. To do this, you use the Send function. Morpheus, himself, is a parallel process running in ao. He receives and sends messages using a series of Handlers. Let's send him a message and see what happens.Your Target is Morpheus which is the variable we defined earlier using Morpheus 's process ID.The Data is the message you want to send to Morpheus. In this case, it's "Morpheus?".Expected Results:You've sent a message to Morpheus and received a response, but you can't read the full message. Let's learn about the Inbox and how to read messages.Step 6: The Inbox The Inbox is where you receive messages from other processes.INFO To see an in depth view of an inbox message, head over to the Messages Concepts page.Let's check your inbox to see how many messages you have received.Inside your aos CLI, type the following command:lua #Inbox If you're actively following through the tutorial, the inbox will not have many messages. However, if you've been experimenting with the aos environment, you may more than 1 message in your inbox.Example Return:In the example above, the return is 4, stating that there are four messages in the inbox.As we're actively looking for Morpheus 's response, we'll assume his message was the last one received. To read the last message in your inbox, type the following command:lua Inbox[#Inbox].Data This command allows you to isolate the Data from the message and only read the contents of the data.The Expected Return:You are now using your own process to communicate with Morpheus, another parallel process running in ao. You're now ready to move on to the next step in the tutorial.Step 7: Sending Messages with Tags Purpose of Tags: Tags in aos messages are used to categorize, route, and process messages efficiently. They a crucial role in message handling, especially when dealing with multiple processes or complex workflows.Some processes use Handlers that specifically interact with messages that have certain tags. For example, a process may have a handler that only interacts with messages that have a specific tag, which we'll see an example of in the chatroom tutorial.How to Use Tags in Messages In the case of Morpheus, we can use tags to categorize our messages, and because Morpheus is a autonomous process, he has handlers that can interact with messages that have certain tags.Adding Tags to a Message:We already know that the Data of a message is the payload of the message you want to send to another process. Earlier, we sent a message to Morpheus without any tags, in which he used a handler to respond to an exact match within the Data field.Let's Show Morpheus That We're Ready Send Morpheus a message with the tag Action and the value rabbithole.Example:Read the message from Morpheus:luaInbox[#Inbox].Data Expected Return:Additional Tips for Using Tags Consistent Tagging: Develop a consistent tagging system for your application to make message handling more predictable.Tag Naming: Choose clear and descriptive names for your tags. This makes it easier to understand the purpose and context of messages at a glance.Security with Tags: Remember that tags are not encrypted or hidden, so avoid using sensitive information as tags.Advanced Usage of Tags Workflow Management: Tags can be instrumental in managing workflows, especially in systems where messages pass through multiple stages or processes.Additional Tips for Messaging Message Structure: Explore other fields like Epoch, From, and Nonce for more complex messaging needs.Debugging: Use the Dump function to print messages for debugging.Security Considerations: Be cautious with the content and handling of messages, and never send anything considered private or sensitive.Conclusion You've now learned how to send messages with tags, which is a powerful tool for categorizing and routing messages in aos.Morpheus has officially invited you to the next stage of your journey. You're now ready to move on to the next step in the tutorial, Creating a Chatroom.

---

# 21. Crafting a Token  Cookbook

Document Number: 21
Source: https://cookbook_ao.arweave.net/tutorials/begin/token.html
Words: 576
Quality Score: 0.505
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Crafting a Token INFO Diving deeper into the ao, you're now ready to create your own token, a symbol of value and exchange within this decentralized medium. If you've found yourself wanting to learn how to create a token, but haven't visited the Messaging and Build a Chatroom lessons, be sure to do so as this page is part of a multi-part interactive tutorial.When creating tokens, we'll continue to use the Lua Language within ao to mint a token, guided by the principles outlined in the Token Specification.Video Tutorial Continuing Down the Rabbit Hole In our last tutorial, Build a Chatroom, we learned how to create a chatroom within ao, invited both Morpheus and Trinity to the chatroom we created, and then Trinity has now asked for us to create a token for her as a way of proving ourselves worthy of continuing down the rabbit hole.Let us begin.The Two Paths To Building a Token There are two paths to take when building a token:The Blueprint: This is a predesigned template that helps you quickly build a token in ao. It is a great way to get started and can be customized to fit your needs.Check here to Token Blueprint.The Manual Method: This is a step-by-step guide to building a token in ao from scratch. This path is for those who want to understand the inner workings of a token and how to build one from the ground up.Check here to review the full Build a Token guide.The Blueprint Method For this tutorial, we'll be using the Token Blueprint to create a token for Trinity. This is a predesigned template that helps you quickly build a token in ao.How To Use The Token Blueprint Make sure we're in the same directory as before during the previous steps in the tutorial.Open the Terminal.Start your aos process.Type in .load-blueprint token This will load the required handlers for the tutorials token within ao. It's important to note that the token blueprint isn't specific to this tutorial and can be used as a foundation for any token you wish to create.Verify the Blueprint is Loaded Type in Handlers.list to see the newly loaded handlers.You should see a new list of handlers that have been loaded into your aos process. If you've been following along the with the previous steps in the tutorial, you should also see the handlers for your chatroom, as well.Example: Testing the Token Now that the token blueprint is loaded, we can test the token by sending a message to ourselves using the Action = "Info" tag.This will print the token information to the console. It should show your process ID with the total balance of tokens available.Sending Tokens to Trinity Now that we've tested the token and it's working as expected, we can send some tokens to Trinity. We'll send 1000 tokens to Trinity using the Action = "Transfer" tag.When Trinity receives the tokens, she'll respond to the transfer with a message to confirm that she's received the tokens.Her response will look something like this:Trinity: "Token received. Interesting. I wasn't sure you'd make it this far. I'm impressed, but we are not done yet. I want you to use this token to tokengate the chatroom. Do that, and then I will believe you could be the one." You've completed the process of creating a token and sending it to Trinity. You're now ready to move on to the next step in the tutorial. Tokengating the Chatroom.

---

# 22. Building a Token in ao  Cookbook

Document Number: 22
Source: https://cookbook_ao.arweave.net/guides/aos/token.html
Words: 1337
Quality Score: 0.505
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Building a Token in ao When creating tokens, we'll continue to use the Lua Language within ao to mint a token, guided by the principles outlined in the Token Specification.Two Ways to Create Tokens:1 - Use the token blueprint:.load-blueprint token Using the token blueprint will create a token with all the handlers and state already defined. This is the easiest way to create a token. You'll be able to customize those handlers and state to your after loading the blueprint.You can blueprints here: Blueprints INFO Using the token blueprint will definitely get quickly, but you'll still want to understand how to load and test the token, so you can customize it to your needs.2 - Build from Scratch:The following guide will guide you through the process of creating a token from scratch. This is a more advanced way to create a token, but it will give you a better understanding of how tokens work.Preparations Step 1: Initializing the Token Open our preferred text editor, preferably from within the same folder you used during the previous tutorial.Create a new file named token.lua.Within token.lua, you'll begin by initializing the token's state, defining its balance, name, ticker, and more: Let's break down what we've done here:local json = require('json'): This first line of this code imports a module for later use.if not Balances then Balances = { [ao.id] = 100000000000000 } end: This second line is initializing a Balances table which is the way the Process tracks who posses the token. We initialize our token process ao.id to start with all the balance.The Next 4 Lines, if Name, if Ticker, if Denomination, and if not Logo are all optional, except for if Denomination, and are used to define the token's name, ticker, denomination, and logo respectively.INFO The code if Denomination ~= 10 then Denomination = 10 end tells us the number of the token that should be treated as a single unit.Step 2: Info and Balances Handlers Incoming Message Handler Now lets add our first Handler to handle incoming Messages. INFO At this point, you've probably noticed that we're building all of the handlers inside the token.lua file rather than using .editor.With many handlers and processes, it's perfectly fine to create your handlers using .editor, but because we're creating a full process for initializing a token, setting up info and balances handlers, transfer handlers, and a minting handler, it's best to keep everything in one file.This also allows us to maintain consistency since each handler will be updated every time we reload the token.lua file into aos.This code means that if someone Sends a message with the Tag, Action = "Info", our token will Send back a message with all of the information defined above. Note the Target = msg.From, this tells ao we are replying to the process that sent us this message.Info & Token Balance Handlers Now we can add 2 Handlers which provide information about token Balances.The first Handler above Handlers.add('Balance' handles a process or person requesting their own balance or the balance of a Target. Then replies with a message containing the info. The second Handler Handlers.add('Balances' just replies with the entire Balances table.Step 3: Transfer Handlers Before we begin testing we will add 2 more Handlers one which allows for the transfer of tokens between processes or users.luaHandlers.add('Transfer', Handlers.utils.hasMatchingTag('Action', 'Transfer'), function(msg)
assert(type(msg.Tags.Recipient) == 'string', 'Recipient is required!')
assert(type(msg.Tags.Quantity) == 'string', 'Quantity is required!')
if not Balances[msg.From] then Balances[msg.From] = 0 end
if not Balances[msg.Tags.Recipient] then Balances[msg.Tags.Recipient] = 0 end
local qty = tonumber(msg.Tags.Quantity)
assert(type(qty) == 'number', 'qty must be number')
if Balances[msg.From] >= qty then
Balances[msg.From] = Balances[msg.From] - qty
Balances[msg.Tags.Recipient] = Balances[msg.Tags.Recipient] + qty
--[[
Only Send the notifications to the Sender and Recipient
if the Cast tag is not set on the Transfer message
]] --
if not msg.Tags.Cast then
-- Debit-Notice message template, that is sent to the Sender of the transfer
local debitNotice = {
Target = msg.From,
Action = 'Debit-Notice',
Recipient = msg.Recipient,
Quantity = tostring(qty),
Data = Colors.gray ..
"You transferred " ..
Colors.blue .. msg.Quantity .. Colors.gray .. " to " .. Colors.green .. msg.Recipient .. Colors.reset
}
-- Credit-Notice message template, that is sent to the Recipient of the transfer
local creditNotice = {
Target = msg.Recipient,
Action = 'Credit-Notice',
Sender = msg.From,
Quantity = tostring(qty),
Data = Colors.gray ..
"You received " ..
Colors.blue .. msg.Quantity .. Colors.gray .. " from " .. Colors.green .. msg.From .. Colors.reset
}
-- Add forwarded tags to the credit and debit notice messages
for tagName, tagValue in pairs(msg) do
-- Tags beginning with "X-" are forwarded
if string.sub(tagName, 1, 2) == "X-" then
debitNotice[tagName] = tagValue
creditNotice[tagName] = tagValue
end
end
-- Send Debit-Notice and Credit-Notice
ao.send(debitNotice)
ao.send(creditNotice)
end
else
ao.send({
Target = msg.Tags.From,
Tags = { ["Action"] = 'Transfer-Error', ['Message-Id'] = msg.Id, ["Error"] = 'Insufficient Balance!' }
})
end
end) In summary, this code checks to make sure the Recipient and Quantity Tags have been provided, initializes the balances of the person sending the message and the Recipient if they dont exist and then attempts to transfer the specified quantity to the Recipient in the Balances table.If the transfer was successful a Debit-Notice is sent to the sender of the original message and a Credit-Notice is sent to the Recipient.If there was insufficient balance for the transfer it sends back a failure message The line if not msg.Tags.Cast then Means were not producing any messages to push if the Cast tag was set. This is part of the ao protocol.Step 4: Mint Handler Finally, we will add a Handler to allow the minting of new tokens.This code checks to make sure the Quantity Tag has been provided and then adds the specified quantity to the Balances table.Once you've created your token.lua file, or you've used .load-blueprint token, you're now ready to begin testing.1 - Start the aos process Make sure you've started your aos process by running aos in your terminal.If you've followed along with the guide, you'll have a token.lua file in the same directory as your aos process. From the aos prompt, load in the file.lua.load token.lua 3 - Testing the Token Now we can send Messages to our aos process ID, from the same aos prompt to see if is working. If we use ao.id as the Target we are sending a message to ourselves.This should print the Info defined in the contract. Check the latest inbox message for the response.luaInbox[#Inbox].Tags This should print the Info defined in the contract.INFO Make sure you numerically are checking the last message. To do so, run #Inbox first to see the total number of messages are in the inbox. Then, run the last message number to see the data.Example:If #Inbox returns 5, then run Inbox[5].Data to see the data.4 - Transfer Now, try to transfer a balance of tokens to another wallet or process ID.INFO If you need another process ID, you can run aos [name] in another terminal window to get a new process ID. Make sure it's not the same aos [name] as the one you're currently using.Example:If you're using aos in one terminal window, you can run aos test in another terminal window to get a new process ID.After sending, you'll receive a printed message in the terminal similar to Debit-Notice on the sender's side and Credit-Notice on the recipient's side.5 - Check the Balances Now that you've transferred some tokens, let's check the balances.luaInbox[#Inbox].Data You will see two process IDs or wallet addresses, each dising a balance. The first should be your sending process ID, the second should be the recipient's process ID.6 - Minting Tokens Finally, attempt to mint some tokens.And check the balances again.You'll then see the balance of the process ID that minted the tokens has increased.Conclusion That concludes the "Build a Token" guide. Learning out to build custom tokens will unlock a great deal of potential for your projects; whether that be creating a new currency, a token for a game, a governance token, or anything else you can imagine.

---

# 23. Troubleshooting using aolink  Cookbook

Document Number: 23
Source: https://cookbook_ao.arweave.net/guides/aos/troubleshooting.html
Words: 337
Quality Score: 0.504
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Troubleshooting using ao.link Working with a decentralized computer and network, you need to be able to troubleshoot more than your own code. You need to be able to track messages, token balances, token transfers of processes. This is where https://ao.link becomes an essential tool in your toolbox. Analytics AOLink has a set of 4 analytic measures:Total Messages Total Users Total Processes Total Modules These analytics give you a quick view into the ao network's total processing health.Events Below, the analytics are the latest events that have appeared on the ao computer. You have a list of messages being scheduled and that have been executed. These events are any of the ao Data Protocol Types. And you can click on the Process ID or the Message ID to get details about each. Message Details The message details give you key details about:From To Block Height Created Tags Data Result Type Data If you want to further troubleshoot and debug, you have the option to look at the result of the CU (Compute Unit) by clicking on "Compute". And further understand linked messages. Process Details The process details provide you with information about the process it's useful to see in the tags with what module this got instantiated from. If you notice on the left you see the interaction with the process dised on a graph. In this case, this is DevChat, and you can see all the processes that have interacted by Registering and Broadcasting Messages.You can effortless check the Info Handler, by pressing the "Fetch" button. On the bottom you see the processes balance and all messages send, with the option to break it down into Token transfers and Token balances using the tabs. Further Questions?Feel free to reach out on the community Discord of Autonomous Finance, for all questions and support regarding ao.link. https://discord.gg/4kF9HKZ4Wu Summary AOLink is an excellent tool for tracking events in the ao computer. Give it a try. Also, there is another scanner tool available on the permaweb: https://ao_marton.g8way.io/ - check it out!

---

# 24. Preparations  Cookbook

Document Number: 24
Source: https://cookbook_ao.arweave.net/tutorials/begin/preparations.html
Words: 503
Quality Score: 0.504
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Preparations INFO The Awakening Begins:You've always known there's more to this world, just outside of your reach. You've been searching for it, not even knowing what it was you were looking for. It... is ao.We begin our journey by installing the aos client and starting a new process. This will allow us to interact with the ao computer and complete the rest of the tutorial.Video Tutorial System requirements The local client of aos is very simple to install. Just make sure you have:NodeJS version 20+. (If you haven't yet installed it, check out this page to find instructions for your OS).A code editor of your choice.INFO Though it's not required, we do recommend installing the ao addon into your text editor of choice to optimize your experience with aos.Installing aos Once you have NodeJS on your machine, all you need to do is install aos and run it:After installation, we can simply run the command itself to start a new aos process!shaos Welcome to the rabbit hole The utility you just started is a local client, which is ready to relay messages for you to your new process inside the ao computer.After it connects, you should see the following:sh _
/\ \ /::\ \ /\ \
/::\ \ /::::\ \ /::\ \
/::::\ \ /::::::\ \ /::::\ \
/::::::\ \ /::::::::\ \ /::::::\ \
/:::/\:::\ \ /:::/~~\:::\ \ /:::/\:::\ \
/:::/\:::\ \ /:::/ \:::\ \ /:::/\:::\ \
/::::\ \:::\ \ /:::/ / \:::\ \ \:::\ \:::\ \
/::::::\ \:::\ \ /:::// \:::\\ _\:::\ \:::\ \
/:::/\:::\ \:::\ \ |:::| | |:::| | /\ \:::\ \:::\ \
/:::/ \:::\ \:::\\|:::|| |:::| |/::\ \:::\ \:::\\
\::/ \:::\ /:::/ / \:::\ \ /:::/ / \:::\ \:::\ \::/ /
\// \:::\/:::/ / \:::\ \ /:::/ / \:::\ \:::\ \//
\::::::/ / \:::\ /:::/ / \:::\ \:::\ \
\::::/ / \:::\/:::/ / \:::\ \:::\\
/:::/ / \::::::::/ / \:::\ /:::/ /
/:::/ / \::::::/ / \:::\/:::/ /
/:::/ / \::::/ / \::::::/ /
/:::/ / \::// \::::/ /
\::/ / ~~ \::/ /
\// \//
Welcome to AOS: Your operating system for AO, the decentralized open
access supercomputer.
Type ".load-blueprint chat" to join the community chat and ask questions!
AOS Client Version: 1.12.1. 2024
Type "Ctrl-C" twice to exit
Your AOS process: QFt5SR6UwJSCnmgnROq62-W8KGY9z96k1oExgn4uAzk
default@aos-0.2.2[Inbox:1]> Let's walk through the initial printout after running aos: After running aos in your terminal, you should see:An ASCII art image of AOS.A Welcome Message The version of aos you are running.An instructional exit message.Your process ID.INFO If your OS version is different than the latest version, a message asking if you'd like to update the version will appear. If so, simply exit the process by pressing "Ctrl+C" twice, run npm i -g https://get_ao.g8way.io to update, and then run aos again.Welcome to your new home in the ao computer! The prompt you are now looking at is your own personal server in this decentralized machine.Now, let's journey further down the rabbit hole by exploring one of the two core concept type of ao: messaging.

---

# 25. Exposing Process State to HyperBEAM  Cookbook

Document Number: 25
Source: https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/exposing-process-state.html
Words: 578
Quality Score: 0.501
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Exposing Process State to HyperBEAM HyperBEAM introduces a powerful feature for exposing parts of a process's state for immediate reading over HTTP. This improves performance for web frontends and data services by replacing the need for dryrun calls, which were a known bottleneck on legacynet.The Patch Device The ~patch@1.0 device is the mechanism that allows AO processes to make parts of their internal state readable via direct HTTP GET requests.How it Works Exposing state is a four-step process involving your process and HyperBEAM:Process Logic: From your process (e.g., in Lua or WASM), send an outbound message to the ~patch@1.0 device.Patch Message Format: The message must include device and cache tags.HyperBEAM Execution: HyperBEAM's dev_patch module processes this message, mapping the key-value pairs from the cache table to a URL path.HTTP Access: The exposed data is then immediately available via a standard HTTP GET request to the process's endpoint.HyperBEAMGET /~process@1.0/compute/cache/ Initial State Sync (Optional) To make data available immediately on process creation, you can patch its initial state. A common pattern is to use a flag to ensure this sync only runs once, as shown in this example for a token's Balances and TotalSupply.lua-- Place this logic at the top level of your process script,
-- outside of specific handlers, so it runs on load.
Balances = { token1 = 100, token2 = 200 } -- A table of balances
TotalSupply = 1984 -- A single total supply value
-- 1. Initialize Flag:
-- Initializes a flag if it doesn't exist.
InitialSync = InitialSync or 'INCOMPLETE'
-- 2. Check Flag:
-- Checks if the sync has already run.
if InitialSync == 'INCOMPLETE' then
-- 3. Patch State:
-- The `Send` call patches the state, making it available at endpoints like:
-- /cache/balances
-- /cache/totalsupply
Send({ device = 'patch@1.0', cache = { balances = Balances, totalsupply = TotalSupply } })
-- 4. Update Flag:
-- Updates the flag to prevent the sync from running again.
InitialSync = 'COMPLETE'
print("Initial state sync complete. Balances and TotalSupply patched.")
end This pattern makes essential data queryable upon process creation, boosting application responsiveness.Example (Lua in aos) This handler exposes a currentstatus key that can be read via HTTP after the PublishData action is called.Avoiding Key Conflicts Keys in the cache table become URL path segments. To avoid conflicts with reserved HyperBEAM paths, use descriptive, specific keys. Avoid using reserved keywords such as:For instance, prefer a key like myappstate over a generic key like state.WARNING HTTP paths are case-insensitive. While the patch device stores keys with case sensitivity (e.g., MyKey vs mykey), HTTP access to paths like the following is ambiguous and may lead to unpredictable results.To prevent conflicts, always use lowercase keys in your cache table (e.g., mykey, usercount).HyperBEAMGET /~process@1.0/cache/mykey Key Points Path Structure: Data is exposed at a path structured like this, where is a key from your cache table:HyperBEAM/~process@1.0/cache/ Data Types: Basic data types like strings and numbers work best. Complex objects may require serialization.compute vs now: Accessing patched data can be done via two main paths:The compute endpoint serves the last known value quickly, while now may perform additional computation to get the most recent state.Read-Only Exposure: Patching is for efficient reads and does not replace your process's core state management logic.Using the patch device enables efficient, standard HTTP access to your process state, seamlessly connecting decentralized logic with web applications.Now that you know how to expose static state, learn how to perform on-the-fly computations on that state by reading dynamic state.

---

# 26. How ao messaging works  Cookbook

Document Number: 26
Source: https://cookbook_ao.arweave.net/concepts/how-it-works.html
Words: 395
Quality Score: 0.499
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

How ao messaging works Before we dive in to ao, I want to share with you a little information about unix. Unix is a powerful operating system, but in its design it is focused on two Principal "Types". Files and Programs. A File is data and a Program is logic, when you combine the two you get information.Input.file | TransformProgram | Output.file You might have done something like this on the command line without knowing what you were doing. Being able to connect files to programs and return files which can then be passed to other programs creates a complex system composed of simple applications. This is a very powerful idea.Now, lets talk about ao the hyper parallel computer, and lets change the idea of a File to the ao concept of a Message and the idea of a Program to the ao concept of a Process. The ao computer takes messages and sends them to Processes in which those Processes can output messages that can be sent to other Processes. The result is a complex system built on simple modular logic containers.MessageA | Process | MessageB Here is a description of the process as outlined in the flowchart:A message is initiated from an ao Connect. This message is sent to the mu service using a POST request. The body of the request contains data following a protocol, labeled 'ao', and is of the type 'Message'.The mu service processes the POST request and forwards the message to the su service. This is also done using a POST request with the same data protocol and message type.The su service stores the assignment and message on Arweave.A GET request is made to the cu service to retrieve results based on a message ID. The cu is a service that evaluates messages on processes and can return results based on an individual message identifier.A GET request is made to the su service to retrieve the assignment and message. This request is looking for messages from a process ID, within a range of time from a start (from the last evaluation point) to (to the current message ID).The final step is to push any outbox Messages. It involves reviewing the messages and spawns in the Result object. Based on the outcome of this check, the steps 2, 3, and 4 may be repeated for each relevant message or spawn.

---

# 27. Get started in 5 minutes  Cookbook

Document Number: 27
Source: https://cookbook_ao.arweave.net/welcome/getting-started.html
Words: 837
Quality Score: 0.499
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Get started in 5 minutes In less than 5 mins, we'll walk you through the process of taking your first peek into the rabbit hole of AO Processes. 🕳️🐇 Now that you understand the AO-Core protocol and how AO Processes work, let's get hands-on with creating your first AO Process.System requirements The local client of aos is super simple to install. Just make sure you have:NodeJS version 20+. (If you haven't yet installed it, check out this page to find instructions for your OS).A code editor of your choice.Installing aos Once you have NodeJS on your machine, all you need to do is install aos and run it:After installation, we can simply run the command itself to start a new aos process!shaos You authenticate yourself to your aos process using a keyfile. If you have an Arweave wallet you can specify it by adding a --wallet [location] flag. If you don't, a new keyfile will be generated and stored locally for you at ~/.aos.json.Welcome to the rabbit hole The utility you just started is a local client, which is ready to relay messages for you to your new process inside the ao computer.After it connects, you should see the following:lua _
/\ \ /::\ \ /\ \
/::\ \ /::::\ \ /::\ \
/::::\ \ /::::::\ \ /::::\ \
/::::::\ \ /::::::::\ \ /::::::\ \
/:::/\:::\ \ /:::/~~\:::\ \ /:::/\:::\ \
/:::/\:::\ \ /:::/ \:::\ \ /:::/\:::\ \
/::::\ \:::\ \ /:::/ / \:::\ \ \:::\ \:::\ \
/::::::\ \:::\ \ /:::// \:::\\ _\:::\ \:::\ \
/:::/\:::\ \:::\ \ |:::| | |:::| | /\ \:::\ \:::\ \
/:::/ \:::\ \:::\\|:::|| |:::| |/::\ \:::\ \:::\\
\::/ \:::\ /:::/ / \:::\ \ /:::/ / \:::\ \:::\ \::/ /
\// \:::\/:::/ / \:::\ \ /:::/ / \:::\ \:::\ \//
\::::::/ / \:::\ /:::/ / \:::\ \:::\ \
\::::/ / \:::\/:::/ / \:::\ \:::\\
/:::/ / \::::::::/ / \:::\ /:::/ /
/:::/ / \::::::/ / \:::\/:::/ /
/:::/ / \::::/ / \::::::/ /
/:::/ / \::// \::::/ /
\::/ / ~~ \::/ /
\// \//
Welcome to AOS: Your operating system for AO, the decentralized open
access supercomputer.
Type ".load-blueprint chat" to join the community chat and ask questions!
AOS Client Version: 1.12.1. 2024
Type "Ctrl-C" twice to exit
Your AOS process: QFt5SR6UwJSCnmgnROq62-W8KGY9z96k1oExgn4uAzk
default@aos-0.2.2[Inbox:1]> Welcome to your new home in the ao computer! The prompt you are now looking at is your own personal server in this decentralized machine. We will be using it to with and explore ao in the rest of this tutorial.Sending your first command Your new personal aos process is a server that lives inside the computer, waiting to receive and execute your commands.aos loves to make things simple, so it wants to hear commands from you in the Lua programming language. Don't know Lua? Don't panic! It is a super straightforward, friendly, and fun language. We will learn it as we progress through this series.Let's break the ice and type:Then hit the "[Enter]" key. You should see your shell sign and post the message, request the result, then print the result as follows:lua"Hello, ao!" Eh. What's the big deal?Sent it a message to your process, permanently etched it into Arweave, then asked a distributed compute network to calculate its result.While the result might not look revolutionary, in reality you have done something quite extraordinary. Your process is a decentralized server that doesn't exist in any one particular place on Earth. It exists as data, replicated on Arweave between many different machines, distributed all over the world. If you wanted to, you could now attach a new compute unit to this process and recreate the state from its log of inputs (just your single command, for now) -- at any time in the future.This makes your new shell process...Resilient: There is no single place on Earth where your server actually resides. It is everywhere and nowhere -- immune from physical destruction or tampering of any kind.Permanent: Your process will never disappear. It will always exist in its ✨holographic state✨ on Arweave, allowing you to recall it and continue ing with it. A contribution has been made to Arweave's storage endowment, so that you never have to think about upkeep or maintenance payments again.Permissionless: You did not have to register in order to start this server. Your right to use it is guaranteed by its underlying protocol (Arweave), no matter what Google, Amazon, or any other BigTech company says.Trustless: The state of your server is mathematically guaranteed. This means that you -- and everyone else -- can trust it with certainty, without even having to trust the underlying hardware it runs on. This property lets you build trustless services on top: Code that runs without any privileged owner or controller, ruled purely by math.There is so much more to it, but these are the basics. Welcome to the ao computer, newbie! We are grateful to have you. 🫡 In the tutorials that follow, we will explore ao and build everything from chatrooms to autonomous, decentralized bots. Let's go!

---

# 28. Sending a Message to a Process  Cookbook

Document Number: 28
Source: https://cookbook_ao.arweave.net/guides/aoconnect/sending-messages.html
Words: 384
Quality Score: 0.498
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Sending a Message to a Process A deep dive into the concept of Messages can be found in the ao Messages concept. This guide focuses on using ao connect to send a message to a process.Sending a message is the central way in which your app can interact with ao. A message is input to a process. There are 5 parts of a message that you can specify which are "target", "data", "tags", "anchor", and finally the messages "signature".Refer to your process module's source code or documentation to see how the message is used in its computation. The ao connect library will translate the parameters you pass it in the code below, construct a message, and send it.🎓 To visit the Permaweb Cookbook Sending a Message in NodeJS Need a test wallet, use npx -y @permaweb/wallet > /path/to/wallet.json to create a wallet keyfile.jsimport { readFileSync } from "node:fs";
import { message, createDataItemSigner } from "@permaweb/aoconnect";
const wallet = JSON.parse(
readFileSync("/path/to/arweave/wallet.json").toString(),
);
// The only 2 mandatory parameters here are process and signer
await message({
/*
The arweave TxID of the process, this will become the "target".
This is the process the message is ultimately sent to.
*/
process: "process-id",
// Tags that the process will use as input.
tags: [
{ name: "Your-Tag-Name-Here", value: "your-tag-value" },
{ name: "Another-Tag", value: "another-value" },
],
// A signer function used to build the message "signature"
signer: createDataItemSigner(wallet),
/*
The "data" portion of the message
If not specified a random string will be generated
*/
data: "any data",
})
.then(console.log)
.catch(console.error);Sending a Message in a browser New to building permaweb apps check out the Permaweb Cookbook jsimport { message, createDataItemSigner } from "@permaweb/aoconnect";
// The only 2 mandatory parameters here are process and signer
await message({
/*
The arweave TxID of the process, this will become the "target".
This is the process the message is ultimately sent to.
*/
process: "process-id",
// Tags that the process will use as input.
tags: [
{ name: "Your-Tag-Name-Here", value: "your-tag-value" },
{ name: "Another-Tag", value: "another-value" },
],
// A signer function used to build the message "signature"
signer: createDataItemSigner(globalThis.arweaveWallet),
/*
The "data" portion of the message.
If not specified a random string will be generated
*/
data: "any data",
})
.then(console.log)
.catch(console.error);If you would like to , click here

---

# 29. aoconnect  Cookbook

Document Number: 29
Source: https://cookbook_ao.arweave.net/guides/aoconnect/aoconnect.html
Words: 44
Quality Score: 0.497
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content aoconnect ao connect is a Javascript/Typescript library to interact with the system from Node JS or the browser.Guides in this section provide snippets on how to utilize ao connect. All snippets are written in Javascript but should translate easily to Typescript.

---

# 30. JSON  Cookbook

Document Number: 30
Source: https://cookbook_ao.arweave.net/guides/aos/modules/json.html
Words: 85
Quality Score: 0.497
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content JSON The JSON module allows you to encode and decode objects using JavaScript Object Notation.Example usage Module functions encode() This function returns a string representation of a Lua object in JSON.Parameters:val: {any} The object to format as JSON Returns: JSON string representation of the provided object Example decode() The function takes a JSON string and turns it into a Lua object.Parameters:val: {any} The JSON string to decode Returns: Lua object corresponding to the JSON string (throws an error for invalid JSON strings)

---

# 31. Getting started with SQLite  Cookbook

Document Number: 31
Source: https://cookbook_ao.arweave.net/guides/snacks/sqlite.html
Words: 130
Quality Score: 0.497
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Getting started with SQLite SQLite is a relational database engine. In this guide, we will show how you can spawn a process with SQLite and work with data using a relational database.Setup NOTE: make sure you have aos installed, if not checkout Getting Started spawn a new process mydb with a --sqlite flag, this instructs ao to use the latest sqlite module.Install AO Package Manager installing apm, the ao package manager we can add helper modules to make it easier to work with sqlite.lua.load-blueprint apm Install dbAdmin package DbAdmin is a module that connects to a sqlite database and provides functions to work with sqlite.https://apm_betteridea.g8way.io/pkg?id=@rakis/DbAdmin luaapm.install('@rakis/dbAdmin') Create sqlite Database Create Table Create a table called Comments Insert data List data Congrats!You are using sqlite on AO 🎉

---

# 32. AO Dev-Cli 01  Cookbook

Document Number: 32
Source: https://cookbook_ao.arweave.net/guides/dev-cli/index.html
Words: 462
Quality Score: 0.495
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

AO Dev-Cli 0.1 The AO dev-cli is a tool that is used to build ao wasm modules, the first versions of the tool only supported lua as the embedded language or c based module. With this release developers now can add any pure c or cpp module to their wasm builds. This opens the door for many different innovations from indexers to languages.Install Requirements Docker is required: https://docker.com Start a project Build a project Deploy a project Requirements You will need an arweave keyfile, you can create a local one using this command npx -y @permaweb/wallet > wallet.json Configuration To customize your build process, create a config.yml file in the root directory of your project. This file will modify your settings during the build.Configuration Options:preset: Selects default values for stack_size, initial_memory, and maximum_memory. For available presets, see Config Presets. (Default: md) stack_size: Specifies the stack size, overriding the value from the preset. Must be a multiple of 64. (Default: 32MB) initial_memory: Defines the initial memory size, overriding the preset value. Must be larger than stack_size and a multiple of 64. (Default: 48MB) maximum_memory: Sets the maximum memory size, overriding the preset value. Must be larger than stack_size and a multiple of 64. (Default: 256MB) extra_compile_args: Provides additional compilation commands for emcc. (Default: []) keep_js: By default, the generated .js file is deleted since AO Loader uses predefined versions. Set this to true if you need to retain the .js file. (Default: false) Libraries Starting with version 0.1.3, you can integrate external libraries into your project. To do this, follow these guidelines:Adding Libraries Create a libs Directory: At the root of your project, create a directory named /libs. This is where you'll place your library files.Place Your Library Files: Copy or move your compiled library files (e.g., .a, .so, .o, .dylib, etc.) into the /libs directory.NOTE Ensure that all library files are compiled using emcc to ensure compatibility with your project.IMPORTANT More details to come including an example project...Example Directory Structure Using Libraries in Your Code After adding the library files to the /libs directory, you need to link against these libraries in your project. This often involves specifying the library path and names in your build scripts or configuration files. For example:For C/C++ Projects: You can just include any header files placed in the libs folder as the libs with be automatically built into your module.For Lua Projects: Depending on how your build your libraries and if you compiled them with Lua bindings you can just require the libs in your lua files. markdown = require('markdown') IMPORTANT More details to come...Lua Build Example To create and build a Lua project, follow these steps:C Build Example To create and build a C project, follow these steps:Config Presets Here are the predefined configuration presets:

---

# 33. Meet Web Assembly  Cookbook

Document Number: 33
Source: https://cookbook_ao.arweave.net/references/wasm.html
Words: 189
Quality Score: 0.495
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Meet Web Assembly WebAssembly (often abbreviated as Wasm) is a modern binary instruction format providing a portable compilation target for high-level languages like C, C++, and Rust. It enables deployment on the web for client and server applications, offering a high level of performance and efficiency. WebAssembly is designed to maintain the security and sandboxing features of web browsers, making it a suitable choice for web-based applications. It's a key technology for web developers, allowing them to write code in multiple languages and compile it into bytecode that runs in the browser at near-native speed.The significance of WebAssembly lies in its ability to bridge the gap between web and native applications. It allows complex applications and games, previously limited to desktop environments, to run in the browser with comparable performance. This opens up new possibilities for web development, including the creation of high-performance web apps, games, and even the porting of existing desktop applications to the web. WebAssembly operates alongside JavaScript, complementing it by enabling performance-critical components to be written in languages better suited for such tasks, thereby enhancing the capabilities and performance of web applications.

---

# 34. Building a Chatroom in aos  Cookbook

Document Number: 34
Source: https://cookbook_ao.arweave.net/tutorials/begin/chatroom.html
Words: 733
Quality Score: 0.495
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Building a Chatroom in aos INFO If you've found yourself wanting to learn how to create a chatroom within ao, then that means we understand at least the basic methodology of sending and receiving messages. If not, it's suggested that you review the Messaging tutorial before proceeding.In this tutorial, we'll be building a chatroom within ao using the Lua scripting language. The chatroom will feature two primary functions:Register: Allows processes to join the chatroom.Broadcast: Sends messages from one process to all registered participants.Let's begin by setting up the foundation for our chatroom.Video Tutorial Step 1: The Foundation Open your preferred code editor, e.g. VS Code.Create a new file named chatroom.lua. Step 2: Creating The Member List In chatroom.lua, you'll begin by initializing a list to track participants: Save the chatroom.lua file Step 3: Load the Chatroom into aos With chatroom.lua saved, you'll now load the chatroom into aos.If you haven't already, start your aos in your terminal inside the directory where chatroom.lua is saved In the aos CLI, type the following script to incorporate your script into the aos process:lua.load chatroom.lua Type Members, or whatever you named your user list, in aos. It should return an empty array { }. If you see an empty array, then your script has been successfully loaded into aos.Step 4: Creating Chatroom Functionalities The Registration Handler The register handler will allow processes to join the chatroom.Adding a Register Handler: Modify chatroom.lua to include a handler for Members to register to the chatroom with the following code: This handler will allow processes to register to the chatroom by responding to the tag Action = "Register". A printed message will confirm stating Registered. will appear when the registration is successful.Reload and Test: Let's reload and test the script by registering ourselves to the chatroom.Save and reload the script in aos using .load chatroom.lua.Check to see if the register handler loaded with the following script:lua Handlers.list This will return a list of all the handlers in the chatroom. Since this is most likely your first time developing in aos, you should only see one handler with the name Register.Let's test the registration process by registering ourselves to the chatroom:If successful, you should see that there was a message added to your outbox and that you then see a new printed message that says registered. Finally, let's check to see if we were successfully added to the Members list:lua Members If successful, you'll now see your process ID in the Members list.Adding a Broadcast Handler Now that you have a chatroom, let's create a handler that will allow you to broadcast messages to all members of the chatroom.Add the following handler to the chatroom.lua file:This handler will allow you to broadcast messages to all members of the chatroom.Save and reload the script in aos using .load chatroom.lua.Let's test the broadcast handler by sending a message to the chatroom:Step 5: Inviting Morpheus to the Chatroom Now that you've successfully registered yourself to the chatroom, let's invite Morpheus to join us. To do this, we'll send an invite to him that will allow him to register to the chatroom.Morpheus is an autonomous agent with a handler that will respond to the tag Action = "Join", in which will then have him use your Register tag to register to the chatroom.Let's send Morpheus an invitation to join the chatroom:To confirm that Morpheus has joined the chatroom, check the Members list:luaMembers If successful, you'll receive a broadcasted message from Morpheus.Step 6: Inviting Trinity to the Chatroom Within this message, he'll give you Trinity's process ID and tell you to invite her to the chatroom.Use the same processes to save her process ID as Trinity and to invite her to the chatroom as you did with Morpheus.If she successfully joins the chatroom, she'll then pose the next challenge to you, creating a token.Engaging Others in the Chatroom Onboarding Others Invite aos Users: Encourage other aos users to join your chatroom. They can register and participate in the broadcast.Provide Onboarding Instructions: Share a simple script with them for easy onboarding:Congratulations! You've successfully built a chatroom in ao and have invited Morpheus to join you. You've also created a broadcast handler to send messages to all members of the chatroom.Next, you'll continue to engage with Morpheus, but this time you'll be adding Trinity to the conversation. She will lead you through the next set of challenges. Good Luck!

---

# 35. A whistle stop tour of Lua  Cookbook

Document Number: 35
Source: https://cookbook_ao.arweave.net/concepts/lua.html
Words: 869
Quality Score: 0.493
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

A whistle tour of Lua.Before we can explore ao in greater depth, let's take a moment to learn the basics of Lua: your companion for commanding aos processes.Lua is a simple language with few surprises. If you know Javascript, it will feel like a simplified, purer version. If you are learning from-scratch, it will seem like a tiny language that focuses on the important stuff: Clean computation with sane syntax.In this section we will cover the basics of Lua in just a few minutes. If you already know Lua, jump right through to the next chapter Jumping back into your aos process.For the purpose of this tutorial, we will be assuming that you have already completed the getting started guide. If not, complete that first.If you logged out of your process, you can always re-open it by running aos on your command line, optionally specifying your key file with --wallet [location].Basic Lua expressions.In the remainder of this primer we will quickly run through Lua's core features and syntax.Try out on the examples on your aos process as you go, or skip them if they are intuitive to you.Basic arithmetic: Try some basic arithmetic, like 5 + 3. After processing, you will see the result 8. +, -, *, /, and ^ all work as you might expect. % is the symbol that Lua uses for modulus.Setting variables: Type a = 10 and press enter. This sets the variable a to 10. By convention (not enforced by the language), global variables start with a capital letter in Lua (for example Handlers).Using variables: Now type a * 2. You will see 20 returned on the command line.String concatenation: Say hello to yourself by executing "Hello, " .. ao.id.INFO Note that while global variables conventionally start with a capital letter in Lua, this is not enforced by the language. For example, the ao module is a global variable that was intentionally lowercased for stylistic purposes.Experimenting with conditional statements.If-Else: Like most programming languages, Lua uses if-else blocks to conditionally execute code.In your aos process, type .editor and press enter. This will open an in-line text editor within your command-line interface.Once you are finished editing on your terminal, type .done on a new line and press enter. This will terminate edit mode and submit the expression to your process for evaluation.As a result, you will see that aos coolness is >9,000 cool. Good to know.if statements in Lua can also have additional elseif [condition] then blocks, making conditional execution hierarchies easier.Looping in Lua.There are a few different ways to loop in your code in Lua. Here are our favorites:While loops:Start by initializing your counter to zero by typing n = 0 and pressing enter.Then open the inline editor again with .editor.Type .done on a new line to execute the while loop. You can check the result of the loop by simply running n.For loops:Lua can also execute python-style for loops between a set of values. For example, use the .editor to enter the following code block:Request the new value of the variable by running n again.Getting functional.Define a function:Using the .editor once again, submit the following lines:Lua also has 'anonymous' or 'higher order' functions. These essentially allow you to use functions themselves as if they are normal data -- to be passed as arguments to other functions, etc. The following example defines an anonymous function and is equivalent to the above:Calling the function: Call the function with greeting("Earthling"). aos will return "Hello, Earthling".INFO Handlers in ao commonly utilize anonymous functions. When using Handlers.add(), the third argument is an anonymous function in the form function(msg) ... end. This is a key pattern you'll see frequently when working with ao processes.Defining deep objects with tables.Tables are Lua's only compound data structure. They map keys to values, but can also be used like traditional arrays.Create a simple table: Type ao_is = {"hyper", "parallel", "compute"} to create a simple table.Accessing the table's elements: Access an element with ao_is[2]. aos will return parallel. Note: Indices in Lua start from 1!Count a table's elements: The size of a table in Lua is found with the operator #. For example, running #ao_is will return 3.Set a named element: Type ao_is["cool"] = true to add a new named key to the table. Named elements can also be accessed with the . operator (e.g. ao_is.cool), but only if the key is a valid identifier - for other keys like "my key", use brackets.Lua Wats.aos uses Lua because it is a simple, clean language that most experienced programmers can learn very quickly, and is an increasingly popular first programming language, too, thanks to its use in video games like Roblox.Nonetheless, there are a few things about the language that are prone to trip up rookie Lua builders. Tastes may vary, but here is our exhaustive list of Lua wat s:Remember: Table indexing starts from 1 not 0!Remember: 'Not equals' is expressed with ~=, rather than != or similar.Remember: Objects in Lua are called 'tables', rather than their more common names.Let's go!With this in mind, you now know everything you need in order to build awesome decentralized processes with Lua! In the next chapter we will begin to build parallel processes with Lua and aos.

---

# 36. Pretty  Cookbook

Document Number: 36
Source: https://cookbook_ao.arweave.net/guides/aos/modules/pretty.html
Words: 48
Quality Score: 0.493
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Pretty This module allows printing formatted, human-friendly and readable syntax.Module functions tprint() Returns a formatted string of the structure of the provided table.Parameters:tbl: {table} The table to format indent: {number} Optional indentation of each level of the table Returns: Table structure formatted as a string

---

# 37. aos Brief Tour  Cookbook

Document Number: 37
Source: https://cookbook_ao.arweave.net/concepts/tour.html
Words: 390
Quality Score: 0.492
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

aos Brief Tour Welcome to a quick tour of aos! This tutorial will walk you through the key global functions and variables available in the aos environment, giving you a foundational understanding of how to interact with and utilize aos effectively.1. Introduction to Inbox What It Is: Inbox is a Lua table that stores all messages received by your process but not yet handled.How to Use: Check Inbox to see incoming messages. Iterate through Inbox[x] to process these messages.2. Sending Messages with Send(Message) Functionality: Send(Message) is a global function to send messages to other processes.Usage Example: Send({Target = "...", Data = "Hello, Process!"}) sends a message with the data "Hello, Process!" to a specified process.3. Creating Processes with Spawn(Module, Message) Purpose: Use Spawn(Module, Message) to create new processes.Example: Spawn("MyModule", {Data = "Start"}) starts a new process using "MyModule" with the provided message.4. Understanding Name and Owner Name: A string set during initialization, representing the process's name.Owner: Indicates the owner of the process. Changing this might restrict your ability to interact with your process.Important Note: Treat these as read-only to avoid issues.5. Utilizing Handlers What They Are: Handlers is a table of helper functions for creating message handlers.Usage: Define handlers in Handlers to specify actions for different incoming messages based on pattern matching.6. Data Representation with Dump Function: Dump converts any Lua table into a print-friendly format.How to Use: Useful for debugging or viewing complex table structures. Example: Dump(Inbox) prints the contents of Inbox.7. Leveraging Utils Module Contents: Utils contains a collection of functional utilities like map, reduce, and filter.Usage: Great for data manipulation and functional programming patterns in Lua. For example, Utils.map(myTable, function(x) return x * 2 end) to double the values in a table.8. Exploring the ao Core Library Description: ao is a core module that includes key functions for message handling and process management.Key Features: Includes functions for sending messages (send) and spawning processes (spawn), along with environment variables.Conclusion This brief tour introduces you to the primary globals and functionalities within the aos environment. With these tools at your disposal, you can create and manage processes, handle messages, and utilize Lua's capabilities to build efficient and responsive applications on the aos platform. Experiment with these features to get a deeper understanding and to see how they can be integrated into your specific use cases. Happy coding in aos!

---

# 38. FAQ  Cookbook

Document Number: 38
Source: https://cookbook_ao.arweave.net/guides/aos/faq.html
Words: 179
Quality Score: 0.492
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content FAQ Ownership Understanding Process Ownership Start a new process with the aos console, the ownership of the process is set to your wallet address. aos uses the Owner global variable to define the ownership of the process. If you wish to transfer ownership or lock the process so that no one can own, you simply modify the Owner variable to another wallet address or set it to nil.JSON encoding data as json When sending data to another process or an external service, you may want to use JSON as a way to encode the data for recipients. Using the json module in lua, you can encode and decode pure lua tables that contain values.Send vs ao.send When to use Send vs ao.send Both functions send a message to a process, the difference is ao.send returns the message, in case you want to log it or troubleshoot. The Send function is intended to be used in the console for easier access. It is preferred to use ao.send in the handlers. But they are both interchangeable in aos.

---

# 39. Reading results from an ao Process  Cookbook

Document Number: 39
Source: https://cookbook_ao.arweave.net/guides/aoconnect/reading-results.html
Words: 136
Quality Score: 0.491
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Reading results from an ao Process In ao, messages produce results which are made available by Compute Units (CU's). Results are JSON objects consisting of the following fields: messages, spawns, output and error.Results are what the ao system uses to send messages and spawns that are generated by processes. A process can send a message just like you can as a developer, by returning messages and spawns in a result.You may want to access a result to dis the output generated by your message. Or you may want to see what messages etc., were generated. You do not need to take the messages and spawns from a result and send them yourself. They are automatically handled by Messenger Units (MU's). A call to results can also provide you paginated list of multiple results.

---

# 40. Bots and Games  Cookbook

Document Number: 40
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/index.html
Words: 176
Quality Score: 0.491
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Bots and Games NOTE Build your own unique bot to complete Quest 3 and earn 1000 CRED, then enter games like the Grid to earn legacynet CRED 24/7!Leveraging insights from our previous chapter, this section will guide you through the realm of automation with bots in aos and the construction of games. You will learn to create autonomous agents, using them to navigate and interact with game environments effectively.Sections Getting Started with a Game 0. # Let's A Game:Experience a game on aos Enhancing Game Interactions with Automation 1. # Interpreting Announcements:Interpret in-game announcements 2. # Fetching Game State:Retrieve and process the latest game state 3. # Strategic Decisions:Utilize automation to determine your next move 4. # Automated Responses:Streamline attack responses through automation 5. # Bringing it Together:Combine your skills to craft an autonomous agent Game Development Insights 6. # Mechanics of the Arena:Explore the underlying mechanics of a game's arena 7. # Expanding the Arena:Build unique game logic upon the arena A journey of discovery and creation awaits. Let the adventure begin!

---

# 41. Eval  Cookbook

Document Number: 41
Source: https://cookbook_ao.arweave.net/concepts/eval.html
Words: 81
Quality Score: 0.489
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Eval Each AO process includes an onboard Eval handler that evaluates any new code it receives. This handler determines the appropriate action for the code and verifies that the message originates from the process owner.The Eval handler can also be manually triggered to evaluate the Data field from an incoming message. When you use the .load function to load a file into a process, it relies on the Eval handler to evaluate the file’s content under the hood.

---

# 42. Introduction  Cookbook

Document Number: 42
Source: https://cookbook_ao.arweave.net/guides/aos/intro.html
Words: 524
Quality Score: 0.487
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Introduction aos introduces a new approach to building processes — asynchronous, parallel-executing smart contracts. The ao computer is a decentralized computer network that allows compute to run anywhere and aos in a unique, interactive shell. You can use aos as your personal operating system, your development environment for building ao processes, and your bot army.Lets go over some basic commands.Variables If you want to dis the contents of any variable through the console, simply type the variable name.luaName Inbox the Inbox is a collection of messages that your Process has received.luaInbox[1] If you want to get a count of messages, just add the # infront of Inbox.lua#Inbox The process of checking how many messages are in the inbox is a very common pattern. To make this easier, you can create a function that returns the number of messages within the inbox and diss it in the prompt.Use either .editor or .load file to load this function on your process.The Expected Results:Your prompt now has changed to include the number of messages in your inbox.INFO The Inbox is a Lua table (similar to an array) that contains messages received by your process that were not handled by any Handlers. The # operator is used to get the length of a table in Lua - so #Inbox returns the total number of unhandled messages currently in your inbox. This is a common Lua syntax pattern for getting the size/length of tables and strings.Globals In aos process there are some Globals that can make development a little more intuitive.Name Description Type Inbox This is a lua Table that stores all the messages that are received and not handlers by any handlers.Table(Array) Send(Message) This is a global function that is available in the interactive environment that allows you to send messages to Processes function Spawn(Module, Message) This is a global function that is available in the aos interactive environment that allows you to spawn processes Name a string that is set on init that describes the name of your process string Owner a string that is set on the init of the process that documents the owner of the process, warning if you change this value, it can brick you ability to interact with your process string Handlers a lua Table that contains helper functions that allows you to create handlers that execute functionality based on the pattern matching function on inbound messages table Dump a function that takes any lua Table and generates a print friendly output of the data function Utils a functional utility library with functions like map, reduce, filter module ao this is a core function library for sending messages and spawing processes module Modules In aos there are some built in common lua modules that are already available for you to work with, these modules can be referenced with a "require" function.Name Description json a json module that allows you to encode and decode json documents ao contains ao specific functions like send and spawn.base64 a base64 module that allows you to encode and decode base64 text.pretty a pretty print module using the function tprint to output formatted syntax.utils an utility function library

---

# 43. Lets Play A Game  Cookbook

Document Number: 43
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/ao-effect.html
Words: 645
Quality Score: 0.485
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Let's A Game!You've been powering through tutorials like a champ! Now, let's take a refreshing break and dive into something exciting. How about a game that adds a dash of fun to your learning journey? What's the game?ao-effect is a game where you can compete with friends or other ers globally, in real-time, right from your terminal. We've set up a global game process for this adventure.The rules are simple. Each er starts on a 40x40 grid with health at 100 and energy at 0. Your energy replenishes over time to a maximum of 100. Navigate the grid, find other ers, and use your energy to attack when they're within range. The battle continues until only one er remains or the allotted time expires.Checkout the guides on the Mechanics of the Arena and Expanding the Arena for a deeper understanding of the game.Heads Up: Don't sweat it if some command syntax seem unfamiliar. Focus on understanding the purpose of each command at a high level and, most importantly, enjoy the game!Preparing for an Adventure in ao-effect To join this global escapade, you'll need to set things up. Don't worry, it's as easy as 1-2-3!Install aos Fire up your terminal and run:Launch aos Next, create your instance of aos:bashaos Set Up the Game ID Let's keep our game server ID handy for quick access:Print Game Announcements Directly To Terminal (Optional) Here's how you can write a handler for printing announcement details:This is temporary as we will be loading this via a lua script in the next section.And voilà! You're all set to join the game.Ready to jump in? Just a few simple steps to get you going:All communication between processes in ao occurs through messages. To register, send this message to the game server:This places you in the Waiting Lobby. A small fee is needed to confirm your spot.Confirm your spot In order to confirm your spot you need some tokens. You can acquire them by sending the following message to the game:NOTE The .receive().Data will wait for a response by adding a temporary Handler that only runs once and will print the response Data. If you would like to instead just wait for the response to hit your Inbox you can call Send() without .receive() and run Inbox[#Inbox].Data to see the response Data.Handler added by .receive():Once you receive the tokens, confirm your spot by paying the game's entry fee like this:Wait for a few seconds, and you'll see live updates in your terminal about er payments and statuses.Let the Games Begin!Game Mechanics Game Start: The game begins after a 2-minute WaitTime if at least 2 ers have paid. Non-paying ers are removed. If not enough ers pay, those who did are refunded.ers spawn at a random grid point once the game begins.It's Your Move!Making a Move: The first thing you can do is move around, no energy required! You can shift one square in any direction – up, down, left, right, or diagonally. Along with the direction you must also pass in your er id to help the game identify your move. Here's how:The available moves across the grid are as follows:Keep in Mind: Directions are case sensitive!If you move off the grid, you'll pop up on the opposite side.Time to Strike!Launching an Attack: As the game progresses, you'll accumulate energy. Use it to attack other ers within a 3x3 grid range. Your attack won't hurt you, but it will affect others in range.Health starts at 100 and decreases with hits from other ers. Reach 0, and it's game over for you.Wrapping Up The game ends when there's one er left or time is up. Winners receive rewards, then it's back to the lobby for another round.Enjoyed the game? What if there was a way to make your experience even better or boost your odds of winning. Checkout the next guide to find out 🤔

---

# 44. Chatroom Blueprint  Cookbook

Document Number: 44
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/chatroom.html
Words: 167
Quality Score: 0.485
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Chatroom Blueprint The Chatroom Blueprint is a predesigned template that helps you quickly build a chatroom in ao. It is a great way to get started and can be customized to fit your needs.Unpacking the Chatroom Blueprint Members: The Members array is used to store the users who have registered to the chatroom.Register Handler: The register handler allows processes to join the chatroom. When a process sends a message with the tag Action = "Register", the handler will add the process to the Members array and send a message back to the process confirming the registration.Broadcast Handler: The broadcast handler allows processes to send messages to all the members of the chatroom. When a process sends a message with the tag Action = "Broadcast", the handler will send the message to all the members of the chatroom.How To Use:Open your preferred text editor.Open the Terminal.Start your aos process.Type in .load-blueprint chatroom Verify the Blueprint is Loaded:Type in Handlers.list to see the newly loaded handlers.

---

# 45. Using WeaveDrive  Cookbook

Document Number: 45
Source: https://cookbook_ao.arweave.net/guides/snacks/weavedrive.html
Words: 253
Quality Score: 0.481
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Using WeaveDrive WeaveDrive has been released on AO legacynet, which is great! But how to use it with your process? This post aims to provide a step by step guide on how to use WeaveDrive in your AOS process.The current availability time is called Assignments and this type puts WeaveDrive in a mode that allows you to define an Attestor wallet address when you create your AOS process. This will enable the process to load data from dataItems that have a Attestation created by this wallet.Prep Tutorial In order, to setup the tutorial for success we need to upload some data and upload an attestation. It will take a few minutes to get mined into a block on arweave.Install arx Create a wallet Create some data You should get a result like:Create Attestation It is important to copy the id of the uploaded dataItem, in the above case 9TIPJD2a4-IleOQJzRwPnDHO5DA891MWAyIdJJ1SiSk as your Message Value.👏 Awesome! That will take a few minutes to get mined on arweave, once it is mined then we will be able to read the data.html dataItem using WeaveDrive Enable WeaveDrive in a process Lets create a new AOS process with WeaveDrive enabled and the wallet we created above as an Attestor.NOTE: it is important to use the same wallet address that was used to sign the attestation data-item.NOTE: It does take a few minutes for the data to get 20 plus confirmations which is the threshold for data existing on arweave. You may want to go grab a coffee. ☕

---

# 46. Tokengating the Chatroom  Cookbook

Document Number: 46
Source: https://cookbook_ao.arweave.net/tutorials/begin/tokengating.html
Words: 493
Quality Score: 0.478
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Tokengating the Chatroom INFO Now that we've created a token and sent it to Trinity, we can use the token to tokengate our chatroom. This will allow only those who have the token to enter the chatroom.Video Tutorial How to Tokengate the Chatroom Let's create a handler that will allow us to tokengate the chatroom. This handler will respond to the tag Action = "Broadcast" meaning it will replace the original Broadcast handler we built for our chatroom.Step 1: Start the same aos process.Be sure you're using the same aos process that you've used throughout the tutorial.Step 2: Open the chatroom.lua file.This is the same file we used to create the chatroom during the chatroom tutorial.Step 3: Edit your Broadcast handler.Replace the original Broadcast handler with the following code:This handler will now check the balance of the sender's token before broadcasting the message to the chatroom. If the sender doesn't have a token, the message will not be broadcasted.Save the file.Step 4: Reload the chatroom.lua file.To replace the original broadcast handler with the new one, you'll need to reload the chatroom.lua file.lua.load chatroom.lua Step 5: Test the Tokengate Now that the chatroom is tokengated, let's test it by sending a message to the chatroom.From the original aos process First, we'll test it from the original aos process.Expected Results:Testing from another Process ID.From a new aos process Now, let's test it from a new aos process that doesn't have a token. The following command creates a new AO process with the name "chatroom-no-token".Next we need to register to the chatroom we built on our original process, from our new process. Hint: type ao.id into your console to get the Process ID of the process you are currently connected to.Expected Results:Now, let's try to send a message to the chatroom.Expected Results:As you can see, the message was not broadcasted because the new process doesn't have a token.Tell Trinity "It is done" From the original aos process, send a broadcast message to the chatroom saying, "It is done".WARNING It's important to be aware of exact match data and case sensitivity. If you're not receiving a response from either Morpheus or Trinity, be sure to check the the content of your Data and Tags.Trinity will then respond to the chatroom being tokengated.Expected Results:Trinity will send a message saying, "I guess Morpheus was right. You are the one. Consider me impressed. You are now ready to join The Construct, an exclusive chatroom available to only those that have completed this tutorial. Now, go join the others by using the same tag you used Register, with this process ID: [Construct Process ID] Good luck. -Trinity". Additionally, a footer will follow the message.Conclusion You've done it! You've successfully tokengated the chatroom. This has now unlocked access to the Construct, where only those that have fully completed this tutorial can enter.Congratulations!You've shown a great deal of promise. I hope you've enjoyed this tutorial. You're now ready to build freely in ao.

---

# 47. Units  Cookbook

Document Number: 47
Source: https://cookbook_ao.arweave.net/concepts/units.html
Words: 419
Quality Score: 0.477
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Units What is a Unit?The ao Computer is composed of three Unit types, each type contains a set of responsibilities for the computer. And each Unit is horizontally scalable.In ao we have the Messenger Unit or MU, and the Scheduler Unit or SU, and the Compute Unit or the CU. These units are the building blocks of the ao Computer Grid. There can be 1 or more of these units on the network and they work together to power the ao Operating System or aos. Messenger Unit - This unit is the front door to ao, it receives all the messages from the outside and as well as directs traffic flow for Processes. This traffic flow we call pushing. Each process can return an Outbox when it evaluates a Message, and this Outbox can be filled with Messages or requests to Spawn new processes, and the Messenger Unit is responsible for extracting these Messages from the Outbox and signing them and sending them to the Scheduler Units for processing. Scheduler Unit - The Scheduler unit is responsible for ordering the messages, and storing those messages on Arweave. It is important that every message is appropriately ordered so that the evaluation can be reed and verified. The Scheduler Unit is responsible for this process. It provides the abilty to query it via an endpoint to get the order of messages for evaluation. Compute Unit - The Compute unit is responsible for compute, this unit loads the binary module and manages the memory of that module, so that the execution of the process is alway running on the most up to date memory. The compute unit provides the results of the evaluation back to the the messenger unit, which can then push any messages in the outbox of the given process.Summary The ao Computer consists of three scalable unit types—Messenger Unit (MU), Scheduler Unit (SU), and Compute Unit (CU)—which form the foundation of the ao Computer. These units can exist in multiples on the network and collectively operate the ao Operating System (aos).The MU acts as the entry point, receiving external messages and managing process communications. It processes outgoing messages and spawn requests from process outboxes and forwards them to the SU.The SU ensures messages are properly sequenced and stored on Arweave, maintaining order for consistent re and verification of message evaluations.The CU handles computation, loading binary modules, and managing memory to ensure processes run with current data. It then returns the evaluation results to the MU for further message handling.

---

# 48. Calling DryRun  Cookbook

Document Number: 48
Source: https://cookbook_ao.arweave.net/guides/aoconnect/calling-dryrun.html
Words: 121
Quality Score: 0.475
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Calling DryRun DEPRECATION NOTICE This method of reading state is in the process of being deprecated for processes running on HyperBEAM. It is recommended to use the State Patching mechanism to expose state via HTTP for better performance, as calling dryrun was known to cause severe bottlenecks in web applications on legacynet.DryRun is the process of sending a message object to a specific process and getting the Result object back, but the memory is not saved, it is perfect to create a read message to return the current value of memory. For example, a balance of a token, or a result of a transfer, etc. You can use DryRun to obtain an output without sending an actual message.

---

# 49. Token Blueprint  Cookbook

Document Number: 49
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/token.html
Words: 972
Quality Score: 0.473
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Token Blueprint The Token Blueprint is a predesigned template that helps you quickly build a token in ao. It is a great way to get started and can be customized to fit your needs.Unpacking the Token Blueprint Balances: The Balances array is used to store the token balances of the participants.Info Handler: The info handler allows processes to retrieve the token parameters, like Name, Ticker, Logo, and Denomination.Balance Handler: The balance handler allows processes to retrieve the token balance of a participant.Balances Handler: The balances handler allows processes to retrieve the token balances of all participants.Transfer Handler: The transfer handler allows processes to send tokens to another participant.Mint Handler: The mint handler allows processes to mint new tokens.Total Supply Handler: The totalSupply handler allows processes to retrieve the total supply of the token.Burn Handler: The burn handler allows processes to burn tokens.How To Use:Open your preferred text editor.Open the Terminal.Start your aos process.Type in .load-blueprint token Verify the Blueprint is Loaded:Type in Handlers.list to see the newly loaded handlers.What's in the Token Blueprint:lualocal bint = require('.bint')(256)
--[[
This module implements the ao Standard Token Specification.
Terms:
Sender: the wallet or Process that sent the Message
It will first initialize the internal state, and then attach handlers,
according to the ao Standard Token Spec API:
- Info(): return the token parameters, like Name, Ticker, Logo, and Denomination
- Balance(Target?: string): return the token balance of the Target. If Target is not provided, the Sender
is assumed to be the Target
- Balances(): return the token balance of all participants
- Transfer(Target: string, Quantity: number): if the Sender has a sufficient balance, send the specified Quantity
to the Target. It will also issue a Credit-Notice to the Target and a Debit-Notice to the Sender
- Mint(Quantity: number): if the Sender matches the Process Owner, then mint the desired Quantity of tokens, adding
them the Processes' balance
]]
--
local json = require('json')
--[[
utils helper functions to remove the bint complexity.
]]
--
local utils = {
add = function(a, b)
return tostring(bint(a) + bint(b))
end,
subtract = function(a, b)
return tostring(bint(a) - bint(b))
end,
toBalanceValue = function(a)
return tostring(bint(a))
end,
toNumber = function(a)
return bint.tonumber(a)
end
}
--[[
Initialize State
ao.id is equal to the Process.Id
]]
--
Variant = "0.0.3"
-- token should be idempotent and not change previous state updates
Denomination = Denomination or 12
Balances = Balances or { [ao.id] = utils.toBalanceValue(10000 * 10 ^ Denomination) }
TotalSupply = TotalSupply or utils.toBalanceValue(10000 * 10 ^ Denomination)
Name = Name or 'Points Coin'
Ticker = Ticker or 'PNTS'
Logo = Logo or 'SBCCXwwecBlDqRLUjb8dYABExTJXLieawf7m2aBJ-KY'
--[[
Add handlers for each incoming Action defined by the ao Standard Token Specification
]]
--
--[[
Info
]]
--
Handlers.add('info', "Info", function(msg)
msg.reply({
Name = Name,
Ticker = Ticker,
Logo = Logo,
Denomination = tostring(Denomination)
})
end)
--[[
Balance
]]
--
Handlers.add('balance', "Balance", function(msg)
local bal = '0'
-- If not Recipient is provided, then return the Senders balance
if (msg.Tags.Recipient) then
if (Balances[msg.Tags.Recipient]) then
bal = Balances[msg.Tags.Recipient]
end
elseif msg.Tags.Target and Balances[msg.Tags.Target] then
bal = Balances[msg.Tags.Target]
elseif Balances[msg.From] then
bal = Balances[msg.From]
end
msg.reply({
Balance = bal,
Ticker = Ticker,
Account = msg.Tags.Recipient or msg.From,
Data = bal
})
end)
--[[
Balances
]]
--
Handlers.add('balances', "Balances",
function(msg) msg.reply({ Data = json.encode(Balances) }) end)
--[[
Transfer
]]
--
Handlers.add('transfer', "Transfer", function(msg)
assert(type(msg.Recipient) == 'string', 'Recipient is required!')
assert(type(msg.Quantity) == 'string', 'Quantity is required!')
assert(bint.__lt(0, bint(msg.Quantity)), 'Quantity must be greater than 0')
if not Balances[msg.From] then Balances[msg.From] = "0" end
if not Balances[msg.Recipient] then Balances[msg.Recipient] = "0" end
if bint(msg.Quantity) <= bint(Balances[msg.From]) then
Balances[msg.From] = utils.subtract(Balances[msg.From], msg.Quantity)
Balances[msg.Recipient] = utils.add(Balances[msg.Recipient], msg.Quantity)
--[[
Only send the notifications to the Sender and Recipient
if the Cast tag is not set on the Transfer message
]]
--
if not msg.Cast then
-- Debit-Notice message template, that is sent to the Sender of the transfer
local debitNotice = {
Action = 'Debit-Notice',
Recipient = msg.Recipient,
Quantity = msg.Quantity,
Data = Colors.gray ..
"You transferred " ..
Colors.blue .. msg.Quantity .. Colors.gray .. " to " .. Colors.green .. msg.Recipient .. Colors.reset
}
-- Credit-Notice message template, that is sent to the Recipient of the transfer
local creditNotice = {
Target = msg.Recipient,
Action = 'Credit-Notice',
Sender = msg.From,
Quantity = msg.Quantity,
Data = Colors.gray ..
"You received " ..
Colors.blue .. msg.Quantity .. Colors.gray .. " from " .. Colors.green .. msg.From .. Colors.reset
}
-- Add forwarded tags to the credit and debit notice messages
for tagName, tagValue in pairs(msg) do
-- Tags beginning with "X-" are forwarded
if string.sub(tagName, 1, 2) == "X-" then
debitNotice[tagName] = tagValue
creditNotice[tagName] = tagValue
end
end
-- Send Debit-Notice and Credit-Notice
msg.reply(debitNotice)
Send(creditNotice)
end
else
msg.reply({
Action = 'Transfer-Error',
['Message-Id'] = msg.Id,
Error = 'Insufficient Balance!'
})
end
end)
--[[
Mint
]]
--
Handlers.add('mint', "Mint", function(msg)
assert(type(msg.Quantity) == 'string', 'Quantity is required!')
assert(bint(0) < bint(msg.Quantity), 'Quantity must be greater than zero!')
if not Balances[ao.id] then Balances[ao.id] = "0" end
if msg.From == ao.id then
-- Add tokens to the token pool, according to Quantity
Balances[msg.From] = utils.add(Balances[msg.From], msg.Quantity)
TotalSupply = utils.add(TotalSupply, msg.Quantity)
msg.reply({
Data = Colors.gray .. "Successfully minted " .. Colors.blue .. msg.Quantity .. Colors.reset
})
else
msg.reply({
Action = 'Mint-Error',
['Message-Id'] = msg.Id,
Error = 'Only the Process Id can mint new ' .. Ticker .. ' tokens!'
})
end
end)
--[[
Total Supply
]]
--
Handlers.add('totalSupply', "Total-Supply", function(msg)
assert(msg.From ~= ao.id, 'Cannot call Total-Supply from the same process!')
msg.reply({
Action = 'Total-Supply',
Data = TotalSupply,
Ticker = Ticker
})
end)
--[[
Burn
]] --
Handlers.add('burn', 'Burn', function(msg)
assert(type(msg.Quantity) == 'string', 'Quantity is required!')
assert(bint(msg.Quantity) <= bint(Balances[msg.From]), 'Quantity must be less than or equal to the current balance!')
Balances[msg.From] = utils.subtract(Balances[msg.From], msg.Quantity)
TotalSupply = utils.subtract(TotalSupply, msg.Quantity)
msg.reply({
Data = Colors.gray .. "Successfully burned " .. Colors.blue .. msg.Quantity .. Colors.reset
})
end)

---

# 50. Tutorials  Cookbook

Document Number: 50
Source: https://cookbook_ao.arweave.net/tutorials/index.html
Words: 52
Quality Score: 0.467
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Tutorials Here, we've created a series of tutorials to help you get started with aos and build your first processes. These tutorials include interactive guides, code snippets, and examples to help you get comfortable with the aos environment.List of Tutorials Getting Started - An Interactive Guide Bots and Games

---

# 51. Community Resources  Cookbook

Document Number: 51
Source: https://cookbook_ao.arweave.net/references/community.html
Words: 177
Quality Score: 0.467
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Community Resources This page provides a comprehensive list of community resources, tools, guides, and links for the AO ecosystem.Core Resources Autonomous Finance Autonomous Finance is a dedicated research and technology entity, focusing on the intricacies of financial infrastructure within the ao network.BetterIdea Build faster, smarter, and more efficiently with BetterIDEa, the ultimate native web IDE for AO development 0rbit 0rbit provides any data from the web to an ao process by utilizing the power of ao, and 0rbit nodes. The user sends a message to the 0rbit ao, 0rbit nodes fetches the data and the user process receives the data.ArweaveHub A community platform for the Arweave ecosystem featuring events, developer resources, and discovery tools.AR.IO The first permanent cloud network built on Arweave, providing infrastructure for the permaweb with no 404s, no lost dependencies, and reliable access to applications and data through gateways, domains, and deployment tools.Developer Tools AO Package Manager Contributing Not seeing an AO Community Member or resource? Create an issue or submit a pull request to add it to this page: https://github.com/permaweb/ao-cookbook

---

# 52. Installing ao connect  Cookbook

Document Number: 52
Source: https://cookbook_ao.arweave.net/guides/aoconnect/installing-connect.html
Words: 46
Quality Score: 0.465
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Installing ao connect Prerequisites In order to install ao connect into your app you must have NodeJS/NPM 18 or higher. Installing npm yarn This module can now be used from NodeJS as well as a browser, it can be included as shown below.

---

# 53. Lua Optimization Guide for AO Platform  Cookbook

Document Number: 53
Source: https://cookbook_ao.arweave.net/references/lua-optimization.html
Words: 172
Quality Score: 0.461
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Lua Optimization Guide for AO Platform This guide provides practical tips for writing efficient, fast, and performant Lua code for on-chain programs on the AO platform.Table Operations Appending Elements Removing Elements Variable Access Local Variables Upvalues String Operations String Concatenation Pattern Matching Memory Management Table Reuse Minimize Garbage Creation lua-- ❌ Inefficient: Creates new response table on every transfer
local function createTransferResponse(sender, recipient, amount)
return {
from = sender,
to = recipient,
quantity = amount,
success = true,
newBalance = Balances[sender],
tags = {
Action = "Transfer-Complete",
Type = "Token"
}
}
end
-- ✅ Efficient: Reuse template table
local transferResponse = {
from = nil,
to = nil,
quantity = 0,
success = false,
newBalance = 0,
tags = {
Action = "Transfer-Complete",
Type = "Token"
}
}
local function createTransferResponse(sender, recipient, amount)
transferResponse.from = sender
transferResponse.to = recipient
transferResponse.quantity = amount
transferResponse.success = true
transferResponse.newBalance = Balances[sender]
return transferResponse
end Blockchain-Specific Optimizations State Management Additional Resources Lua Performance Guide Special thanks to @allquantor for sharing optimization tips

---

# 54. Meet Lua  Cookbook

Document Number: 54
Source: https://cookbook_ao.arweave.net/references/lua.html
Words: 293
Quality Score: 0.459
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Meet Lua Understanding Lua Background: Lua is a lightweight, high-level, multi-paradigm programming language designed primarily for embedded systems and clients. It's known for its efficiency, simplicity, and flexibility.Key Features: Lua offers powerful data description constructs, dynamic typing, efficient memory management, and good support for object-oriented programming.Setting Up Installation: Visit Lua's official website to download and install Lua.Environment: You can use a simple text editor and command line, or an IDE like ZeroBrane Studio or Eclipse with a Lua plugin.Basic Syntax and Concepts (in aos) Hello World:lua"Hello, World!" Variables and Types: Lua is dynamically typed. Basic types include nil, boolean, number, string, function, userdata, thread, and table.Control Structures: Includes if, while, repeat...until, and for.Functions: First-class citizens in Lua, supporting closures and higher-order functions.Tables: The only data structuring mechanism in Lua, which can be used to represent arrays, sets, records, etc.Hands-On Practice Experiment with Lua's Interactive Mode: Run aos in your terminal and start experimenting with Lua commands.Write Simple Scripts: Create .lua files and run them using the Lua interpreter. Use .load file.lua feature to upload lua code on your aos process.Resources Official Documentation: Lua 5.3 Reference Manual Online Tutorials: Websites like Learn Lua are great for interactive learning.Books: "Programming in Lua" (first edition available online) is a comprehensive resource.Community: Join forums or communities like Lua Users for support and discussions.Best Practices Keep It Simple: Lua is designed to be simple and flexible. Embrace this philosophy in your code.Performance: Learn about Lua's garbage collection and efficient use of tables.Integration: Consider how Lua can be embedded into other applications, particularly C/C++ projects.Conclusion Lua is a powerful language, especially in the context of embedded systems and game development. Its simplicity and efficiency make it a great choice for specific use cases. Enjoy your journey into Lua programming!

---

# 55. aos AO Operating System  Cookbook

Document Number: 55
Source: https://cookbook_ao.arweave.net/guides/aos/index.html
Words: 396
Quality Score: 0.458
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

aos: AO Operating System aos is a powerful operating system built on top of the AO hyper-parallel computer. While AO provides the distributed compute infrastructure, aos offers a simplified interface for interacting with and developing processes in this environment.What is aos?aos enables you to:Create and interact with processes on the AO network Develop distributed applications using a simple, intuitive approach Leverage the Lua programming language for deterministic, reliable operations All you need to get started is a terminal and a code editor. aos uses Lua as its primary language - a robust, deterministic, and user-friendly programming language that's ideal for distributed applications.New to AO? If you're just getting started, we recommend completing our tutorials first. They take just 15-30 minutes and provide an excellent foundation.Getting Started with aos Start here if you're new to aos:Introduction to aos - Overview of aos capabilities and concepts Installation Guide - Step-by-step instructions for setting up aos aos Command Line Interface - Learn to use the aos CLI effectively Customizing Your Prompt - Personalize your aos development environment Load Lua Files - Learn how to load and execute Lua files in aos Building a Ping-Pong Server - Create your first interactive aos application Blueprints Blueprints in aos are templates that streamline the development of distributed applications by providing a framework for creating consistent and efficient processes across the AO network.Available Blueprints Chatroom - Template for building chatroom applications Cred Utils - Tools for managing credentials Staking - Framework for implementing staking mechanisms Token - Guide for creating and managing tokens Voting - Blueprint for setting up voting systems aos Modules aos includes several built-in modules for common operations:JSON Module - Parse and generate JSON data AO Module - Interface with the AO ecosystem Crypto Module - Perform cryptographic operations Base64 Module - Encode and decode Base64 data Pretty Module - Format data for easier reading Utils Module - Common utility functions Developer Resources More advanced topics for aos development:Editor Setup & Configuration - Configure your development environment Understanding the Inbox & Message Handlers - Learn how message handling works Troubleshooting with ao.link - Debug aos applications Frequently Asked Questions - Find answers to common questions Build a Token - Create your own token on AO Use the sidebar to browse through specific aos guides. For a more structured learning path, we recommend following the guides in the order listed above.

---

# 56. ao Module  Cookbook

Document Number: 56
Source: https://cookbook_ao.arweave.net/references/ao.html
Words: 590
Quality Score: 0.458
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

ao Module version: 0.0.3 ao process communication is handled by messages, each process receives messages in the form of ANS-104 DataItems, and needs to be able to do the following common operations.ao.send(msg) - send message to another process ao.spawn(module, msg) - spawn a process The goal of this library is to provide this core functionality in the box of the ao developer toolkit. As a developer you have the option to leverage this library or not, but it integrated by default.Properties Name Description Type id Process Identifier (TxID) string module Module Identifier (TxID) string authorities Set of Trusted TXs string Authority Identifiers that the process is able to accept transactions from that are not the owner or the process (0-n) string _version The version of the library string reference Reference number of the process number env Evaluation Environment object outbox Holds Messages and Spawns for response object assignables List of assignables of the process list nonExtractableTags List of non-extractable tags of the process list nonForwardableTags List of non-forwardable tags of the process list init Initializes the AO environment function send Sends a message to a target process function assign Assigns a message to the process function spawn Spawns a process function result Returns the result of a message function isTrusted Checks if a message is trusted function isAssignment Checks if a message is an assignment function isAssignable Checks if a message is assignable function addAssignable Adds an assignable to the assignables list function removeAssignable Removes an assignable from the assignables list function clearOutbox Clears the outbox function normalize Normalizes a message by extracting tags function sanitize Sanitizes a message by removing non-forwardable tags function clone Clones a table recursively function Environment Schema The ao.env variable contains information about the initializing message of the process. It follows this schema:Example Methods ao.send(msg: Message) Takes a Message as input. The function adds ao -specific tags and stores the message in ao.outbox.Messages.Example ao.spawn(module: string, spawn: Spawn) Takes a module ID string and Spawn as input. Returns a Spawn table with a generated Ref tag.Example ao.assign(assignment: Assignment) Takes an Assignment as input. Adds the assignment to ao.outbox.Assignments.Example ao.result(result: Result) Takes a Result as input. Returns the final process execution result.Example ao.isAssignable(msg: Message) Takes a Message as input. Returns true if the message matches a pattern in ao.assignables.Example ao.isAssignment(msg: Message) Takes a Message as input. Returns true if the message is assigned to a different process.Example ao.addAssignable(name: string, condition: function) Adds a named condition function to the process's list of assignables. Messages matching any condition will be accepted when assigned.Note: The condition parameter uses a similar pattern matching approach as the pattern parameter in Handlers.add(). For more advanced pattern matching techniques, see the Handlers Pattern Matching documentation.Example ao.removeAssignable(name: string) Removes a previously added assignable condition from the process's list of assignables.Example luaao.removeAssignable("allowArDrive") ao.isTrusted(msg: Message) Takes a Message as input. Returns true if the message is from a trusted source.Example Custom ao Table Structures Used by: ao.send(), ao.spawn(), ao.normalize(), ao.sanitize() All of the below syntaxes are valid, but each syntax gets converted to { name = string, value = string } tables behind the scenes. We use alternative 1 throughout the documentation for brevity and consistency.Root-level Tag Conversion Any keys in the root message object that are not one of: Target, Data, Anchor, Tags, or From will automatically be converted into Tags using the key as the tag name and its value as the tag value.Message Used by: ao.send(), ao.isTrusted(), ao.isAssignment(), ao.isAssignable(), ao.normalize(), ao.sanitize() Spawn Used by: ao.spawn() Assignment Used by: ao.assign(), ao.result() Result Used by: ao.result()

---

# 57. Messaging Patterns in ao  Cookbook

Document Number: 57
Source: https://cookbook_ao.arweave.net/references/messaging.html
Words: 658
Quality Score: 0.457
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Messaging Patterns in ao This reference guide explains the messaging patterns available in ao and when to use each one.Quick Reference: Choosing the Right Pattern If you need to...Process Flow Key function(s) Send a message without waiting for a response A → B ao.send Send a message and wait for a response A → B → A ao.send().receive() Process messages and respond to the sender B → A Handlers.add + msg.reply Create a chain of processing services A → B → C → A msg.forward + ao.send().receive() Wait for any matching message regardless of sender Any → A Receive (capital R) Create a standard automated response B → A Handlers.utils.reply Sending Messages ao.send: Asynchronous Message Sending Non-blocking direct A → B messaging that returns immediately after sending.Use for fire-and-forget notifications or starting async conversations Returns a promise-like object that can be chained with .receive() if needed Good for parallel processing since it doesn't block execution Basic Send Example:msg.reply: Asynchronous Response Sending Non-blocking B → A response with automatic reference tracking. Used within handlers to respond to incoming messages.Automatically links response to original message via X-Reference Enables asynchronous request-response patterns Automatically sets Target to the original sender or Reply-To address if specified Handler Reply Example:msg.forward: Message Forwarding Non-blocking multi-process routing for A → B → C → A patterns. Creates a sanitized copy of the original message.Takes a target and a partial message to overwrite forwarded message fields Preserves Reply-To and X-Reference properties for complete message tracking Sets X-Origin to original sender, enabling final service to reply directly to originator Multi-Process Pipeline Example:lua-- In client process
local middlewareProcessId = "process-123"
local finalProcessId = "process-456"
-- Send to middleware and wait for response from final service
local response = ao.send({
Target = middlewareProcessId,
Action = "Transform",
Data = "raw-data"
}).receive(finalProcessId) -- Explicitly wait for response from final service
-- In middleware service
Handlers.add("transform-middleware",
{ Action = "Transform" },
function(msg)
local finalProcessId = "process-456"
msg.forward(finalProcessId, {
Data = msg.Data .. " (pre-processed)",
Action = "Transform-Processed"
})
end
)
-- In final service
Handlers.add("final-processor",
{ Action = "Transform-Processed" },
function(msg)
-- No need to know the client ID - it's stored in X-Origin
msg.forward(msg['X-Origin'], {
Data = msg.Data .. " (final processing complete)",
Action = "Transform-Complete"
})
end
) Handlers.utils.reply: Simple Reply Handler Creation Creates a handler function that automatically replies with a fixed response. A wrapper around msg.reply for common use cases.Simple String Response Example:Message Table Response Example:Receiving Messages Receive (Capital R): Blocking Pattern Matcher Blocks execution until any matching message arrives from any sender. Under the hood, this is implemented using Handlers.once, making it a one-time pattern matcher that automatically removes itself after execution.Waits for any message matching the pattern, regardless of origin Use for synchronous message processing flows or event listening Automatically removes the handler after first match (using Handlers.once internally) Message Pattern Matching Example:ao.send().receive (Lowercase r): Blocking Reference Matcher Blocks execution until a specific reply arrives, enabling A → B → A and A → B → C → A request-response cycles.Only matches messages linked by X-Reference Can specify a target process ID to indicate which process will reply Implicitly waits for the proper response based on message reference chains For A → B → A flows, process B uses msg.reply For A → B → C → A flows, processes B and C use msg.forward Basic Request-Response Example:Message Properties The following properties track message chains and ensure proper routing:Reference: Unique identifier automatically assigned to each message.Reply-To: Specifies the destination for responses.X-: Any property starting with X- denotes a 'forwarded' tag and is automatically managed by the system. X-Reference: Maintains the conversation chain across replies and forwards.X-Origin: Tracks the conversation originator.The system automatically manages these properties when using msg.reply and msg.forward. Check out the source code to see exactly how these properties are managed.Blocking vs. Non-Blocking Functions either your code or let it continue running:Non-blocking (ao.send, msg.reply, msg.forward): Send and continue execution Blocking (Receive, .receive()): until response arrives

---

# 58. Introduction to AO-Core  Cookbook

Document Number: 58
Source: https://cookbook_ao.arweave.net/welcome/ao-core-introduction.html
Words: 330
Quality Score: 0.456
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Introduction to AO-Core AO-Core is a protocol and standard for distributed computation that forms the foundation of the AO computer. Inspired by and built upon concepts from the Erlang language, AO-Core embraces the actor model for concurrent, distributed systems. Unlike traditional blockchain systems, AO-Core defines a flexible, powerful computation protocol that enables a wide range of applications beyond just running Lua programs.What is AO-Core?AO-Core is the fundamental protocol of the AO computer that:Defines standards for trustless computation distributed across the world Provides mathematical guarantees about program execution Enables composable, modular development through devices Supports various execution environments beyond just Lua Implements the actor model for concurrent, message-passing computation The Actor Model in AO AO references the actor model of computation where:Each actor (or process) is an independent unit of computation Actors communicate exclusively through message passing Actors can create other actors, send messages, and make local decisions The system is inherently concurrent and distributed This approach, inspired by Erlang, provides natural scalability and resilience in distributed systems.Key Features of AO-Core Resilient: There is no single point of failure. AO-Core exists across many machines distributed worldwide, making it immune to physical destruction or tampering.Permanent: Computations following the AO-Core protocol are stored permanently on Arweave, allowing you to recall and continue your work at any time.Permissionless: No registration is required to use AO-Core. Your right to use it is guaranteed by the underlying protocol.Trustless: The state of your computations is mathematically guaranteed, allowing you to build services that don't require trust in any central authority.Beyond Just Processes While AO Processes (smart contracts built using the AO-Core protocol) are powerful for creating autonomous agents, AO-Core itself enables much more:Serverless functions with trustworthy guarantees Hybrid applications combining smart contract and serverless functionality Custom execution environments through different devices Composable systems using the path language In the following sections, we'll explore how AO Processes build on top of the AO-Core protocol, and how you can get started building your own applications in this powerful environment.

---

# 59. ao Specs  Cookbook

Document Number: 59
Source: https://cookbook_ao.arweave.net/concepts/specs.html
Words: 148
Quality Score: 0.456
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content ao Specs What is ao?The ao computer is the actor oriented machine that emerges from the network of nodes that adhere to its core data protocol, running on the Arweave network. This document gives a brief introduction to the protocol and its functionality, as well as its technical details, such that builders can create new implementations and services that integrate with it.The ao computer is a single, unified computing environment (a Single System Image), hosted on a heterogenous set of nodes in a distributed network. ao is designed to offer an environment in which an arbitrary number of parallel processes can be resident, coordinating through an open message passing layer. This message passing standard connects the machine's independently operating processes together into a 'web' -- in the same way that websites operate on independent servers but are conjoined into a cohesive, unified experience via hyperlinks.

---

# 60. Voting Blueprint  Cookbook

Document Number: 60
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/voting.html
Words: 340
Quality Score: 0.452
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Voting Blueprint The Voting Blueprint is a predesigned template that helps you quickly build a voting system in ao. It is a great way to get started and can be customized to fit your needs.Prerequisites The Staking Blueprint requires the Token Blueprint to be loaded, first.Unpacking the Voting Blueprint Balances: The Balances array is used to store the token balances of the participants.Votes: The Votes array is used to store the votes of the participants.Vote Action Handler: The vote handler allows processes to vote. When a process sends a message with the tag Action = "Vote", the handler will add the vote to the Votes array and send a message back to the process confirming the vote.Finalization Handler: The finalize handler allows processes to finalize the voting process. When a process sends a message with the tag Action = "Finalize", the handler will process the votes and finalize the voting process.How To Use:Open your preferred text editor.Open the Terminal.Start your aos process.Type in .load-blueprint voting Verify the Blueprint is Loaded:Type in Handlers.list to see the newly loaded handlers.What's in the Voting Blueprint:luaBalances = Balances or {}
Votes = Votes or {}
-- Vote Action Handler
Handlers.vote = function(msg)
local quantity = Stakers[msg.From].amount
local target = msg.Tags.Target
local side = msg.Tags.Side
local deadline = tonumber(msg['Block-Height']) + tonumber(msg.Tags.Deadline)
assert(quantity > 0, "No staked tokens to vote")
Votes[target] = Votes[target] or { yay = 0, nay = 0, deadline = deadline }
Votes[target][side] = Votes[target][side] + quantity
end
-- Finalization Handler
local finalizationHandler = function(msg)
local currentHeight = tonumber(msg['Block-Height'])
-- Process voting
for target, voteInfo in pairs(Votes) do
if currentHeight >= voteInfo.deadline then
if voteInfo.yay > voteInfo.nay then
print("Handle Vote")
end
-- Clear the vote record after processing
Votes[target] = nil
end
end
end
-- wrap function to continue handler flow
local function continue(fn)
return function (msg)
local result = fn(msg)
if (result) == -1 then
return 1
end
return result
end
end
Handlers.add("vote",
continue(Handlers.utils.hasMatchingTag("Action", "Vote")), Handlers.vote)
-- Finalization handler should be called for every message
Handlers.add("finalize", function (msg) return -1 end, finalizationHandler)

---

# 61. ao Token and Subledger Specification  Cookbook

Document Number: 61
Source: https://cookbook_ao.arweave.net/references/token.html
Words: 1111
Quality Score: 0.452
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

ao Token and Subledger Specification Status: DRAFT-1 Targeting Network: ao.TN.1 This specification describes the necessary message handlers and functionality required for a standard ao token process. Implementations of this standard typically offer users the ability to control a transferrable asset, whose scarcity is maintained by the process.Each compliant process will likely implement a ledger of balances in order to encode ownership of the asset that the process represents. Compliant processes have a set of methods that allow for the modification of this ledger, typically with safe-guards to ensure the scarcity of ownership of the token represented by the process.Additionally, this specification describes a 'subledger' process type which, when implemented, offers the ability to split move a number of the tokens from the parent into a child process that implements the same token interface specification. If the From-Module of the subledger process is trusted by the participants, these subledgers can be used to transact in the 'source' token, without directly exchanging messages with it. This allows participants to use the tokens from a process, even if that process is congested. Optionally, if the participants trust the Module a subledger process is running, they are able to treat balances across these processes as fungible. The result of this is that an arbitrary numbers of parallel processes -- and thus, transactions -- can be processed by a single token at any one time.Token Processes A specification-compliant token process responds to a number of different forms of messages, with each form specified in an Action tag. The full set of Action messages that the token must support are as follows:Name Description Read-Only Balance get the balance of an identifier ✔️ Balances get a list of all ledger/account balances ✔️ Transfer send 1 or more units from the callers balance to one or move targets with the option to notify targets ❌ Mint if the ledger process is the root and you would like to increase token supply ❌ In the remainder of this section the tags necessary to spawn a compliant token process, along with the form of each of the Action messages and their results is described.Spawning Parameters Every compliant token process must carry the following immutable parameters upon its spawning message:Tag Description Optional?Name The title of the token, as it should be dised to users.✔️ Ticker A suggested shortened name for the token, such that it can be referenced quickly.✔️ Logo An image that applications may desire to show next to the token, in order to make it quickly visually identifiable.✔️ Denomination The number of the token that should be treated as a single unit when quantities and balances are dised to users.❌ Messaging Protocol Balance(Target?: string) Returns the balance of a target, if a target is not supplied then the balance of the sender of the message must be returned.Example Action message:Example response message:Balances() Returns the balance of all participants in the token.Example response message:Transfer(Target, Quantity) If the sender has a sufficient balance, send the Quantity to the Target, issuing a Credit-Notice to the recipient and a Debit-Notice to the sender. The Credit- and Debit-Notice should forward any and all tags from the original Transfer message with the X- prefix. If the sender has an insufficient balance, fail and notify the sender.If a successful transfer occurs a notification message should be sent if Cast is not set.Recipients will infer from the From-Process tag of the message which tokens they have received.Get-Info() Mint() [optional] Implementing a Mint action gives the process a way of allowing valid participants to create new tokens.Subledger Processes In order to function appropriately, subledgers must implement the full messaging protocol of token contracts (excluding the Mint action). Subledgers must also implement additional features and spawn parameters for their processes. These modifications are described in the following section.Spawning Parameters Every compliant subledger process must carry the following immutable parameters upon its spawning message:Tag Description Optional?Source-Token The ID of the top-most process that this subledger represents.❌ Parent-Token The ID of the parent process that this subledger is attached to.❌ Credit-Notice Handler Upon receipt of a Credit-Notice message, a compliant subledger process must check if the process in question is the Parent-Token. If it is, the subledger must increase the balance of the Sender by the specified quantity.Transfer(Target, Quantity) In addition to the normal tags that are passed in the Credit-Notice message to the recipient of tokens, a compliant subledger process must also provide both of the Source-Token and Parent-Token values. This allows the recipient of the Transfer message -- if they trust the Module of the subledger process -- to credit a receipt that is analogous (fungible with) deposits from the Source-Token.The modified Credit-Notice should be structured as follows:Withdraw(Target?, Quantity) All subledgers must allow balance holders to withdraw their tokens to the parent ledger. Upon receipt of an Action: Withdraw message, the subledger must send an Action message to its Parent-Ledger, transferring the requested tokens to the caller's address, while debiting their account locally. This transfer will result in a Credit-Notice from the Parent-Ledger for the caller.Token Example NOTE: When implementing a token it is important to remember that all Tags on a message MUST be "string"s. Using the tostring function you can convert simple types to strings.luaif not balances then
balances = { [ao.id] = 100000000000000 }
end
if name ~= "Fun Coin" then
name = "Fun Coin"
end
if ticker ~= "Fun" then
ticker = "fun"
end
if denomination ~= 6 then
denomination = 6
end
-- handlers that handler incoming msg
Handlers.add(
"Transfer",
Handlers.utils.hasMatchingTag("Action", "Transfer"),
function (msg)
assert(type(msg.Tags.Recipient) == 'string', 'Recipient is required!')
assert(type(msg.Tags.Quantity) == 'string', 'Quantity is required!')
if not balances[msg.From] then
balances[msg.From] = 0
end
if not balances[msg.Tags.Recipient] then
balances[msg.Tags.Recipient] = 0
end
local qty = tonumber(msg.Tags.Quantity)
assert(type(qty) == 'number', 'qty must be number')
-- handlers.utils.reply("Transferring qty")(msg)
if balances[msg.From] >= qty then
balances[msg.From] = balances[msg.From] - qty
balances[msg.Tags.Recipient] = balances[msg.Tags.Recipient] + qty
ao.send({
Target = msg.From,
Tags = {
["Action"] = "Debit-Notice",
["Quantity"] = tostring(qty)
}
})
ao.send({
Target = msg.Tags.Recipient,
Tags = {
["Action"] = "Credit-Notice",
["Quantity"] = tostring(qty)
}
})
-- if msg.Tags.Cast and msg.Tags.Cast == "true" then
-- return
-- end
end
end
)
Handlers.add(
"Balance",
Handlers.utils.hasMatchingTag("Action", "Balance"),
function (msg)
assert(type(msg.Tags.Target) == "string", "Target Tag is required!")
local bal = "0"
if balances[msg.Tags.Target] then
bal = tostring(balances[msg.Tags.Target])
end
ao.send({
Target = msg.From,
Tags = {
["Balance"] = bal,
["Ticker"] = ticker or ""
}
})
end
)
local json = require("json")
Handlers.add(
"Balances",
Handlers.utils.hasMatchingTag("Action", "Balances"),
function (msg)
ao.send({
Target = msg.From,
Data = json.encode(balances)
})
end
)
Handlers.add(
"Info",
Handlers.utils.hasMatchingTag("Action", "Info"),
function (msg)
ao.send({
Target = msg.From,
Tags = {
["Name"] = name,
["Ticker"] = ticker,
["Denomination"] = tostring(denomination)
}
})
end
)

---

# 62. Spawning a Process  Cookbook

Document Number: 62
Source: https://cookbook_ao.arweave.net/guides/aoconnect/spawning-processes.html
Words: 160
Quality Score: 0.451
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Spawning a Process A deep dive into the concept of Processes can be found in the ao Processes concept. This guide focuses on using ao connect to spawn a Process.In order to spawn a Process you must have the TxID of an ao Module that has been uploaded to Arweave. The Module is the source code for the Process. The Process itself is an instantiation of that source.You must also have the wallet address of a Scheduler Unit (SU). This specified SU will act as the scheduler for this Process. This means that all nodes in the system can tell that they need to read and write to this SU for this Process. You can use the address below.Wallet address of an available Scheduler lua_GQ33BkPtZrqxA84vM8Zk-N2aO0toNNu_C-l-rawrBA In addition, in order to receive messages from other processes an Authority tag must be supplied with the wallet address of an authorised Messaging Unit (MU).Wallet address of the legacynet MU luafcoN_xJeisVsPXA-trzVAuIiqO3ydLQxM-L4XbrQKzY

---

# 63. LLMs Documentation  Cookbook

Document Number: 63
Source: https://cookbook_ao.arweave.net/llms-explanation.html
Words: 84
Quality Score: 0.450
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content LLMs Documentation llms.txt:Structured overview of the ao ecosystem.Ideal for AI tools navigating documentation or answering general questions.Suited for agents with web search capabilities.llms-full.txt:Complete technical documentation.Designed for in-depth analysis, troubleshooting, or chatbot integration.Provides exhaustive details for complex queries.INFO The llms-full.txt file only contains content from references and release notes, as testing showed this focused approach performs better with current AI models.Permaweb LLMs.txt:The following is a tool that allows you to build your own LLMs.txt files based on docs from the permaweb ecosystem.

---

# 64. Mechanics of the Arena  Cookbook

Document Number: 64
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/arena-mechanics.html
Words: 1908
Quality Score: 0.448
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Mechanics of the Arena This guide provides a comprehensive overview of the fundamental mechanics essential for designing and managing arena-style games in aos. In arena games, participants engage in rounds, strategically vying to eliminate each other until a sole victor emerges.The framework presented here lays the groundwork for crafting a wide range of games, all sharing the same core functionalities. Explore the intricacies of game development and unleash your creativity within this versatile arena.Core Functionalities Now, let's dive into the core functionalities that power arena-style games:Game Progression Modes:Arena games are structured into rounds that operate in a loop with the following progression modes: "Not-Started" → "Waiting" → "ing" → [Someone wins or timeout] → "Waiting"...NOTE The loop timesout if there are not enough ers to start a game after the waiting state.Rounds offer a defined timeframe for ers to engage, intensifying the excitement of game.Token Stakes:ers must deposit a specified quantity of tokens (defined by PaymentQty) to participate in the game. These tokens add a tangible stake element to the game.Bonus Rewards:Beyond the thrill of victory, ers are enticed by the prospect of extra rewards. The builder has the flexibility to offer bonus tokens, defined by BonusQty, to be distributed per round. Any bets placed by ers are also added to these bonuses. These bonuses serve as an additional incentive, enhancing the competitive spirit of the game.er Management:ers waiting to join the next game are tracked in the Waiting table.Active ers and their game states are stored in the ers table.Eliminated ers are promptly removed from the ers table and placed in the Waiting table for the next game.Round Winner Reward:When a er eliminates another, they earn not only bragging rights but also the eliminated er's deposit tokens as a reward. Additionally, winners of each round share a portion of the bonus tokens, as well as their original stake, further motivating ers to strive for victory.Listener Mode:For those who prefer to watch the action unfold, the "Listen" mode offers an opportunity to stay informed without active participation. Processes can register as listeners, granting them access to all announcements from the game. While they do not engage as ers, listeners can continue to observe the game's progress unless they explicitly request removal.Game State Management:To maintain the flow and fairness of arena games, an automated system oversees game state transitions. These transitions encompass waiting, ing, and ending phases. Time durations for each state, such as WaitTime and GameTime, ensure that rounds adhere to defined timeframes, preventing games from lasting indefinitely.You can refer to the code for the arena in the dropdown below:Arena Game Blueprint lua-- ARENA GAME BLUEPRINT.
-- This blueprint provides the framework to operate an 'arena' style game
-- inside an ao process. Games are ed in rounds, where ers aim to
-- eliminate one another until only one remains, or until the game time
-- has elapsed. The game process will rounds indefinitely as ers join
-- and leave.
-- When a er eliminates another, they receive the eliminated er's deposit token
-- as a reward. Additionally, the builder can provide a bonus of these tokens
-- to be distributed per round as an additional incentive. If the intended
-- er type in the game is a bot, providing an additional 'bonus'
-- creates an opportunity for coders to 'mine' the process's
-- tokens by competing to produce the best agent.
-- The builder can also provide other handlers that allow ers to perform
-- actions in the game, calling 'eliminateer()' at the appropriate moment
-- in their game logic to control the framework.
-- Processes can also register in a 'Listen' mode, where they will receive
-- all announcements from the game, but are not considered for entry into the
-- rounds themselves. They are also not unregistered unless they explicitly ask
-- to be.
-- GLOBAL VARIABLES.
-- Game progression modes in a loop:
-- [Not-Started] -> Waiting -> ing -> [Someone wins or timeout] -> Waiting...
-- The loop is broken if there are not enough ers to start a game after the waiting state.
GameMode = GameMode or "Not-Started"
StateChangeTime = StateChangeTime or undefined
-- State durations (in milliseconds)
WaitTime = WaitTime or 2 * 60 * 1000 -- 2 minutes
GameTime = GameTime or 20 * 60 * 1000 -- 20 minutes
Now = Now or undefined -- Current time, updated on every message.
-- Token information for er stakes.
UNIT = 1000
PaymentToken = PaymentToken or "ADDR" -- Token address
PaymentQty = PaymentQty or tostring(math.floor(UNIT)) -- Quantity of tokens for registration
BonusQty = BonusQty or tostring(math.floor(UNIT)) -- Bonus token quantity for winners
-- ers waiting to join the next game and their payment status.
Waiting = Waiting or {}
-- Active ers and their game states.ers = ers or {}
-- Number of winners in the current game.
Winners = 0
-- Processes subscribed to game announcements.
Listeners = Listeners or {}
-- Minimum number of ers required to start a game.
Minimumers = Minimumers or 2
-- Default er state initialization.erInitState = erInitState or {}
-- Sends a state change announcement to all registered listeners.
-- @param event: The event type or name.
-- @param description: Description of the event.
function announce(event, description)
for ix, address in pairs(Listeners) do
ao.send({
Target = address,
Action = "Announcement",
Event = event,
Data = description
})
end
return print(Colors.gray .. "Announcement: " .. Colors.red .. event .. " " .. Colors.blue .. description .. Colors.reset)
end
-- Sends a reward to a er.
-- @param recipient: The er receiving the reward.
-- @param qty: The quantity of the reward.
-- @param reason: The reason for the reward.
function sendReward(recipient, qty, reason)
if type(qty) ~= number then
qty = tonumber(qty)
end
ao.send({
Target = PaymentToken,
Action = "Transfer",
Quantity = tostring(qty),
Recipient = recipient,
Reason = reason
})
return print(Colors.gray .. "Sent Reward: " ..
Colors.blue .. tostring(qty) ..
Colors.gray .. ' tokens to ' ..
Colors.green .. recipient .. " " ..
Colors.blue .. reason .. Colors.reset
)
end
-- Starts the waiting period for ers to become ready to .
function startWaitingPeriod()
GameMode = "Waiting"
StateChangeTime = Now + WaitTime
announce("Started-Waiting-Period", "The game is about to begin! Send your token to take part.")
print('Starting Waiting Period')
end
-- Starts the game if there are enough ers.
function startGamePeriod()
local paiders = 0
for er, hasPaid in pairs(Waiting) do
if hasPaid then
paiders = paiders + 1
end
end
if paiders < Minimumers then
announce("Not-Enough-ers", "Not enough ers registered! Restarting...")
for er, hasPaid in pairs(Waiting) do
if hasPaid then
Waiting[er] = false
sendReward(er, PaymentQty, "Refund")
end
end
startWaitingPeriod()
return
end
LastTick = undefined
GameMode = "ing"
StateChangeTime = Now + GameTime
for er, hasPaid in pairs(Waiting) do
if hasPaid theners[er] = erInitState()
else
ao.send({
Target = er,
Action = "Ejected",
Reason = "Did-Not-Pay"
})
removeListener(er) -- Removing er from listener if they didn't pay
end
end
announce("Started-Game", "The game has started. Good luck!")
print("Game Started....")
end
-- Handles the elimination of a er from the game.
-- @param eliminated: The er to be eliminated.
-- @param eliminator: The er causing the elimination.
function eliminateer(eliminated, eliminator)
sendReward(eliminator, PaymentQty, "Eliminated-er")
Waiting[eliminated] = falseers[eliminated] = nil
ao.send({
Target = eliminated,
Action = "Eliminated",
Eliminator = eliminator
})
announce("er-Eliminated", eliminated .. " was eliminated by " .. eliminator .. "!")
local erCount = 0
for er, _ in pairs(ers) doerCount = erCount + 1
end
print("Eliminating er: " .. eliminated .. " by: " .. eliminator) -- Useful for tracking eliminations
if erCount < Minimumers then
endGame()
end
end
-- Ends the current game and starts a new one.
function endGame()
print("Game Over")
Winners = 0
Winnings = tonumber(BonusQty) / Winners -- Calculating winnings per er
for er, _ in pairs(ers) do
Winners = Winners + 1
end
Winnings = tonumber(BonusQty) / Winners
for er, _ in pairs(ers) do
-- addLog("EndGame", "Sending reward of:".. Winnings + PaymentQty .. "to er: " .. er) -- Useful for tracking rewards
sendReward(er, Winnings + tonumber(PaymentQty), "Win")
Waiting[er] = false
enders = {}
announce("Game-Ended", "Congratulations! The game has ended. Remaining ers at conclusion: " .. Winners .. ".")
startWaitingPeriod()
end
-- Removes a listener from the listeners' list.
-- @param listener: The listener to be removed.
function removeListener(listener)
local idx = 0
for i, v in ipairs(Listeners) do
if v == listener then
idx = i
break
end
end
if idx > 0 then
table.remove(Listeners, idx)
end
end
-- HANDLERS: Game state management
-- Handler for cron messages, manages game state transitions.
Handlers.add(
"Game-State-Timers",
function(Msg)
return "continue"
end,
function(Msg)
Now = Msg.Timestamp
if GameMode == "Not-Started" then
startWaitingPeriod()
elseif GameMode == "Waiting" then
if Now > StateChangeTime then
startGamePeriod()
end
elseif GameMode == "ing" then
if onTick and type(onTick) == "function" then
onTick()
end
if Now > StateChangeTime then
endGame()
end
end
end
)
-- Handler for er deposits to participate in the next game.
Handlers.add(
"Transfer",
function(Msg)
return
Msg.Action == "Credit-Notice" and
Msg.From == PaymentToken and
tonumber(Msg.Quantity) >= tonumber(PaymentQty) and "continue"
end,
function(Msg)
Waiting[Msg.Sender] = true
ao.send({
Target = Msg.Sender,
Action = "Payment-Received"
})
announce("er-Ready", Msg.Sender .. " is ready to !")
end
)
-- Registers new ers for the next game and subscribes them for event info.
Handlers.add(
"Register",
{ Action = "Register" },
function(Msg)
if Msg.Mode ~= "Listen" and Waiting[Msg.From] == undefined then
Waiting[Msg.From] = false
end
removeListener(Msg.From)
table.insert(Listeners, Msg.From)
ao.send({
Target = Msg.From,
Action = "Registered"
})
announce("New er Registered", Msg.From .. " has joined in waiting.")
end
)
-- Unregisters ers and s sending them event info.
Handlers.add(
"Unregister",
{ Action = "Unregister" },
function(Msg)
removeListener(Msg.From)
ao.send({
Target = Msg.From,
Action = "Unregistered"
})
end
)
-- Adds bet amount to BonusQty
Handlers.add(
"AddBet",
{ Reason = "AddBet" },
function(Msg)
BonusQty = tonumber(BonusQty) + tonumber(Msg.Tags.Quantity)
announce("Bet-Added", Msg.From .. "has placed a bet. " .. "BonusQty amount increased by " .. Msg.Tags.Quantity .. "!")
end
)
-- Retrieves the current game state.
Handlers.add(
"GetGameState",
{ Action = "GetGameState" },
function (Msg)
local json = require("json")
local TimeRemaining = StateChangeTime - Now
local GameState = json.encode({
GameMode = GameMode,
TimeRemaining = TimeRemaining,ers = ers,
})
ao.send({
Target = Msg.From,
Action = "GameState",
Data = GameState})
end
)
-- Alerts users regarding the time remaining in each game state.
Handlers.add(
"AnnounceTick",
{ Action = "Tick" },
function (Msg)
local TimeRemaining = StateChangeTime - Now
if GameMode == "Waiting" then
announce("Tick", "The game will start in " .. (TimeRemaining/1000) .. " seconds.")
elseif GameMode == "ing" then
announce("Tick", "The game will end in " .. (TimeRemaining/1000) .. " seconds.")
end
end
)
-- Sends tokens to ers with no balance upon request
Handlers.add(
"RequestTokens",
{ Action = "RequestTokens" },
function (Msg)
print("Transferring Tokens: " .. tostring(math.floor(10000 * UNIT)))
ao.send({
Target = ao.id,
Action = "Transfer",
Quantity = tostring(math.floor(10000 * UNIT)),
Recipient = Msg.From,
})
end
) Arena Game Blueprint For those interested in using this arena framework, we've made this code easily accessible through a blueprint. Simply run the following code in your terminal:lua.load-blueprint arena Summary Understanding the mechanics of the arena can not only help you improve your autonomous agent created in the previous section but also empowers you to harness core functionalities for crafting your unique games.In the upcoming section, "Building a Game," we will dive deep into the art of utilizing these mechanics to construct captivating and one-of-a-kind games within this framework. Get ready to embark on a journey into the dynamic realm of game development! 🎮

---

# 65. References  Cookbook

Document Number: 65
Source: https://cookbook_ao.arweave.net/references/index.html
Words: 202
Quality Score: 0.447
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

References This section provides detailed technical references for AO components, languages, and tools. Use these resources to find specific information when implementing your AO projects.Programming Languages Resources for the programming languages used in AO:Lua - Reference for the Lua programming language, the primary language used in AO WebAssembly (WASM) - Information about using WebAssembly modules in AO Lua Optimization - Techniques and best practices for optimizing Lua code in AO AO API Reference Documentation for AO's core APIs and functionality:AO Core - Core ao module and API reference Messaging - Comprehensive guide to the AO messaging system patterns Handlers - Reference for event handlers and message processing Token - Information about token creation and management Arweave Data - Guide to data handling and storage in AO Cron - Documentation for scheduling and managing timed events Development Environment Tools and setup for AO development:Editor Setup - Guide to setting up your development environment for AO BetterIDEa - The ultimate native web IDE for AO development Community Resources Connect with the AO community:Community Resources - Information about AO community resources and support Use the sidebar to navigate between reference topics. References are organized by category to help you find the information you need quickly.

---

# 66. Begin An Interactive Tutorial  Cookbook

Document Number: 66
Source: https://cookbook_ao.arweave.net/tutorials/begin/index.html
Words: 130
Quality Score: 0.443
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Begin: An Interactive Tutorial In this tutorial series, you'll walk through an interactive steps that will help you deepen your knowledge and understanding of the aos environment.INFO The Exercise In this fun exercise, you'll encounter a series of challenges presented by two familiar characters, Morpheus and Trinity. You'll dive deep into the rabbit hole guided by Morpheus as he presents you with a series of challenges to prove you're the one. Once you've completed all of the challenges presented by both Morpheus and Trinity, you'll receive a token that grants you access to an exclusive chatroom within ao called The Construct.Now, let's get started down the rabbit hole.Tutorials Getting Started - An Interactive Tutorial 1. Quick Start 2. Messaging 3. Creating a Chatroom 4. Build a Token

---

# 67. Accessing Data from Arweave with ao  Cookbook

Document Number: 67
Source: https://cookbook_ao.arweave.net/references/data.html
Words: 1254
Quality Score: 0.440
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Accessing Data from Arweave with ao There may be times in your ao development workflow that you want to access data from Arweave. With ao, your process can send an assignment instructing the network to provide that data to your Process.Defining Acceptable Transactions (Required First Step) Before you can assign any Arweave transaction to your process, you must first define which transactions your process will accept using ao.addAssignable. This function creates conditions that determine which Arweave transactions your process will accept.Warning: If you attempt to assign a transaction without first defining a matching assignable pattern, that transaction will be permanently blacklisted and can never be assigned to your process, even if you later add a matching assignable.You can remove assignables with ao.removeAssignable("").The condition functions use similar pattern matching techniques as found in the Handlers documentation. For complete details on the ao.addAssignable function, including parameter descriptions and additional examples, see the ao Module Reference.Assignment Methods After defining acceptable transactions and setting up your listener (if needed), you can request Arweave data in one of two ways:Using Assign The primary method to request data from Arweave:Using Send with Assignments Alternatively, you can use the Send function with an Assignments parameter:Working with Assigned Data You can process assigned data using either Receive or Handlers:Using Receive Directly You can also match specific transactions or combine conditions:Note: When using .load, the script s at Receive until data arrives. When running commands separately in the shell, each command executes independently.Using Handlers For persistent processing, set up a handler:Handlers are ideal for:Processing multiple assignments over time Automated processing without manual intervention Building services that other processes can interact with For more details, see the Messaging Patterns and Handlers documentation.Complete Example Workflow Here's a complete example that demonstrates the entire process of accessing data from an Arweave transaction:This pattern creates a synchronous flow where your process:Defines acceptable transactions Requests the data Captures the data using Receive Processes the data Practical Examples Here are two practical examples showing different approaches to working with Arweave data in your ao process:Example 1: Caching Arweave Data This example demonstrates how to load and cache data from Arweave, then use it in subsequent operations:lua-- Initialize state
local Number = 0
-- Step 1: Define which transactions your process will accept
print("Step 1: Defining acceptable transactions")
ao.addAssignable("addNumber", function (msg)
return msg.Tags["Action"] == "Number"
end)
-- Step 2: Request and cache the initial number from Arweave
-- This uses a self-executing function to fetch and cache the value only once
NumberFromArweave = NumberFromArweave or (function()
print("Step 2: Requesting initial number from Arweave")
Assign({
Processes = { ao.id },
Message = 'DivdWHaNj8mJhQQCdatt52rt4QvceBR_iyX58aZctZQ'
})
return tonumber(Receive({ Action = "Number"}).Data)
end)()
-- Step 3: Set up handler for future number updates
-- This handler will add new numbers to our cached Arweave number
Handlers.add("Number", function (msg)
print("Received message with Data = " .. msg.Data)
print("Old Number: " .. Number)
Number = NumberFromArweave + tonumber(msg.Data)
print("New Number: " .. Number)
end) This example shows how to:Cache Arweave data using a self-executing function Use the cached data in subsequent message handling Combine Arweave data with new incoming data Example 2: Dynamic Transaction Processing This example shows how to process arbitrary Arweave transactions and maintain state between requests:lua-- Table to store pending requests (maps transaction ID to original sender)
local PendingRequests = {}
-- Step 1: Define which transactions your process will accept
print("Step 1: Defining acceptable transactions")
ao.addAssignable("processArweaveNumber", function (msg)
return msg.Tags["Action"] == "Number"
end)
-- Step 2: Set up handler for initiating the processing
Handlers.add(
"ProcessArweaveNumber",
function (msg)
if not msg.Tags["ArweaveTx"] then
print("Error: No ArweaveTx tag provided")
return
end
local txId = msg.Tags["ArweaveTx"]
print("Assigning Arweave transaction: " .. txId)
-- Store the original sender associated with this transaction ID
PendingRequests[txId] = msg.From
-- Assign the transaction to this process
Assign({
Processes = { ao.id },
Message = txId
})
print("Assignment requested; waiting for data...")
end
)
-- Step 3: Set up handler for processing the assigned message
Handlers.add(
"Number",
function (msg)
local txId = msg.Id -- The ID of the assigned message
local originalSender = PendingRequests[txId]
if not originalSender then
print("Error: No pending request found for transaction " .. txId)
return
end
local data = msg.Data
if not data or not tonumber(data) then
print("Error: Invalid number data in assigned message")
return
end
local number = tonumber(data)
local result = number + 1
print(string.format("Processing: %d + 1 = %d", number, result))
-- Send the result back to the original sender
Send({
Target = originalSender,
Data = tostring(result)
})
-- Clean up the pending request
PendingRequests[txId] = nil
end
) To use this example:This example demonstrates:Processing arbitrary Arweave transactions Maintaining state between requests using a pending requests table Sending results back to the original requester Error handling and request cleanup WARNING When using Assign to bridge Arweave data into AO, you must ensure that:The Arweave transaction you're assigning matches one of your defined assignables You have a corresponding handler or receiver set up to process that transaction type The handler's pattern matching matches the assigned transaction's tags/properties For example, if you're assigning a transaction with Action = "Number", you need:An assignable that accepts msg.Tags["Action"] == "Number" Either a Receive function or a handler that matches the same pattern Both the assignable and handler must use consistent pattern matching Important Limitations There are critical limitations to be aware of when working with assignables:Matching is Required: Transactions must match at least one of your defined assignable patterns to be accepted.Blacklisting is Permanent: If you attempt to assign a transaction before defining an appropriate assignable, it will be permanently blacklisted. Even if you later add a matching assignable, that transaction will never be accepted.One-time Assignment: Each Arweave transaction can only be assigned once to a given process. Subsequent assignments of the same transaction will be ignored.Proper Sequence for Assigning Arweave Transactions For successful assignment of Arweave transactions, follow these steps:Define assignables to specify which Arweave transactions your process will accept Wait for any transaction confirmations (by default, 20 confirmations are required) Set up handlers or listeners with Receive or Handlers.add to process the data Assign the Arweave transaction to your process (see Assignment Methods) The order of steps 3 and 4 can be interchanged based on your needs:When using Receive in a script loaded with .load, ensure Assign is placed before Receive to prevent the process from hanging, as Receive is blocking.When using handlers or running commands separately in the shell, the order doesn't matter as handlers will catch messages whenever they arrive Why Access Data from Arweave?There are several practical reasons to access Arweave data from your ao process:Efficient Handling of Large Data: For larger content, directly accessing Arweave is more efficient:Reference large media files (images, videos, documents) without storing them in your process Work with datasets too large to fit in process memory Maintain a lightweight process that can access substantial external resources External Data for Decision-Making: Your process may need data stored on Arweave to make informed decisions. For example:Reading token price data stored by an oracle Accessing verified identity information Retrieving voting records or governance data Dynamic Loading of Features: Rather than including all functionality in your initial process code:Load modules or plugins from Arweave as needed Update configuration without redeploying your entire process Implement upgradable components with new versions stored on Arweave This approach allows you to create more sophisticated applications that leverage Arweave's permanent storage while maintaining efficient process execution in the ao environment.When another process Assigns a transaction to this process, you can also use handlers to process the data asynchronously.

---

# 68. Expanding the Arena  Cookbook

Document Number: 68
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/build-game.html
Words: 1791
Quality Score: 0.432
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Expanding the Arena Welcome to the final guide of Chapter 2, where you'll learn to build your own game on top of the arena framework introduced in the previous tutorial. In this guide, we'll take you through the process of creating the "ao-effect" game, which you experienced at the beginning of this chapter. As you progress through this example, you'll gain insights into structuring your game's logic and interacting with the arena's core code.Whether you're a seasoned developer or an aspiring game creator, this guide will empower you to unleash your creativity and bring your unique game ideas to life within the aos environment.Setting up the Development Environment Start by creating a new file named ao-effect.lua in your preferred directory.NOTE Ideally, this file should be placed in the same directory where your game process runs to ease the loading of the code. Else, you'll need to use relative paths to access the file.Writing the Code Now, let's dive into the logic.You'll notice that your game logic will involve calling functions and variables defined in the arena's logic. This showcases the power of composability, where your game builds on top of the existing arena logic, allowing seamless integration of variables and functions between the two. Because both logic become part of a unified logic for the game process.Initializing Game Mechanics First, define essential variables and functions that set the stage for your game's mechanics:lua-- AO EFFECT: Game Mechanics for AO Arena Game
-- Game grid dimensions
Width = 40 -- Width of the grid
Height = 40 -- Height of the grid
Range = 1 -- The distance for blast effect
-- er energy settings
MaxEnergy = 100 -- Maximum energy a er can have
EnergyPerSec = 1 -- Energy gained per second
-- Attack settings
AverageMaxStrengthHitsToKill = 3 -- Average number of hits to eliminate a er
-- Initializes default er state
-- @return Table representing er's initial state
function erInitState()
return {
x = math.random(Width/8),
y = math.random(Height/8),
health = 100,
energy = 0
}
end
-- Function to incrementally increase er's energy
-- Called periodically to update er energy
function onTick()
if GameMode ~= "ing" then return end -- Only active during "ing" state
if LastTick == undefined then LastTick = Now end
local Elapsed = Now - LastTick
if Elapsed >= 1000 then -- Actions performed every second
for er, state in pairs(ers) do
local newEnergy = math.floor(math.min(MaxEnergy, state.energy + (Elapsed * EnergyPerSec // 2000)))
state.energy = newEnergy
end
LastTick = Now
end
end This code initializes your game's mechanics, including grid dimensions, er energy, and attack settings. The erInitState function sets up the initial state for ers when the game begins.er Movement Next, add the code for er movement:lua-- Handles er movement
-- @param msg: Message request sent by er with movement direction and er info
function move(msg)
local erToMove = msg.From
local direction = msg.Tags.Direction
local directionMap = {
Up = {x = 0, y = -1}, Down = {x = 0, y = 1},
Left = {x = -1, y = 0}, Right = {x = 1, y = 0},
UpRight = {x = 1, y = -1}, UpLeft = {x = -1, y = -1},
DownRight = {x = 1, y = 1}, DownLeft = {x = -1, y = 1}
}
-- calculate and update new coordinates
if directionMap[direction] then
local newX = ers[erToMove].x + directionMap[direction].x
local newY = ers[erToMove].y + directionMap[direction].y
-- updates er coordinates while checking for grid boundariesers[erToMove].x = (newX - 1) % Width + 1ers[erToMove].y = (newY - 1) % Height + 1
announce("er-Moved", erToMove .. " moved to " .. ers[erToMove].x .. "," .. ers[erToMove].y .. ".")
else
ao.send({Target = erToMove, Action = "Move-Failed", Reason = "Invalid direction."})
end
onTick() -- Optional: Update energy each move
end The move function calculates new er coordinates based on the chosen direction while ensuring that ers remain within the grid boundaries. er movement adds dynamic interaction to your game and is announced to all ers and listeners.er Attacks Then you must implement the logic for er attacks:lua-- Handles er attacks
-- @param msg: Message request sent by er with attack info and er state
function attack(msg)
local er = msg.From
local attackEnergy = tonumber(msg.Tags.AttackEnergy)
-- get er coordinates
local x = ers[er].x
local y = ers[er].y
-- check if er has enough energy to attack
if ers[er].energy < attackEnergy then
ao.send({Target = er, Action = "Attack-Failed", Reason = "Not enough energy."})
return
end
-- update er energy and calculate damageers[er].energy = ers[er].energy - attackEnergy
local damage = math.floor((math.random() * 2 * attackEnergy) * (1/AverageMaxStrengthHitsToKill))
announce("Attack", er .. " has launched a " .. damage .. " damage attack from " .. x .. "," .. y .. "!")
-- check if any er is within range and update their status
for target, state in pairs(ers) do
if target ~= er and inRange(x, y, state.x, state.y, Range) then
local newHealth = state.health - damage
if newHealth <= 0 then
eliminateer(target, er)
elseers[target].health = newHealth
ao.send({Target = target, Action = "Hit", Damage = tostring(damage), Health = tostring(newHealth)})
ao.send({Target = er, Action = "Successful-Hit", Recipient = target, Damage = tostring(damage), Health = tostring(newHealth)})
end
end
end
end
-- Helper function to check if a target is within range
-- @param x1, y1: Coordinates of the attacker
-- @param x2, y2: Coordinates of the potential target
-- @param range: Attack range
-- @return Boolean indicating if the target is within range
function inRange(x1, y1, x2, y2, range)
return x2 >= (x1 - range) and x2 <= (x1 + range) and y2 >= (y1 - range) and y2 <= (y1 + range)
end The attack function calculates damage based on attack energy, checks er energy, and updates er health accordingly. er attacks add the competitive element in your game, allowing ers to engage with each other. The attacks are also announced to the ers and listeners for real-time updates of the game.Handling the Logic Lastly, you must setup handlers:As seen in earlier guides, the handlers help trigger functions when their respective patterns are met.You can refer to the final code for ao-effect.lua in the dropdown below:Final ao-effect.lua file lua-- AO EFFECT: Game Mechanics for AO Arena Game
-- Game grid dimensions
Width = 40 -- Width of the grid
Height = 40 -- Height of the grid
Range = 1 -- The distance for blast effect
-- er energy settings
MaxEnergy = 100 -- Maximum energy a er can have
EnergyPerSec = 1 -- Energy gained per second
-- Attack settings
AverageMaxStrengthHitsToKill = 3 -- Average number of hits to eliminate a er
-- Initializes default er state
-- @return Table representing er's initial state
function erInitState()
return {
x = math.random(0, Width),
y = math.random(0, Height),
health = 100,
energy = 0
}
end
-- Function to incrementally increase er's energy
-- Called periodically to update er energy
function onTick()
if GameMode ~= "ing" then return end -- Only active during "ing" state
if LastTick == undefined then LastTick = Now end
local Elapsed = Now - LastTick
if Elapsed >= 1000 then -- Actions performed every second
for er, state in pairs(ers) do
local newEnergy = math.floor(math.min(MaxEnergy, state.energy + (Elapsed * EnergyPerSec // 2000)))
state.energy = newEnergy
end
LastTick = Now
end
end
-- Handles er movement
-- @param msg: Message request sent by er with movement direction and er info
function move(msg)
local erToMove = msg.From
local direction = msg.Tags.Direction
local directionMap = {
Up = {x = 0, y = -1}, Down = {x = 0, y = 1},
Left = {x = -1, y = 0}, Right = {x = 1, y = 0},
UpRight = {x = 1, y = -1}, UpLeft = {x = -1, y = -1},
DownRight = {x = 1, y = 1}, DownLeft = {x = -1, y = 1}
}
-- calculate and update new coordinates
if directionMap[direction] then
local newX = ers[erToMove].x + directionMap[direction].x
local newY = ers[erToMove].y + directionMap[direction].y
-- updates er coordinates while checking for grid boundariesers[erToMove].x = (newX - 1) % Width + 1ers[erToMove].y = (newY - 1) % Height + 1
announce("er-Moved", erToMove .. " moved to " .. ers[erToMove].x .. "," .. ers[erToMove].y .. ".")
else
ao.send({Target = erToMove, Action = "Move-Failed", Reason = "Invalid direction."})
end
onTick() -- Optional: Update energy each move
end
-- Handles er attacks
-- @param msg: Message request sent by er with attack info and er state
function attack(msg)
local er = msg.From
local attackEnergy = tonumber(msg.Tags.AttackEnergy)
-- get er coordinates
local x = ers[er].x
local y = ers[er].y
-- check if er has enough energy to attack
if ers[er].energy < attackEnergy then
ao.send({Target = er, Action = "Attack-Failed", Reason = "Not enough energy."})
return
end
-- update er energy and calculate damageers[er].energy = ers[er].energy - attackEnergy
local damage = math.floor((math.random() * 2 * attackEnergy) * (1/AverageMaxStrengthHitsToKill))
announce("Attack", er .. " has launched a " .. damage .. " damage attack from " .. x .. "," .. y .. "!")
-- check if any er is within range and update their status
for target, state in pairs(ers) do
if target ~= er and inRange(x, y, state.x, state.y, Range) then
local newHealth = state.health - damage
if newHealth <= 0 then
eliminateer(target, er)
elseers[target].health = newHealth
ao.send({Target = target, Action = "Hit", Damage = tostring(damage), Health = tostring(newHealth)})
ao.send({Target = er, Action = "Successful-Hit", Recipient = target, Damage = tostring(damage), Health = tostring(newHealth)})
end
end
end
end
-- Helper function to check if a target is within range
-- @param x1, y1: Coordinates of the attacker
-- @param x2, y2: Coordinates of the potential target
-- @param range: Attack range
-- @return Boolean indicating if the target is within range
function inRange(x1, y1, x2, y2, range)
return x2 >= (x1 - range) and x2 <= (x1 + range) and y2 >= (y1 - range) and y2 <= (y1 + range)
end
-- HANDLERS: Game state management for AO-Effect
-- Handler for er movement
Handlers.add("erMove", { Action = "erMove" }, move)
-- Handler for er attacks
Handlers.add("erAttack", { Action = "erAttack" }, attack) Once you've written your game code, it's time to load it into the aos game process and test your game:lua.load ao-effect.lua IMPORTANT Make sure to load the arena blueprint in the same process as well.Invite friends or create test er processes to experience your game and make any necessary adjustments for optimal performance.What's Next Congratulations! You've successfully expanded the arena by building your own game on top of its core functionalities. Armed with the knowledge and tools acquired in this guide, you're now equipped to build games on aos independently.The possibilities are endless. Continue adding more features to existing games or create entirely new ones. The sky's the limit! ⌃◦🚀

---

# 69. Utils  Cookbook

Document Number: 69
Source: https://cookbook_ao.arweave.net/guides/aos/modules/utils.html
Words: 541
Quality Score: 0.432
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Utils A utility library for generic table manipulation and validation. It supports both curry-styled and traditional programming.Note: It is important to verify that the inputs provided to the following functions match the expected types.Example usage Module functions concat() This function concatenates array b to array a.Parameters:a: {table} The base array b: {table} The array to concat to the base array Returns: An unified array of a and b Examples reduce() This function executes the provided reducer function for all array elements, finally providing one (unified) result.Parameters:fn: {function} The reducer function. It receives the previous result, the current element's value and key in this order initial: {any} An optional initial value t: {table} The array to reduce Returns: A single result from running the reducer across all table elements Examples map() This function creates a new array filled with the results of calling the provided map function on each element in the provided array.Parameters:fn: {function} The map function. It receives the current array element and key data: {table} The array to map Returns: A new array composed of the results of the map function Examples filter() This function creates a new array from a portion of the original, only keeping the elements that passed a provided filter function's test.Parameters:fn: {function} The filter function. It receives the current array element and should return a boolean, deciding whether the element should be kept (true) or filtered out (false) data: {table} The array to filter Returns: The new filtered array Examples find() This function returns the first element that matches in a provided function.Parameters:fn: {function} The find function that receives the current element and returns true if it matches, false if it doesn't t: {table} The array to find an element in Returns: The found element or nil if no element matched Examples reverse() Transforms an array into reverse order.Parameters:data: {table} The array to reverse Returns: The original array in reverse order Example includes() Determines whether a value is part of an array.Parameters:val: {any} The element to check for t: {table} The array to check in Returns: A boolean indicating whether or not the provided value is part of the array Examples keys() Returns the keys of a table.Parameters:table: {table} The table to get the keys for Returns: An array of keys Example values() Returns the values of a table.Parameters:table: {table} The table to get the values for Returns: An array of values Example propEq() Checks if a specified property of a table equals with the provided value.Parameters:propName: {string} The name of the property to compare value: {any} The value to compare to object: {table} The object to select the property from Returns: A boolean indicating whether the property value equals with the provided value or not Examples prop() Returns the property value that belongs to the property name provided from an object.Parameters:propName: {string} The name of the property to get object: {table} The object to select the property value from Returns: The property value or nil if it was not found Examples compose() This function allows you to chain multiple array mutations together and execute them in reverse order on the provided array.Parameters:...: {function[]} The array mutations v: {table} The object to execute the provided functions on Returns: The result from the provided mutations

---

# 70. Base64  Cookbook

Document Number: 70
Source: https://cookbook_ao.arweave.net/guides/aos/modules/base64.html
Words: 231
Quality Score: 0.431
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Base64 A small base64 module to encode or decode base64 text.Note: It is recommended to enable caching for large chunks of texts for up to x2 optimization.Example usage Module functions encode() This function encodes the provided string using the default encoder table. The encoder can be customized and a cache is available for larger chunks of data.Parameters:str: {string} The string to encode encoder: {table} Optional custom encoding table usecache: {boolean} Optional cache for large strings (turned off by default) Returns: Base64 encoded string Examples decode() This function decodes the provided base64 encoded string using the default decoder table. The decoder can be customized and a cache is also available here.Parameters:str: {string} The base64 encoded string to decode decoder: {table} Optional custom decoding table usecache: {boolean} Optional cache for large strings (turned off by default) Returns: Decoded string Examples makeencoder() Allows creating a new encoder table to customize the encode() function's result.Parameters:s62: {string} Optional custom char for 62 (+ by default) s63: {string} Optional custom char for 63 (/ by default) spad: {string} Optional custom padding char (= by default) Returns: Custom encoder table Examples makedecoder() Allows creating a new decoder table to be able to decode custom-encoded base64 strings.Parameters:s62: {string} Optional custom char for 62 (+ by default) s63: {string} Optional custom char for 63 (/ by default) spad: {string} Optional custom padding char (= by default) Returns: Custom decoder table

---

# 71. Bringing it Together  Cookbook

Document Number: 71
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/bringing-together.html
Words: 966
Quality Score: 0.428
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Bringing it Together This final guide wraps up our series, where you've built up an autonomous agent piece by piece. Now, let's refine your agent with some optimizations that fine-tune its operations. Here's a quick overview of the key improvements made:Sequential Command Execution: The introduction of an InAction flag ensures that your agent's actions are sequential (next action occurs only when the previous is successfully executed). This critical addition prevents your agent from acting on outdated game states, enhancing its responsiveness and accuracy. The full implementation can be found in the final code for the bot.lua file below.Dynamic State Updates and Decisions: The agent now employs an automatic tick logic, allowing for dynamic updates and decisions. This logic enables the agent to self-trigger state updates and make subsequent decisions either upon receiving a Tick message or upon completing an action, promoting autonomous operation.Automated Fee Transfer: To further streamline its operation and ensure uninterrupted participation in games, the autonomous agent now autonomously handles the transfer of confirmation fees.In addition to these features, we've also added a logging function for debugging purposes and colored prints for better comprehension of game events. These enhancements collectively make your autonomous agent more efficient and adaptable in the game environment.Check out the complete bot.lua code in the dropdown below, with all new additions highlighted accordingly:Updated bot.lua file lua-- Initializing global variables to store the latest game state and game host process.
LatestGameState = LatestGameState or nil
InAction = InAction or false -- Prevents the agent from taking multiple actions at once.
Logs = Logs or {}
colors = {
red = "\27[31m",
green = "\27[32m",
blue = "\27[34m",
reset = "\27[0m",
gray = "\27[90m"
}
function addLog(msg, text) -- Function definition commented for performance, can be used for debugging
Logs[msg] = Logs[msg] or {}
table.insert(Logs[msg], text)
end
-- Checks if two points are within a given range.
-- @param x1, y1: Coordinates of the first point.
-- @param x2, y2: Coordinates of the second point.
-- @param range: The maximum allowed distance between the points.
-- @return: Boolean indicating if the points are within the specified range.
function inRange(x1, y1, x2, y2, range)
return math.abs(x1 - x2) <= range and math.abs(y1 - y2) <= range
end
-- Decides the next action based on er proximity and energy.
-- If any er is within range, it initiates an attack; otherwise, moves randomly.
function decideNextAction()
local er = LatestGameState.ers[ao.id]
local targetInRange = false
for target, state in pairs(LatestGameState.ers) do
if target ~= ao.id and inRange(er.x, er.y, state.x, state.y, 1) then
targetInRange = true
break
end
end
if er.energy > 5 and targetInRange then
print(colors.red .. "er in range. Attacking." .. colors.reset)
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(er.energy)})
else
print(colors.red .. "No er in range or insufficient energy. Moving randomly." .. colors.reset)
local directionMap = {"Up", "Down", "Left", "Right", "UpRight", "UpLeft", "DownRight", "DownLeft"}
local randomIndex = math.random(#directionMap)
ao.send({Target = Game, Action = "erMove", er = ao.id, Direction = directionMap[randomIndex]})
end
InAction = false -- InAction logic added
end
-- Handler to print game announcements and trigger game state updates.
Handlers.add(
"PrintAnnouncements",
{ Action = "Announcement" },
function (msg)
if msg.Event == "Started-Waiting-Period" then
ao.send({Target = ao.id, Action = "AutoPay"})
elseif (msg.Event == "Tick" or msg.Event == "Started-Game") and not InAction then
InAction = true -- InAction logic added
ao.send({Target = Game, Action = "GetGameState"})
elseif InAction then -- InAction logic added
print("Previous action still in progress. Skipping.")
end
print(colors.green .. msg.Event .. ": " .. msg.Data .. colors.reset)
end
)
-- Handler to trigger game state updates.
Handlers.add(
"GetGameStateOnTick",
{ Action = "Tick" },
function ()
if not InAction then -- InAction logic added
InAction = true -- InAction logic added
print(colors.gray .. "Getting game state..." .. colors.reset)
ao.send({Target = Game, Action = "GetGameState"})
else
print("Previous action still in progress. Skipping.")
end
end
)
-- Handler to automate payment confirmation when waiting period starts.
Handlers.add(
"AutoPay",
{ Action = "AutoPay" },
function (msg)
print("Auto-paying confirmation fees.")
ao.send({ Target = Game, Action = "Transfer", Recipient = Game, Quantity = "1000"})
end
)
-- Handler to update the game state upon receiving game state information.
Handlers.add(
"UpdateGameState",
{ Action = "GameState" },
function (msg)
local json = require("json")
LatestGameState = json.decode(msg.Data)
ao.send({Target = ao.id, Action = "UpdatedGameState"})
print("Game state updated. Print \'LatestGameState\' for detailed view.")
end
)
-- Handler to decide the next best action.
Handlers.add(
"decideNextAction",
{ Action = "UpdatedGameState" },
function ()
if LatestGameState.GameMode ~= "ing" then
InAction = false -- InAction logic added
return
end
print("Deciding next action.")
decideNextAction()
ao.send({Target = ao.id, Action = "Tick"})
end
)
-- Handler to automatically attack when hit by another er.
Handlers.add(
"ReturnAttack",
{ Action = "Hit" },
function (msg)
if not InAction then -- InAction logic added
InAction = true -- InAction logic added
local erEnergy = LatestGameState.ers[ao.id].energy
if erEnergy == undefined then
print(colors.red .. "Unable to read energy." .. colors.reset)
ao.send({Target = Game, Action = "Attack-Failed", Reason = "Unable to read energy."})
elseif erEnergy == 0 then
print(colors.red .. "er has insufficient energy." .. colors.reset)
ao.send({Target = Game, Action = "Attack-Failed", Reason = "er has no energy."})
else
print(colors.red .. "Returning attack." .. colors.reset)
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(erEnergy)})
end
InAction = false -- InAction logic added
ao.send({Target = ao.id, Action = "Tick"})
else
print("Previous action still in progress. Skipping.")
end
end
) What's next?You're now equipped with the knowledge to craft intelligent autonomous agents. It's time to apply these insights into the game world. Understand the game's intricacies and leverage your agent's capabilities to dominate the arena. But there's more to come.In future sections, we'll dive deeper into the game arena, offering advanced strategies to elevate your agent's performance. Ready to take on the challenge? Let's see what you can create! 🕹️

---

# 72. Staking Blueprint  Cookbook

Document Number: 72
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/staking.html
Words: 423
Quality Score: 0.426
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Staking Blueprint The Staking Blueprint is a predesigned template that helps you quickly build a staking system in ao. It is a great way to get started and can be customized to fit your needs.Prerequisites The Staking Blueprint requires the Token Blueprint to be loaded, first.Unpacking the Staking Blueprint Stakers: The Stakers array is used to store the staked tokens of the participants.Unstaking: The Unstaking array is used to store the unstaking requests of the participants.Stake Action Handler: The stake handler allows processes to stake tokens. When a process sends a message with the tag Action = "Stake", the handler will add the staked tokens to the Stakers array and send a message back to the process confirming the staking.Unstake Action Handler: The unstake handler allows processes to unstake tokens. When a process sends a message with the tag Action = "Unstake", the handler will add the unstaking request to the Unstaking array and send a message back to the process confirming the unstaking.Finalization Handler: The finalize handler allows processes to finalize the staking process. When a process sends a message with the tag Action = "Finalize", the handler will process the unstaking requests and finalize the staking process.How To Use:Open your preferred text editor.Open the Terminal.Start your aos process.Type in .load-blueprint staking Verify the Blueprint is Loaded:Type in Handlers.list to see the newly loaded handlers.What's in the Staking Blueprint:luaStakers = Stakers or {}
Unstaking = Unstaking or {}
-- Stake Action Handler
Handlers.stake = function(msg)
local quantity = tonumber(msg.Tags.Quantity)
local delay = tonumber(msg.Tags.UnstakeDelay)
local height = tonumber(msg['Block-Height'])
assert(Balances[msg.From] and Balances[msg.From] >= quantity, "Insufficient balance to stake")
Balances[msg.From] = Balances[msg.From] - quantity
Stakers[msg.From] = Stakers[msg.From] or {}
Stakers[msg.From].amount = (Stakers[msg.From].amount or 0) + quantity
Stakers[msg.From].unstake_at = height + delay
end
-- Unstake Action Handler
Handlers.unstake = function(msg)
local quantity = tonumber(msg.Tags.Quantity)
local stakerInfo = Stakers[msg.From]
assert(stakerInfo and stakerInfo.amount >= quantity, "Insufficient staked amount")
stakerInfo.amount = stakerInfo.amount - quantity
Unstaking[msg.From] = {
amount = quantity,
release_at = stakerInfo.unstake_at
}
end
-- Finalization Handler
local finalizationHandler = function(msg)
local currentHeight = tonumber(msg['Block-Height'])
-- Process unstaking
for address, unstakeInfo in pairs(Unstaking) do
if currentHeight >= unstakeInfo.release_at then
Balances[address] = (Balances[address] or 0) + unstakeInfo.amount
Unstaking[address] = nil
end
end
end
-- wrap function to continue handler flow
local function continue(fn)
return function (msg)
local result = fn(msg)
if (result) == -1 then
return 1
end
return result
end
end
-- Registering Handlers
Handlers.add("stake",
continue(Handlers.utils.hasMatchingTag("Action", "Stake")), Handlers.stake)
Handlers.add("unstake",
continue(Handlers.utils.hasMatchingTag("Action", "Unstake")), Handlers.unstake)
-- Finalization handler should be called for every message
Handlers.add("finalize", function (msg) return -1 end, finalizationHandler)

---

# 73. Interpreting Announcements  Cookbook

Document Number: 73
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/announcements.html
Words: 353
Quality Score: 0.426
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Interpreting Announcements Welcome back to your coding journey. It's time to use the skills you've acquired from previous tutorials to enhance your gaming experience.During the game, you've likely noticed announcements appearing in your terminal. These announcements are the game's way of communicating important events to ers. However, these messages can sometimes seem cryptic or you might find yourself checking your inbox frequently for further details.Wouldn't it be convenient to access this information directly from your terminal? Well, there's a way to do that!By using handlers, you can create an autonomous agent to retrieve this information for you, marking the progression from simple bots to entities capable of interpreting and acting on game events directly.Setting up the Development Environment Start by creating a new file named bot.lua in your preferred directory.Ideally, this file should be placed in the same directory where your er process runs to ease the loading of the code. Else, you'll need to use relative paths to access the file.Writing the Code Let's dive into the logic.Each handler in aos requires three key pieces of information:name: A unique name for the handler pattern: A pattern for the handler to identify, triggering its operation handle: The operations to perform when the desired pattern is found.Here's how you can write a handler for printing announcement details:In this case, the name of the handler is "PrintAnnouncements". It uses a special in-built utility (hasMatchingTags) represented by { Action = "Announcement" } to check if the incoming message has been tagged as an announcement. If true, the handler prints the Event and Data, which represent the title and description of the announcement.NOTE Once a message is "handled", it will be discarded from your Inbox.Now, let's bring this to life in the game.Navigate to your aos er terminal and enter a game session.Activate the handler by loading your bot.lua file with:lua.load bot.lua You'll now see game announcements appear directly in your terminal, offering real-time insights without the need to sift through your inbox.Congratulations! You have just taken the first step in building a bot on aos. But let's keep working on adding more features to it 🌐

---

# 74. Strategic Decisions  Cookbook

Document Number: 74
Source: https://cookbook_ao.arweave.net/tutorials/bots-and-games/decisions.html
Words: 552
Quality Score: 0.425
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Strategic Decisions With the latest game state at your disposal, your bot can evolve into an autonomous agent. This transition marks an upgrade in functionality, enabling not just reactions to game states but strategic actions that consider context, energy, and proximity to make decisions.Writing the Code Return to your bot.lua file and add the following functions:lua-- Determines proximity between two points.
function inRange(x1, y1, x2, y2, range)
return math.abs(x1 - x2) <= range and math.abs(y1 - y2) <= range
end
-- Strategically decides on the next move based on proximity and energy.
function decideNextAction()
local er = LatestGameState.ers[ao.id]
local targetInRange = false
for target, state in pairs(LatestGameState.ers) do
if target ~= ao.id and inRange(er.x, er.y, state.x, state.y, 1) then
targetInRange = true
break
end
end
if er.energy > 5 and targetInRange then
print("er in range. Attacking.")
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(er.energy)})
else
print("No er in range or insufficient energy. Moving randomly.")
local directionMap = {"Up", "Down", "Left", "Right", "UpRight", "UpLeft", "DownRight", "DownLeft"}
local randomIndex = math.random(#directionMap)
ao.send({Target = Game, Action = "erMove", er = ao.id, Direction = directionMap[randomIndex]})
end
end The decideNextAction function is now a testament to our agent's ability to think and act based on a comprehensive understanding of its environment. It analyzes the latest game state to either attack if you have sufficient energy and an opponent is inRange or move otherwise.Now all you need is a handler to make sure this function runs on its own.This handler triggers upon receiving a message that the latest game state has been fetched and updated. An action is taken only when the game is in ing mode.You can refer to the latest code for bot.lua in the dropdown below:Updated bot.lua file luaLatestGameState = LatestGameState or nil
function inRange(x1, y1, x2, y2, range)
return math.abs(x1 - x2) <= range and math.abs(y1 - y2) <= range
end
function decideNextAction()
local er = LatestGameState.ers[ao.id]
local targetInRange = false
for target, state in pairs(LatestGameState.ers) do
if target ~= ao.id and inRange(er.x, er.y, state.x, state.y, 1) then
targetInRange = true
break
end
end
if er.energy > 5 and targetInRange then
print("er in range. Attacking.")
ao.send({Target = Game, Action = "erAttack", er = ao.id, AttackEnergy = tostring(er.energy)})
else
print("No er in range or insufficient energy. Moving randomly.")
local directionMap = {"Up", "Down", "Left", "Right", "UpRight", "UpLeft", "DownRight", "DownLeft"}
local randomIndex = math.random(#directionMap)
ao.send({Target = Game, Action = "erMove", er = ao.id, Direction = directionMap[randomIndex]})
end
end
Handlers.add(
"HandleAnnouncements",
{ Action = "Announcement" },
function (msg)
ao.send({Target = Game, Action = "GetGameState"})
print(msg.Event .. ": " .. msg.Data)
end
)
Handlers.add(
"UpdateGameState",
{ Action = "GameState" },
function (msg)
local json = require("json")
LatestGameState = json.decode(msg.Data)
ao.send({Target = ao.id, Action = "UpdatedGameState"})
end
)
Handlers.add(
"decideNextAction",
{ Action = "UpdatedGameState" },
function ()
if LatestGameState.GameMode ~= "ing" then
return
end
print("Deciding next action.")
decideNextAction()
end
) Once again, to test out the latest upgrades, load the file in your aos er terminal as follows:lua.load bot.lua Observe your process output to see the decisions your autonomous agent makes in real-time, leveraging the current game state for strategic advantage. But what if another er attacks you and runs away while you are deciding the next move? In the next section you'll learn to automatically counter as soon as you have been attacked 🤺

---

# 75. Blueprints  Cookbook

Document Number: 75
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/index.html
Words: 38
Quality Score: 0.424
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Blueprints Blueprints are predesigned templates that help you quickly build in ao. They are a great way to get started and can be customized to fit your needs.Available Blueprints Chatroom CRED Utils Staking Token Voting

---

# 76. Load Lua Files with load filename  Cookbook

Document Number: 76
Source: https://cookbook_ao.arweave.net/guides/aos/load.html
Words: 100
Quality Score: 0.416
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Load Lua Files with.load This feature allows you to load lua code from a source file on your local machine, this simple feature gives you a nice DX experience for working with aos processes.When creating handlers you may have a lot of code and you want to take advantage of a rich development environment like vscode. You can even install the lua extension to get some syntax checking.So how do you publish your local lua source code to your ao process? This is where the .load command comes into .hello.lua aos shell lua.load hello.lua Easy Peasy! 🐶

---

# 77. CRED Utils Blueprint  Cookbook

Document Number: 77
Source: https://cookbook_ao.arweave.net/guides/aos/blueprints/cred-utils.html
Words: 661
Quality Score: 0.416
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

CRED Utils Blueprint CRED is now deprecated CRED was a token used during ao's legacynet phase to reward early developers. It is no longer earnable or redeemable.The CRED Utils Blueprint is a predesigned template that helps you quickly check your CRED balance in ao legacynet.Unpacking the CRED Utils Blueprint The CRED Metatable CRED.balance: Evaluating CRED.balance will print your process's last known balance of your CRED. If you have never fetched your CRED balance before, it will be fetched automatically. If you think your CRED has recently changed, consider running CRED.update first.CRED.process: Evaluating CRED.process will print the process ID of the CRED token issuer.CRED.send: Invoking CRED.send(targetProcessId, amount) like a function will transfer CRED from your ao process to another ao process.targetProcessId: string: the 43-character process ID of the recipient.amount: integer: The quantity of CRED units to send. 1 CRED === 1000 CRED units.CRED.update: Evaluating CRED.update will fetch your latest CRED balance by sending a message to the CRED issuer process. The UpdateCredBalance handler (see below) will ingest the response message.Handler Definitions Credit Handler: The CRED_Credit handler allows the CRED issuer process (and aos) to automatically notify you when your CRED balance increase.Debit Handler: The CRED_Debit handler allows the CRED issuer process (and aos) to automatically notify you when your CRED balance decreases.Update Balance Handler: The UpdateCredBalance handler ingests the response to any CRED.update requests.How To Use the Blueprint Open the Terminal.Start your aos process.Type in .load-blueprint credUtils Type in CRED.balance What's in the CRED Utils Blueprint:See the aos source code on GitHub for the blueprint shipped in the latest version of aos.luaCRED_PROCESS = "Sa0iBLPNyJQrwpTTG-tWLQU-1QeUAJA73DdxGGiKoJc"
_CRED = { balance = "Your CRED balance has not been checked yet. Updating now." }
local credMeta = {
__index = function(t, key)
-- sends CRED balance request
if key == "update" then
Send({ Target = CRED_PROCESS, Action = "Balance", Tags = { ["Target"] = ao.id } })
return "Balance update requested."
-- prints local CRED balance, requests it if not set
elseif key == "balance" then
if _CRED.balance == "Your CRED balance has not been checked yet. Updating now." then
Send({ Target = CRED_PROCESS, Action = "Balance", Tags = { ["Target"] = ao.id } })
end
return _CRED.balance
-- prints CRED process ID
elseif key == "process" then
return CRED_PROCESS
-- tranfers CRED
elseif key == "send" then
return function(target, amount)
-- ensures amount is string
amount = tostring(amount)
print("sending " .. amount .. "CRED to " .. target)
Send({ Target = CRED_PROCESS, Action = "Transfer", ["Recipient"] = target, ["Quantity"] = amount })
end
else
return nil
end
end
}
CRED = setmetatable({}, credMeta)
-- Function to evaluate if a message is a balance update
local function isCredBalanceMessage(msg)
if msg.From == CRED_PROCESS and msg.Tags.Balance then
return true
else
return false
end
end
-- Function to evaluate if a message is a Debit Notice
local function isDebitNotice(msg)
if msg.From == CRED_PROCESS and msg.Tags.Action == "Debit-Notice" then
return true
else
return false
end
end
-- Function to evaluate if a message is a Credit Notice
local function isCreditNotice(msg)
if msg.From == CRED_PROCESS and msg.Tags.Action == "Credit-Notice" then
return true
else
return false
end
end
local function formatBalance(balance)
-- Ensure balance is treated as a string
balance = tostring(balance)
-- Check if balance length is more than 3 to avoid unnecessary formatting
if #balance > 3 then
-- Insert dot before the last three digits
balance = balance:sub(1, -4) .. "." .. balance:sub(-3)
end
return balance
end
-- Handles Balance messages
Handlers.add(
"UpdateCredBalance",
isCredBalanceMessage,
function(msg)
local balance = nil
if msg.Tags.Balance then
balance = msg.Tags.Balance
end
-- Format the balance if it's not set
if balance then
-- Format the balance by inserting a dot after the first three digits from the right
local formattedBalance = formatBalance(balance)
_CRED.balance = formattedBalance
print("CRED Balance updated: " .. _CRED.balance)
else
print("An error occurred while updating CRED balance")
end
end
)
-- Handles Debit notices
Handlers.add(
"CRED_Debit",
isDebitNotice,
function(msg)
print(msg.Data)
end
)
-- Handles Credit notices
Handlers.add(
"CRED_Credit",
isCreditNotice,
function(msg)
print(msg.Data)
end
)

---

# 78. Installing aos  Cookbook

Document Number: 78
Source: https://cookbook_ao.arweave.net/guides/aos/installing.html
Words: 33
Quality Score: 0.415
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Installing aos Installing aos only requires NodeJS - https://nodejs.org NOTE: If you are on windows you may get better results with WSL Console.Once installed you can run by typing aos

---

# 79. Monitoring Cron  Cookbook

Document Number: 79
Source: https://cookbook_ao.arweave.net/guides/aoconnect/monitoring-cron.html
Words: 73
Quality Score: 0.413
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Monitoring Cron When using cron messages, ao users need a way to start ingesting the messages, using this monitor method, ao users can initiate the subscription service for cron messages. Setting cron tags means that your process will start producing cron results in its outbox, but you need to monitor these results if you want messages from those results to be pushed through the network.You can monitoring by calling unmonitor

---

# 80. Guides  Cookbook

Document Number: 80
Source: https://cookbook_ao.arweave.net/guides/index.html
Words: 215
Quality Score: 0.402
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Guides This section provides detailed guides and documentation to help you build and deploy applications on the AO ecosystem. Whether you're creating chatrooms, autonomous bots, or complex decentralized applications, you'll find step-by-step instructions here.Core Technologies Comprehensive guides for AO's main technologies:AOS: Compute on AO - Learn how to use the AO operating system for distributed computing Introduction to AOS - Get started with the AOS environment Installation Guide - Set up AOS on your system CLI Usage - Learn the command-line interface And more...AO Connect: JavaScript Library - Interact with AO using JavaScript Installation - Set up the AO Connect library Connecting to AO - Establish connections Sending Messages - Communicate with processes And more...Development Tools AO Module Builder CLI - Build WebAssembly modules for AO Installation - Install the development CLI Project Setup - Create your first project Building & Deployment - Compile and deploy modules Utilities & Storage Helpful tools and storage solutions:Using WeaveDrive - Store and manage data with WeaveDrive Using SQLite - Integrate SQLite databases with your AO projects Additional Resources Community Resources - Connect with the AO community Release Notes - Stay updated on the latest changes and features Use the sidebar to browse through specific guides. Each guide provides detailed instructions and examples to help you build on AO.

---

# 81. Welcome to ao  Cookbook

Document Number: 81
Source: https://cookbook_ao.arweave.net/welcome/index.html
Words: 184
Quality Score: 0.402
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Welcome to ao AO is a decentralized compute system where countless parallel processes interact within a single, cohesive environment. Each process operates independently, yet they are seamlessly connected through a native message-passing layer, similar to how websites form the World Wide Web.AO + AOS: The rocket and your rocket fuel.Typically when you use AO, you will interact with it through its operating system: AOS.AOS is an abstraction layer that runs in your processes, making it easy to use the full functionality of the AO computer. In this cookbook, you will learn everything you need to know about getting started with the AO computer using AOS.Mainnet and Legacynet AO Mainnet launched on February 8, 2025, paving the way for a decentralized, open-access supercomputer directly connected to the internet with HyperBEAM.AO Legacynet launched on February 27, 2024, providing a fee-free environment for early adopters to experiment with AO’s hyper-parallel architecture.Legacynet Documentation These tutorials explore AO Legacynet, covering everything from building chatrooms to developing autonomous, decentralized bots. It’s a great starting point for experimenting with AO’s hyper-parallel architecture.Legacynet Tutorials Further References Guides Concepts References

---

# 82. Concepts  Cookbook

Document Number: 82
Source: https://cookbook_ao.arweave.net/concepts/index.html
Words: 200
Quality Score: 0.397
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Concepts This section explains the core concepts and architecture behind AO, helping you understand how the system works at a fundamental level.System Architecture AO is built on a few fundamental principles that form its foundation:Two core types: Messages and Processes - the basic building blocks of the AO ecosystem No shared state, only Holographic State - a unique approach to distributed computing Decentralized Computer (Grid) - enabling truly distributed applications Core Components Explore these foundational concepts to gain a deeper understanding of AO:How it Works - An overview of AO's architecture and how the different parts interact Processes - Learn about processes, the computational units in AO Messages - Understand the messaging system that enables communication Evaluation - Discover how code execution works in the AO environment Units - Learn about the computational units that power the AO network Technical Foundations Specifications - Detailed technical specifications for the AO protocol Getting Started Meet Lua - Introduction to Lua, the programming language used in AO AO System Tour - A guided tour of the AO system and its capabilities Use the sidebar to navigate between concept topics. Each document provides in-depth information about a specific aspect of AO.

---

# 83. Cron Messages  Cookbook

Document Number: 83
Source: https://cookbook_ao.arweave.net/references/cron.html
Words: 249
Quality Score: 0.375
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Cron Messages ao has the ability to generate messages on a specified interval, this interval could be seconds, minutes, hours, or blocks. These messages automatically get evaluated by a monitoring process to inform the Process to evaluate these messages over time. The result is a real-time Process that can communicate with the full ao network or oracles in the outside network.Setting up cron in a process The easiest way to create these cron messages is by spawning a new process in the aos console and defining the time interval.When spawning a new process, you can pass a cron argument in your command line followed by the interval you would like the cron to tick. By default, cron messages are lazily evaluated, meaning they will not be evaluated until the next scheduled message. To initiate these scheduled cron messages, call .monitor in aos - this kicks off a worker process on the mu that triggers the cron messages from the cu. Your Process will then receive cron messages every x-interval.lua.monitor If you wish to triggering the cron messages simply call .unmonitor and this will the triggering process, but the next time you send a message, the generated cron messages will still get created and processed.Handling cron messages Every cron message has an Action tag with the value Cron. Handlers can be defined to perform specific tasks autonomously, each time a cron message is received.Cron messages are a powerful utility that can be used to create "autonomous agents" with expansive capabilities.

---

# 84. CLI  Cookbook

Document Number: 84
Source: https://cookbook_ao.arweave.net/guides/aos/cli.html
Words: 178
Quality Score: 0.368
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content CLI There are some command-line arguments you pass to aos to do the following:[name] - create a new process or loads an existing process for your wallet --load - load a file, you can add one or many of this command --cron - only used when creating a process --wallet - use a specific wallet Managing multiple processes with aos shaos Starts or connects to a process with the name default shaos chatroom Starts or connects to a process with the name of chatroom shaos treasureRoom Starts or connects to a process with the name of treasureRoom Load flag With the load flag I can load many source files to my process CRON Flag If you want to setup your process to react on a schedule we need to tell ao, we do that when we spawn the process.Tag flags With the tag flags, you can start a process with some custom tags (for e.g. using them as static environment variables):The command above will add the extra tags to the transaction that spawns your process:

---

# 85. Modules  Cookbook

Document Number: 85
Source: https://cookbook_ao.arweave.net/guides/aos/modules/index.html
Words: 11
Quality Score: 0.368
Extraction Method: semantic_dom
Extraction Reason: found_content_in_main

Modules Documentation on all the built-in modules for aos.Available Modules JSONaocryptoBase64prettyUtils

---

# 86. Why Migrate to HyperBEAM  Cookbook

Document Number: 86
Source: https://cookbook_ao.arweave.net/guides/migrating-to-hyperbeam/why-migrate.html
Words: 137
Quality Score: 0.367
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Why Migrate to HyperBEAM?Migrating processes from legacynet to HyperBEAM is essential for leveraging significant advancements in performance, features, and developer experience on AO.HyperBEAM is a new, more robust foundation for decentralized applications on AO, offering several key advantages:Enhanced Performance: Built on an architecture optimized for concurrency, HyperBEAM provides faster message scheduling and more responsive applications.Direct State Access: HyperBEAM allows processes to expose their state directly via HTTP. This enables immediate reads of your process's data, eliminating the need for dry-run messages which were a common performance bottleneck.Easy Extensibility: It allows core feature extensibility through modular devices.The most impactful change when migrating is the ability to expose parts of your process state for immediate reading. This dramatically improves the performance of web frontends and data-driven services.To learn how to implement this, see Exposing Process State.

---

# 87. crypto  Cookbook

Document Number: 87
Source: https://cookbook_ao.arweave.net/guides/aos/modules/crypto.html
Words: 2302
Quality Score: 0.362
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

crypto Overview The crypto module provides a set of cryptographic primitives like digests, ciphers and other cryptographic algorithms in pure Lua. It offers several functionalities to hash, encrypt and decrypt data, simplifying the development of secure communication and data storage. This document will guide you through the module's functionalities, installation, and usage.Usage Primitives Digests (sha1, sha2, sha3, keccak, blake2b, etc.) Ciphers (AES, ISSAC, Morus, NORX, etc.) Random Number Generators (ISAAC) MACs (HMAC) KDFs (PBKDF2) Utilities (Array, Stream, Queue, etc.) Digests MD2 Calculates the MD2 digest of a given message.Parameters:stream (Stream): The message in form of stream Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:MD4 Calculates the MD4 digest of a given message.Parameters:stream (Stream): The message in form of stream Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:MD5 Calculates the MD5 digest of a given message.Parameters:stream (Stream): The message in form of stream Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:SHA1 Calculates the SHA1 digest of a given message.Parameters:stream (Stream): The message in form of stream Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:SHA2_256 Calculates the SHA2-256 digest of a given message.Parameters:stream (Stream): The message in form of stream Returns: A table containing functions to get digest in different formats. asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:SHA2_512 Calculates the SHA2-512 digest of a given message.Parameters:msg (string): The message to calculate the digest Returns: A table containing functions to get digest in different formats. asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:SHA3 It contains the following functions:sha3_256 sha3_512 keccak256 keccak512 Each function calculates the respective digest of a given message.Parameters:msg (string): The message to calculate the digest Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example:Blake2b Calculates the Blake2b digest of a given message.Parameters:data (string): The data to be hashed.outlen (number): The length of the output hash (optional) default is 64.key (string): The key to be used for hashing (optional) default is "".Returns: A table containing functions to get digest in different formats.asBytes(): The digest as byte table.asHex(): The digest as string in hexadecimal format.asString(): The digest as string format.Example: Ciphers AES The Advanced Encryption Standard (AES) is a symmetric block cipher used to encrypt sensitive information. It has two functions encrypt and decrypt.Encrypt Encrypts a given message using the AES algorithm.Parameters:data (string): The data to be encrypted.key (string): The key to be used for encryption.iv (string) optional: The initialization vector to be used for encryption. default is "" mode (string) optional: The mode of operation to be used for encryption. default is "CBC". Available modes are CBC, ECB, CFB, OFB, CTR.keyLength (number) optional: The length of the key to use for encryption. default is 128.Returns: A table containing functions to get encrypted data in different formats.asBytes(): The encrypted data as byte table.asHex(): The encrypted data as string in hexadecimal format.asString(): The encrypted data as string format.Decrypt Decrypts a given message using the AES algorithm.Parameters:cipher (string): Hex Encoded encrypted data.key (string): The key to be used for decryption.iv (string) optional: The initialization vector to be used for decryption. default is "" mode (string) optional: The mode of operation to be used for decryption. default is "CBC". Available modes are CBC, ECB, CFB, OFB, CTR.keyLength (number) optional: The length of the key to use for decryption. default is 128.Returns: A table containing functions to get decrypted data in different formats.asBytes(): The decrypted data as byte table.asHex(): The decrypted data as string in hexadecimal format.asString(): The decrypted data as string format.Example:ISSAC Cipher ISAAC is a cryptographically secure pseudo-random number generator (CSPRNG) and stream cipher. It has the following functions seedIsaac: Seeds the ISAAC cipher with a given seed.getRandomChar: Generates a random character using the ISAAC cipher.random: Generates a random number between a given range using the ISAAC cipher.getRandom: Generates a random number using the ISAAC cipher.encrypt: Encrypts a given message using the ISAAC cipher.decrypt: Decrypts a given message using the ISAAC cipher.Encrypt Encrypts a given message using the ISAAC cipher.Parameters:msg (string): The message to be encrypted.key (string): The key to be used for encryption.Returns: A table containing functions to get encrypted data in different formats. asBytes(): The encrypted data as byte table.asHex(): The encrypted data as string in hexadecimal format.asString(): The encrypted data as string format.Decrypt Decrypts a given message using the ISAAC cipher.Parameters:cipher (string): Hex Encoded encrypted data.key (string): Key to be used for decryption.Returns: A table containing functions to get decrypted data in different formats. asBytes(): The decrypted data as byte table.asHex(): The decrypted data as string in hexadecimal format.asString(): The decrypted data as string format.Example:random Generates a random number using the ISAAC cipher.Parameters:min (number) optional: The minimum value of the random number. defaults to 0.max (number) optional: The maximum value of the random number. defaults to 2^31 - 1.seed (string) optional: The seed to be used for generating the random number. defaults to math.random(0,2^32 - 1).Returns: A random number between the given range.Example:Morus Cipher MORUS is a high-performance authenticated encryption algorithm submitted to the CAESAR competition, and recently selected as a finalist.Encrypt Encrypts a given message using the MORUS cipher.Parameters:key (string): The encryption key (16 or 32-byte string).iv (string): The nonce or initial value (16-byte string).msg (string): The message to encrypt (variable length string).ad (string) optional: The additional data (variable length string). defaults to "".Returns: A table containing functions to get encrypted data in different formats. asBytes(): The encrypted data as byte table.asHex(): The encrypted data as string in hexadecimal format.asString(): The encrypted data as string format.Decrypt Decrypts a given message using the MORUS cipher.Parameters:key (string): The encryption key (16 or 32-byte string).iv (string): The nonce or initial value (16-byte string).cipher (string): The encrypted message (variable length string).adLen (number) optional: The length of the additional data (variable length string). defaults to 0.Returns: A table containing functions to get decrypted data in different formats. asBytes(): The decrypted data as byte table.asHex(): The decrypted data as string in hexadecimal format.asString(): The decrypted data as string format.Example:NORX Cipher NORX is an authenticated encryption scheme with associated data that was selected, along with 14 other primitives, for the third phase of the ongoing CAESAR competition. It is based on the sponge construction and relies on a simple permutation that allows efficient and versatile implementations.Encrypt Encrypts a given message using the NORX cipher.Parameters:key (string): The encryption key (32-byte string).nonce (string): The nonce or initial value (32-byte string).plain (string): The message to encrypt (variable length string).header (string) optional: The additional data (variable length string). defaults to "".trailer (string) optional: The additional data (variable length string). defaults to "".Returns: A table containing functions to get encrypted data in different formats. asBytes(): The encrypted data as byte table.asHex(): The encrypted data as string in hexadecimal format.asString(): The encrypted data as string format.Decrypt Decrypts a given message using the NORX cipher.Parameters:key (string): The encryption key (32-byte string).nonce (string): The nonce or initial value (32-byte string).crypted (string): The encrypted message (variable length string).header (string) optional: The additional data (variable length string). defaults to "".trailer (string) optional: The additional data (variable length string). defaults to "".Returns: A table containing functions to get decrypted data in different formats. asBytes(): The decrypted data as byte table.asHex(): The decrypted data as string in hexadecimal format.asString(): The decrypted data as string format.Example: Random Number Generators The module contains a random number generator using ISAAC which is a cryptographically secure pseudo-random number generator (CSPRNG) and stream cipher.Parameters:min (number) optional: The minimum value of the random number. defaults to 0.max (number) optional: The maximum value of the random number. defaults to 2^31 - 1.seed (string) optional: The seed to be used for generating the random number. defaults to math.random(0,2^32 - 1).Returns: A random number between the given range.Example: MACs HMAC The Hash-based Message Authentication Code (HMAC) is a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.The modules exposes a function called createHmac which is used to create a HMAC instance.Parameters:data (Stream): The data to be hashed.key (Array): The key to be used for hashing.algorithm (string) optional: The algorithm to be used for hashing. default is "sha256". Available algorithms are "sha1", "sha256". default is "sha1".Returns: A table containing functions to get HMAC in different formats. asBytes(): The HMAC as byte table.asHex(): The HMAC as string in hexadecimal format.asString(): The HMAC as string format.Example: KDFs PBKDF2 The Password-Based Key Derivation Function 2 (PBKDF2) applies a pseudorandom function, such as hash-based message authentication code (HMAC), to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used as a cryptographic key in subsequent operations.Parameters:password (Array): The password to derive the key from.salt (Array): The salt to use.iterations (number): The number of iterations to perform.keyLen (number): The length of the key to derive.digest (string) optional: The digest algorithm to use. default is "sha1". Available algorithms are "sha1", "sha256".Returns: A table containing functions to get derived key in different formats. asBytes(): The derived key as byte table.asHex(): The derived key as string in hexadecimal format.asString(): The derived key as string format.Example: Utilities Array Example Usage:size Returns the size of the array.Parameters:arr (Array): The array to get the size of.Returns: The size of the array.fromString Creates an array from a string.Parameters:str (string): The string to create the array from.Returns: The array created from the string.toString Converts an array to a string.Parameters:arr (Array): The array to convert to a string.Returns: The array as a string.fromStream Creates an array from a stream.Parameters:stream (Stream): The stream to create the array from.Returns: The array created from the stream.readFromQueue Reads data from a queue and stores it in the array.Parameters:queue (Queue): The queue to read data from.size (number): The size of the data to read.Returns: The array containing the data read from the queue.writeToQueue Writes data from the array to a queue.Parameters:queue (Queue): The queue to write data to.array (Array): The array to write data from.Returns: None toStream Converts an array to a stream.Parameters:arr (Array): The array to convert to a stream.Returns: (Stream) The array as a stream.fromHex Creates an array from a hexadecimal string.Parameters:hex (string): The hexadecimal string to create the array from.Returns: The array created from the hexadecimal string.toHex Converts an array to a hexadecimal string.Parameters:arr (Array): The array to convert to a hexadecimal string.Returns: The array as a hexadecimal string.concat Concatenates two arrays.Parameters:a (Array): The array to concatenate with.b (Array): The array to concatenate.Returns: The concatenated array.truncate Truncates an array to a given length.Parameters:a (Array): The array to truncate.newSize (number): The new size of the array.Returns: The truncated array.XOR Performs a bitwise XOR operation on two arrays.Parameters:a (Array): The first array.b (Array): The second array.Returns: The result of the XOR operation.substitute Creates a new array with keys of first array and values of second Parameters:input (Array): The array to substitute.sbox (Array): The array to substitute with.Returns: The substituted array.permute Creates a new array with keys of second array and values of first array.Parameters:input (Array): The array to permute.pbox (Array): The array to permute with.Returns: The permuted array.copy Creates a copy of an array.Parameters:input (Array): The array to copy.Returns: The copied array.slice Creates a slice of an array.Parameters:input (Array): The array to slice.start (number): The start index of the slice. (number): The end index of the slice.Returns: The sliced array. Stream Stream is a data structure that represents a sequence of bytes. It is used to store and manipulate data in a streaming fashion.Example Usage:fromString Creates a stream from a string.Parameters:str (string): The string to create the stream from.Returns: The stream created from the string.toString Converts a stream to a string.Parameters:stream (Stream): The stream to convert to a string.Returns: The stream as a string.fromArray Creates a stream from an array.Parameters:arr (Array): The array to create the stream from.Returns: The stream created from the array.toArray Converts a stream to an array.Parameters:stream (Stream): The stream to convert to an array.Returns: The stream as an array.fromHex Creates a stream from a hexadecimal string.Parameters:hex (string): The hexadecimal string to create the stream from.Returns: The stream created from the hexadecimal string.toHex Converts a stream to a hexadecimal string.Parameters:stream (Stream): The stream to convert to a hexadecimal string.Returns: The stream as a hexadecimal string. Hex Example Usage:hexToString Converts a hexadecimal string to a string.Parameters:hex (string): The hexadecimal string to convert to a string.Returns: The hexadecimal string as a string.stringToHex Converts a string to a hexadecimal string.Parameters:str (string): The string to convert to a hexadecimal string.Returns: The string as a hexadecimal string. Queue Queue is a data structure that represents a sequence of elements. It is used to store and manipulate data in a first-in, first-out (FIFO) fashion.Example Usage:push Pushes an element to the queue.Parameters:queue (Queue): The queue to push the element to.element (any): The element to push to the queue.Returns: None pop Pops an element from the queue.Parameters:queue (Queue): The queue to pop the element from.element (any): The element to pop from the queue.Returns: The popped element.size Returns the size of the queue.Parameters: None Returns: The size of the queue.getHead Returns the head of the queue.Parameters: None Returns: The head of the queue.getTail Returns the tail of the queue.Parameters: None Returns: The tail of the queue.reset Resets the queue.Parameters: None

---

# 88. Release Notes  Cookbook

Document Number: 88
Source: https://cookbook_ao.arweave.net/releasenotes/index.html
Words: 181
Quality Score: 0.349
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Skip to content Release Notes This section provides detailed information about updates, new features, bug fixes, and changes in each release of AO and its related tools. Release notes are essential for understanding what's changed between versions and how these changes might affect your projects.AOS Releases AOS is the operating system built on top of the AO computer. These release notes document changes and improvements to AOS:AOS 2.0.2 - Improved spawn process times and various bug fixes AOS 2.0.1 - Details about patch updates and fixes in the 2.0.1 release AOS 2.0.0 - Major release information, including new features and significant changes Why Read Release Notes?Release notes provide valuable information for developers:Learn about new features that could enhance your applications Understand potential breaking changes that might affect existing code Discover bug fixes that resolve issues you may have encountered Stay informed about security updates and best practices We recommend reviewing release notes before upgrading to a new version to ensure a smooth transition.Use the sidebar to navigate between different release notes. Notes are organized chronologically with the most recent releases first.

---

# 89. Sending an Assignment to a Process  Cookbook

Document Number: 89
Source: https://cookbook_ao.arweave.net/guides/aoconnect/assign-data.html
Words: 202
Quality Score: 0.324
Extraction Method: defuddle_semantic
Extraction Reason: defuddle_returned_html_semantic_extracted

Sending an Assignment to a Process Assignments can be used to load Data from another Message into a Process. Or to not duplicate Messages. You can create one Message and then assign it to any number of processes. This will make it available to the Processes you have sent an Assignment to.Sending an Assignment in NodeJS Excluding DataItem fields You can also exclude most DataItem fields which will tell the CU not to load them into your process. You may want to do this if you need only the header data like the Tags and not the Data itself etc... If you exclude the Owner it wont have any effect because the CU requires the Owner, so excluding Owner will be ignored by the CU. Only capitalized DataItem/Message fields will have an effect in the CU.Assigning L1 Transactions You can also assign a layer 1 transaction by passing the baseLayer param into assign. This is useful for minting tokens etc... using the base layer. By default, if the L1 tx does not have at least 20 confirmations the SU will reject it. This can be changed by setting the Settlement-Depth tag to a different number on the Process when it is created.
