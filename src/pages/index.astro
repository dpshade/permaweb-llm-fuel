---
// Main page for Permaweb LLMs Builder
import '../styles/theme.css';
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta
			name="description"
			content="Interactive tool to select and curate Permaweb documentation into llms.txt format for AI training"
		/>
		<title>Permaweb LLMs Builder</title>

		<!-- Custom checkbox styling -->
		<style>
			input[type="checkbox"] {
				appearance: none;
				-webkit-appearance: none;
				width: 18px;
				height: 18px;
				/* Use theme accent color for default border */
				border: 2px solid var(--ao-accent-color);
				border-radius: 4px;
				background-color: white;
				cursor: pointer;
				position: relative;
				transition: all 0.2s ease;
			}

			input[type="checkbox"]:checked {
				background-color: var(--ao-accent-color);
				border-color: var(--ao-accent-color);
			}

			input[type="checkbox"]:checked::after {
				content: "✓";
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: white;
				font-size: 12px;
				font-weight: bold;
			}

			input[type="checkbox"]:focus {
				outline: 2px solid var(--ao-accent-color);
				outline-offset: 2px;
			}

			input[type="checkbox"]:hover {
				border-color: var(--ao-accent-color);
			}

			input[type="checkbox"]:indeterminate {
				background-color: var(--ao-accent-color);
				border-color: var(--ao-accent-color);
			}

			input[type="checkbox"]:indeterminate::after {
				content: "−";
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				color: white;
				font-size: 14px;
				font-weight: bold;
				line-height: 1;
			}

			/* Dark theme adjustments */
			[data-theme="dark"] input[type="checkbox"] {
				/* Keep accent border in dark mode while using input background */
				border-color: var(--ao-accent-color);
				background-color: var(--ao-input-bg);
			}

			[data-theme="dark"] input[type="checkbox"]:hover {
				border-color: var(--ao-accent-color);
			}

			[data-theme="dark"] input[type="checkbox"]:indeterminate {
				background-color: var(--ao-accent-color);
				border-color: var(--ao-accent-color);
			}

			/* Remove outdated selector for bolding page labels (handled inline) */

			/* Pulse animation for skeleton loading */
			@keyframes pulse {
				0%, 100% {
					opacity: 1;
				}
				50% {
					opacity: 0.5;
				}
			}
		</style>

		<!-- Iframe compatibility headers -->
		<meta http-equiv="X-Frame-Options" content="ALLOWALL" />
		<meta
			http-equiv="Content-Security-Policy"
			content="frame-ancestors *;"
		/>
	</head>

	<body>
		<!-- Theme Toggle Button -->
		<button class="theme-toggle" aria-label="Toggle theme">
			<svg
				class="sun-icon"
				fill="none"
				stroke="currentColor"
				viewBox="0 0 24 24"
			>
				<circle cx="12" cy="12" r="5"></circle>
				<line x1="12" y1="1" x2="12" y2="3"></line>
				<line x1="12" y1="21" x2="12" y2="23"></line>
				<line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
				<line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
				<line x1="1" y1="12" x2="3" y2="12"></line>
				<line x1="21" y1="12" x2="23" y2="12"></line>
				<line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
				<line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
			</svg>
			<svg
				class="moon-icon"
				fill="none"
				stroke="currentColor"
				viewBox="0 0 24 24"
			>
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
				></path>
			</svg>
		</button>

		<!-- Main Container -->
		<div class="main-container">
			<h1>Permaweb LLMs Builder</h1>

			<!-- Documentation Tree -->
			<div id="loading-message" style="display: none;">
				<h3>Loading Documentation Index</h3>
				<p>
					Loading curated documentation from the Permaweb ecosystem...
				</p>
			</div>
			<div id="docs-tree">
				<!-- Optimistic UI - shows immediately -->
				<div id="optimistic-tree">
					<div style="margin-bottom: 16px; font-size: 14px; color: var(--ao-secondary-text);">
						Loading documentation from the Permaweb ecosystem...
					</div>
					<div id="tree-root" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;">
						<!-- Skeleton structure -->
						<div style="margin-bottom: 8px;">
							<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; opacity: 0.6;">
								<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<svg style="width: 16px; height: 16px; opacity: 0.5;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<circle cx="12" cy="12" r="10" stroke="#666" stroke-width="2"/>
									<path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" stroke="#666" stroke-width="2"/>
								</svg>
								<div style="height: 20px; width: 120px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<div style="height: 16px; width: 60px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite; margin-left: 8px;"></div>
							</div>
							<div style="margin-left: 24px;">
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.4;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 200px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.4;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 160px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.4;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 180px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
							</div>
						</div>
						<div style="margin-bottom: 8px;">
							<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; opacity: 0.5;">
								<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<svg style="width: 16px; height: 16px; opacity: 0.5;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<circle cx="12" cy="12" r="10" stroke="#666" stroke-width="2"/>
									<path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" stroke="#666" stroke-width="2"/>
								</svg>
								<div style="height: 20px; width: 140px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<div style="height: 16px; width: 50px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite; margin-left: 8px;"></div>
							</div>
							<div style="margin-left: 24px;">
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.3;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 220px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.3;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 150px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
							</div>
						</div>
						<div style="margin-bottom: 8px;">
							<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; opacity: 0.4;">
								<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<svg style="width: 16px; height: 16px; opacity: 0.5;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<circle cx="12" cy="12" r="10" stroke="#666" stroke-width="2"/>
									<path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" stroke="#666" stroke-width="2"/>
								</svg>
								<div style="height: 20px; width: 100px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								<div style="height: 16px; width: 70px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite; margin-left: 8px;"></div>
							</div>
							<div style="margin-left: 24px;">
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; opacity: 0.2;">
									<div style="width: 18px; height: 18px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
									<div style="height: 16px; width: 190px; background-color: var(--ao-category-bg); border-radius: 4px; animation: pulse 2s infinite;"></div>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<!-- Progress Container -->
			<div
				class="progress-container"
				id="progress-container"
				style="display: none;"
			>
				<div class="progress-bar">
					<div class="progress-fill" id="progress-fill"></div>
				</div>
				<div class="progress-text" id="progress-text">
					Processing...
				</div>
			</div>

			<!-- Selection Counter -->
			<div class="selection-counter">
				<div
					class="selection-header"
					style="display: flex; align-items: center; gap: 8px; cursor: pointer; justify-content: space-between;"
					onclick="toggleSelectionDetails()"
				>
					<div style="display: flex; align-items: center; gap: 8px;">
						<strong id="selection-count">0</strong> pages selected
						<svg
							id="selection-toggle"
							style="width: 12px; height: 12px; transition: transform 0.2s ease;"
							viewBox="0 0 24 24"
							fill="none"
							xmlns="http://www.w3.org/2000/svg"
						>
							<path
								fill-rule="evenodd"
								clip-rule="evenodd"
								d="M13.9394 12.0001L8.46973 6.53039L9.53039 5.46973L16.0607 12.0001L9.53039 18.5304L8.46973 17.4697L13.9394 12.0001Z"
								fill="#666"></path>
						</svg>
					</div>
					<div
						id="estimated-chars"
						style="font-style: italic; font-size: 12px; color: var(--ao-secondary-text);"
					>
					</div>
				</div>
				<div
					id="selection-details"
					style="display: none; margin-top: 12px; max-height: 200px; overflow-y: auto;"
				>
					<div
						id="selected-pages-list"
						style="font-size: 14px; color: var(--ao-secondary-text);"
					>
					</div>
				</div>
			</div>

			<!-- Action Buttons -->
			<div class="action-buttons">
				<button class="btn btn-primary" id="generate-btn" disabled>
					Generate llms.txt
				</button>
				<button class="btn" id="select-all-btn"> Select All </button>
				<button class="btn" id="clear-all-btn"> Clear All </button>
			</div>
		</div>

		<!-- Main JavaScript -->
		<script type="module">
			import { initializeAllTheme } from "/src/utils/theme.js";
			import {
				batchFetchAndClean,
				generateLLMsTxt,
				downloadFile,
			} from "/src/utils/defuddle-fetch.js";



			// Initialize theme system
			initializeAllTheme();

			// State management
			let docsIndex = null;
			let displayTree = null;
			let selectedPages = new Set();
			let allPages = [];

			// DOM elements
			const docsTree = document.getElementById("docs-tree");
			const loadingMessage = document.getElementById("loading-message");
			const selectionCount = document.getElementById("selection-count");
			const generateBtn = document.getElementById("generate-btn");
			const selectAllBtn = document.getElementById("select-all-btn");
			const clearAllBtn = document.getElementById("clear-all-btn");
			const progressContainer =
				document.getElementById("progress-container");
			const progressFill = document.getElementById("progress-fill");
			const progressText = document.getElementById("progress-text");
			const selectionDetails =
				document.getElementById("selection-details");
			const selectionToggle = document.getElementById("selection-toggle");
			const selectedPagesList = document.getElementById(
				"selected-pages-list",
			);

			// Initialize the application
			async function initialize() {
				await loadDocumentationIndex();
			}

			// Load documentation index with Vercel primary and local fallback
			async function loadDocumentationIndex() {
				try {
					updateLoadingMessage(
						"Loading Documentation Index",
						"Fetching latest documentation from Vercel endpoint...",
					);

					// Try loading from Vercel JSON endpoint first
					let response;
					try {
						// TODO: Replace with your actual Vercel JSON project URL
						const vercelJsonUrl = "https://permaweb-docs-index.vercel.app/docs-index.json";
						response = await fetch(vercelJsonUrl);
						
						if (!response.ok) {
							throw new Error(`Vercel endpoint failed: ${response.status}`);
						}
						
						console.log("Successfully loaded from Vercel JSON endpoint");
					} catch (vercelError) {
						console.warn("Vercel endpoint failed, trying local fallback:", vercelError.message);
						
						updateLoadingMessage(
							"Loading Documentation Index",
							"Vercel endpoint unavailable, loading local index...",
						);
						
						// Fallback to local static index
						response = await fetch("/docs-index.json");
						if (!response.ok) {
							throw new Error(
								`Local index also failed: ${response.status}`,
							);
						}
						
						console.log("Loaded from local fallback");
					}

					docsIndex = await response.json();

					// Process the index into display format
					displayTree = processIndex(docsIndex);
					allPages = extractAllPages(docsIndex);

					// Render the tree
					renderDocumentationTree();

					// Loading message is already hidden by default with optimistic UI

					console.log(
						`Loaded documentation index: ${allPages.length} total pages from ${Object.keys(docsIndex).length} sites`,
					);
				} catch (error) {
					console.error("Failed to load documentation index:", error);
					showError(
						`Failed to load documentation index: ${error.message}`,
					);
				}
			}



			// Process index into display format
			function processIndex(index) {
				const processed = {};

				for (const [siteKey, siteData] of Object.entries(index)) {
					// Skip metadata entries
					if (siteKey === '_metadata') continue;
					
					processed[siteKey] = {
						name: siteData.name,
						description: siteData.description,
						pages: siteData.pages || [],
						crawledAt: siteData.crawledAt,
					};
				}

				return processed;
			}

			// Extract all pages from index
			function extractAllPages(index) {
				const pages = [];

				for (const [siteKey, siteData] of Object.entries(index)) {
					// Skip metadata entries
					if (siteKey === '_metadata') continue;
					
					// Use the flat pages array directly from the JSON structure
					if (siteData.pages && Array.isArray(siteData.pages)) {
						for (const page of siteData.pages) {
							// Use existing estimatedWords or calculate from title
							const estimatedWords = page.estimatedWords || Math.max(300, page.title.length * 15);
							const estimatedChars = Math.round(estimatedWords * 5.5);

							pages.push({
								...page,
								siteKey,
								siteName: siteData.name,
								estimatedWords: estimatedWords,
								estimatedChars: estimatedChars,
							});
						}
					}
				}

				return pages;
			}

			// Render documentation tree - flat list with breadcrumb paths
			function renderDocumentationTree() {
				if (!allPages.length) return;

				const totalPages = allPages.length;
				const siteCount = Object.keys(displayTree).length;

				// Sort pages by site name, then by breadcrumb path
				const sortedPages = [...allPages].sort((a, b) => {
					if (a.siteName !== b.siteName) {
						return a.siteName.localeCompare(b.siteName);
					}
					const pathA = a.breadcrumbs ? a.breadcrumbs.join(' / ') : '';
					const pathB = b.breadcrumbs ? b.breadcrumbs.join(' / ') : '';
					return pathA.localeCompare(pathB);
				});

				const treeHtml = `
					<div style="margin-bottom: 16px; font-size: 14px; color: var(--ao-secondary-text);">
						${totalPages} pages from ${siteCount} sites
					</div>
					<div id="tree-root" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;">
						${renderSitesWithPages(sortedPages)}
					</div>
				`;

				// Smooth transition from optimistic to real content
				const optimisticTree = document.getElementById('optimistic-tree');
				if (optimisticTree) {
					optimisticTree.style.opacity = '0';
					optimisticTree.style.transition = 'opacity 0.3s ease';
					
					setTimeout(() => {
						docsTree.innerHTML = treeHtml;
						docsTree.style.opacity = '0';
						docsTree.style.transition = 'opacity 0.3s ease';
						requestAnimationFrame(() => {
							docsTree.style.opacity = '1';
							// Add event listeners after DOM is fully rendered and visible
							addTreeEventListeners();
						});
					}, 300);
				} else {
					docsTree.innerHTML = treeHtml;
					// Add event listeners immediately when no transition
					addTreeEventListeners();
				}
				
				// Select all pages by default
				allPages.forEach(page => {
					selectedPages.add(page.url);
				});
				
				updateSelectionCount();
			}



			// Render sites with their pages grouped together
			function renderSitesWithPages(sortedPages) {
				// Group pages by site
				const pagesBySite = {};
				sortedPages.forEach((page) => {
					if (!pagesBySite[page.siteKey]) {
						pagesBySite[page.siteKey] = {
							siteName: page.siteName,
							pages: [],
						};
					}
					pagesBySite[page.siteKey].pages.push(page);
				});

				// Render each site with its pages
				return Object.entries(pagesBySite)
					.map(([siteKey, siteData]) => {
						const sitePageCount = siteData.pages.length;

						// Site header with expand/collapse
						let html = `
						<div style="margin-bottom: 8px;">
							<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
								<input type="checkbox" id="site-${siteKey}" class="site-checkbox" data-site="${siteKey}" checked>
								<div style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;" onclick="toggleNode('site-${siteKey}')">
									<svg style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
										<circle cx="12" cy="12" r="10" stroke="#666" stroke-width="2"/>
										<path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" stroke="#666" stroke-width="2"/>
									</svg>
									<label style="cursor: pointer; font-weight: 500; font-size: 15px; color: var(--ao-text-color); pointer-events: none;">${siteData.siteName}</label>
									<span style="font-size: 12px; color: var(--ao-secondary-text);">${sitePageCount} pages</span>
									<svg class="tree-toggle" id="toggle-site-${siteKey}" style="width: 12px; height: 12px; transition: transform 0.2s ease; margin-left: auto;" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
										<path fill-rule="evenodd" clip-rule="evenodd" d="M13.9394 12.0001L8.46973 6.53039L9.53039 5.46973L16.0607 12.0001L9.53039 18.5304L8.46973 17.4697L13.9394 12.0001Z" fill="#666"/>
									</svg>
								</div>
							</div>
							<div id="site-${siteKey}-children" style="display: none;">
					`;

						// Site pages with breadcrumb paths
						siteData.pages.forEach((page) => {
							const pageId = `page-${page.siteKey}-${page.url.replace(/[^a-zA-Z0-9]/g, "-")}`;
							const breadcrumbPath = page.breadcrumbs && page.breadcrumbs.length > 0 
								? page.breadcrumbs.join(' / ') 
								: 'Root';
							
							const specificTitle = generateSpecificTitle(page);
							html += `
								<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; padding: 2px 0; margin-left: 24px;">
									<input type="checkbox" id="${pageId}" class="page-checkbox" data-url="${page.url}" data-site="${page.siteKey}" checked>
									<label for="${pageId}" style="cursor: pointer; font-size: 14px; font-weight: 500; color: var(--ao-text-color);">${specificTitle}</label>
									<a href="${page.url}" target="_blank" rel="noopener noreferrer" style="font-size: 12px; color: var(--ao-secondary-text); margin-left: 8px; text-decoration: none; cursor: pointer;" 
									   onmouseover="this.style.textDecoration='underline'" 
									   onmouseout="this.style.textDecoration='none'">
										${breadcrumbPath}
									</a>
								</div>
							`;
						});

						// Close the collapsible section and add spacing
						html += `
							</div>
						</div>
						<div style="margin-bottom: 16px;"></div>
					`;

						return html;
					})
					.join("");
			}

			// Global function for toggling tree nodes
			window.toggleNode = function (nodeId) {
				const children = document.getElementById(nodeId + "-children");
				const toggle = document.getElementById("toggle-" + nodeId);
				if (children && toggle) {
					const isExpanded = children.style.display !== "none";
					children.style.display = isExpanded ? "none" : "block";
					toggle.style.transform = isExpanded
						? "rotate(0deg)"
						: "rotate(90deg)";
				}
			};

			// Global function for toggling selection details
			window.toggleSelectionDetails = function () {
				const isExpanded = selectionDetails.style.display !== "none";
				selectionDetails.style.display = isExpanded ? "none" : "block";
				selectionToggle.style.transform = isExpanded
					? "rotate(0deg)"
					: "rotate(90deg)";
			};

			// Add event listeners to tree
			function addTreeEventListeners() {
				// Site checkboxes
				document
					.querySelectorAll(".site-checkbox")
					.forEach((checkbox) => {
						checkbox.addEventListener("change", (e) => {
							const siteKey = e.target.dataset.site;
							const isChecked = e.target.checked;

							// Toggle all pages in this site
							const sitePageCheckboxes = document.querySelectorAll(
								`input[data-site="${siteKey}"].page-checkbox`,
							);
							
							sitePageCheckboxes.forEach((pageCheckbox) => {
								pageCheckbox.checked = isChecked;
								const url = pageCheckbox.dataset.url;
								
								// Update selectedPages set directly
								if (isChecked) {
									selectedPages.add(url);
								} else {
									selectedPages.delete(url);
								}
							});
							
							// Update UI once after all changes
							updateSelectionCount();
						});
					});

				// Page checkboxes
				document
					.querySelectorAll(".page-checkbox")
					.forEach((checkbox) => {
						checkbox.addEventListener("change", (e) => {
							handlePageSelection(e.target, e.target.checked);
						});
					});
			}

			// Handle page selection
			function handlePageSelection(checkbox, isChecked) {
				const url = checkbox.dataset.url;

				if (isChecked) {
					selectedPages.add(url);
				} else {
					selectedPages.delete(url);
				}

				updateSelectionCount();
				updateSiteCheckboxes();
			}

			// Update site checkboxes based on their page selections
			function updateSiteCheckboxes() {
				document.querySelectorAll(".site-checkbox").forEach((siteCheckbox) => {
					const siteKey = siteCheckbox.dataset.site;
					const sitePageCheckboxes = document.querySelectorAll(
						`input[data-site="${siteKey}"].page-checkbox`
					);
					
					const checkedPages = Array.from(sitePageCheckboxes).filter(cb => cb.checked);
					
					// Update site checkbox state
					if (checkedPages.length === 0) {
						siteCheckbox.checked = false;
						siteCheckbox.indeterminate = false;
					} else if (checkedPages.length === sitePageCheckboxes.length) {
						siteCheckbox.checked = true;
						siteCheckbox.indeterminate = false;
					} else {
						siteCheckbox.checked = false;
						siteCheckbox.indeterminate = true;
					}
				});
			}

			// Generate defuddle title (stripped, no spaces, no #, no MD, just raw text)
			function generateDefuddleTitle(title) {
				if (!title) return 'Untitled';
				
				let cleaned = title;
				
				// Remove common site suffixes like " | Cookbook", " | Documentation", etc.
				cleaned = cleaned.replace(/\s*[|\-–—]\s*(Cookbook|Documentation|Docs|Guide|Tutorial|Help|Support|Home|Index|Main|Page)\s*$/i, '');
				
				// Remove leading/trailing whitespace
				cleaned = cleaned.trim();
				
				// Remove markdown formatting
				cleaned = cleaned.replace(/[#*_`]/g, '');
				
				// Clean up extra whitespace
				cleaned = cleaned.replace(/\s+/g, ' ').trim();
				
				return cleaned || 'Untitled';
			}

			// Truncate text with ellipsis
			function truncateText(text, maxLength = 55) {
				if (!text || text.length <= maxLength) return text;
				return text.substring(0, maxLength - 3) + '...';
			}

			// Generate more specific title using breadcrumbs and context
			function generateSpecificTitle(page) {
				if (!page) return 'Untitled';
				
				// Start with defuddle title as baseline
				const defuddleTitle = generateDefuddleTitle(page.title);
				
				// If no breadcrumbs or just filename, return truncated defuddle title
				if (!page.breadcrumbs || page.breadcrumbs.length === 0) {
					return truncateText(defuddleTitle);
				}
				
				// Extract meaningful breadcrumb context (ignore file extensions and generic terms)
				const meaningfulCrumbs = page.breadcrumbs
					.filter(crumb => {
						// Remove file extensions and generic terms
						const cleaned = crumb.replace(/\.(html?|php|aspx?)$/i, '').toLowerCase();
						return cleaned !== 'index' && 
							   cleaned !== 'main' && 
							   cleaned !== 'home' && 
							   cleaned !== 'default' &&
							   cleaned.length > 1;
					})
					.map(crumb => {
						// Clean and format breadcrumb
						let formatted = crumb.replace(/\.(html?|php|aspx?)$/i, '');
						formatted = formatted.replace(/[-_]/g, ' ');
						return formatted.charAt(0).toUpperCase() + formatted.slice(1);
					});
				
				// If we have meaningful breadcrumbs, try to create a more specific title
				if (meaningfulCrumbs.length > 0) {
					const context = meaningfulCrumbs.join(' / ');
					
					// Check if the defuddle title already contains the context
					const titleLower = defuddleTitle.toLowerCase();
					const contextLower = context.toLowerCase();
					
					// If title already includes the context, just return truncated defuddle title
					if (titleLower.includes(contextLower) || contextLower.includes(titleLower)) {
						return truncateText(defuddleTitle);
					}
					
					// Create contextual title - but keep it concise
					// Only add context if it's not too long and adds value
					if (context.length < 30 && meaningfulCrumbs.length <= 2) {
						const fullTitle = `${defuddleTitle} (${context})`;
						return truncateText(fullTitle);
					}
				}
				
				return truncateText(defuddleTitle);
			}

			// Update selection count
			function updateSelectionCount() {
				const selectedCount = selectedPages.size;
				const estimatedCharsElement =
					document.getElementById("estimated-chars");

				// Update the basic count
				selectionCount.textContent = selectedCount.toString();

				// Calculate total estimated characters for selected pages
				let totalEstimatedChars = 0;
				selectedPages.forEach((url) => {
					const page = allPages.find((p) => p.url === url);
					if (page && page.estimatedChars) {
						totalEstimatedChars += page.estimatedChars;
					}
				});

				// Format the character count for display
				const formatChars = (chars) => {
					if (chars < 1000) return `${chars} chars`;
					if (chars < 1000000)
						return `${(chars / 1000).toFixed(1)}K chars`;
					return `${(chars / 1000000).toFixed(1)}M chars`;
				};

				// Update estimated characters display
				if (selectedCount === 0 || totalEstimatedChars === 0) {
					estimatedCharsElement.textContent = "";
				} else {
					estimatedCharsElement.textContent = `≈${formatChars(totalEstimatedChars)}`;
				}

				generateBtn.disabled = selectedCount === 0;
				updateSelectedPagesList();
			}

			// Update the selected pages list with breadcrumb paths
			function updateSelectedPagesList() {
				if (selectedPages.size === 0) {
					selectedPagesList.innerHTML = "<em>No pages selected</em>";
					return;
				}

				const selectedPagesData = [];

				// Collect data for selected pages
				selectedPages.forEach((url) => {
					const page = allPages.find((p) => p.url === url);
					if (page) {
						const breadcrumbPath = page.breadcrumbs && page.breadcrumbs.length > 0 
							? page.breadcrumbs.join(' / ') 
							: 'Root';
						
						selectedPagesData.push({
							title: generateSpecificTitle(page),
							url: page.url,
							siteName: page.siteName,
							breadcrumbPath: breadcrumbPath,
						});
					}
				});

				// Sort by site name then by breadcrumb path
				selectedPagesData.sort((a, b) => {
					if (a.siteName !== b.siteName) {
						return a.siteName.localeCompare(b.siteName);
					}
					return a.breadcrumbPath.localeCompare(b.breadcrumbPath);
				});

				// Generate HTML
				const listHtml = selectedPagesData
					.map(
						(page) => `
					<div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--ao-border-color);">
						<div style="font-weight: 500; color: var(--ao-text-color);">${page.title}</div>
						<div style="font-size: 12px; color: var(--ao-secondary-text); margin-top: 2px;">
							${page.siteName} → <a href="${page.url}" target="_blank" rel="noopener noreferrer" style="color: var(--ao-secondary-text); text-decoration: none;" 
							onmouseover="this.style.textDecoration='underline'" 
							onmouseout="this.style.textDecoration='none'">${page.breadcrumbPath}</a>
						</div>
					</div>
				`,
					)
					.join("");

				selectedPagesList.innerHTML = listHtml;
			}



			// Update loading message (optimistic UI shows instead)
			function updateLoadingMessage(title, description) {
				// With optimistic UI, we just update the skeleton message
				const optimisticMessage = document.querySelector('#optimistic-tree > div:first-child');
				if (optimisticMessage) {
					optimisticMessage.textContent = description;
				}
				
				// Keep the old loading message hidden since we show optimistic UI
				console.log(`Loading: ${title} - ${description}`);
			}

			// Show error message
			function showError(message) {
				docsTree.innerHTML = `
					<div style="padding: 32px; text-align: center; color: var(--ao-error-color, #dc3545);">
						<h3>❌ Error</h3>
						<p>${message}</p>
						<button class="btn" onclick="location.reload()">Retry</button>
					</div>
				`;
			}

			// Action button handlers
			selectAllBtn.addEventListener("click", () => {
				// First, update all checkboxes immediately for instant visual feedback
				const pageCheckboxes = document.querySelectorAll(".page-checkbox");
				const siteCheckboxes = document.querySelectorAll(".site-checkbox");
				
				// Update page checkboxes visually first
				pageCheckboxes.forEach((checkbox) => {
					checkbox.checked = true;
				});
				
				// Update site checkboxes visually first
				siteCheckboxes.forEach((checkbox) => {
					checkbox.checked = true;
					checkbox.indeterminate = false;
				});
				
				// Then batch update the data structures
				requestAnimationFrame(() => {
					// Clear and rebuild selectedPages set efficiently
					selectedPages.clear();
					pageCheckboxes.forEach((checkbox) => {
						selectedPages.add(checkbox.dataset.url);
					});
					
					// Update counts once at the end
					updateSelectionCount();
				});
			});

			clearAllBtn.addEventListener("click", () => {
				// Update UI immediately for instant visual feedback
				document
					.querySelectorAll('input[type="checkbox"]')
					.forEach((checkbox) => {
						checkbox.checked = false;
						checkbox.indeterminate = false;
					});
				
				// Then batch update the data structures
				requestAnimationFrame(() => {
					selectedPages.clear();
					updateSelectionCount();
				});
			});

			generateBtn.addEventListener("click", async () => {
				if (selectedPages.size === 0) return;

				try {
					// Show progress
					progressContainer.style.display = "block";
					progressText.textContent = `Fetching ${selectedPages.size} pages...`;

					const selectedUrls = Array.from(selectedPages);
					
					// Use the enhanced batch processing with optimized parallel processing
					const batchResult = await batchFetchAndClean(selectedUrls, {
						concurrency: 5,
						qualityThreshold: 0.3,
						useOptimizedBatch: true,
						onProgress: (completed, total, currentUrl, qualityScore) => {
							const percent = Math.round((completed / total) * 100);
							progressFill.style.width = `${percent}%`;
							
							// Enhanced progress text with quality info
							if (qualityScore !== undefined) {
								progressText.textContent = `Processing: ${completed}/${total} (${percent}%)`;
							} else {
								progressText.textContent = `Processing: ${completed}/${total} (${percent}%)`;
							}
						},
						onError: (url, error) => {
							console.warn(`Failed to process ${url}:`, error.message);
						},
						onQualityFilter: (url, score, reason) => {
							console.log(`Filtered low-quality content from ${url}: ${reason} (Score: ${score.toFixed(2)})`);
						}
					});

					// Extract results array from batch result
					const cleanedPages = batchResult.results || batchResult;

					// Show processing summary
					if (batchResult.summary) {
						const { total, successful, failed } = batchResult.summary;
						progressText.textContent = `Processed ${successful}/${total} pages successfully. Generating document...`;
					} else {
						progressText.textContent = "Generating llms.txt...";
					}

					// Generate LLMs.txt
					const llmsTxt = generateLLMsTxt(cleanedPages);

					// Download
					const timestamp = new Date().toISOString().split("T")[0];
					downloadFile(
						llmsTxt,
						`permaweb-docs-${timestamp}.llms.txt`,
						"text/plain",
					);

					// Hide progress with success message
					if (batchResult.summary) {
						const { successful, failed } = batchResult.summary;
						progressText.textContent = `Generated document with ${successful} pages${failed > 0 ? ` (${failed} failed)` : ''}`;
						setTimeout(() => {
							progressContainer.style.display = "none";
						}, 2000);
					} else {
						progressContainer.style.display = "none";
					}
				} catch (error) {
					console.error("Generation failed:", error);
					progressText.textContent = `❌ Error: ${error.message}`;
					setTimeout(() => {
						progressContainer.style.display = "none";
					}, 5000);
				}
			});

			// Initialize the application
			initialize();
		</script>
	</body>
</html>
